{
  "fullClassName": "junit.framework.TestCase",
  "className": "TestCase",
  "index": 14,
  "modifier": "[public , abstract ]",
  "extend": "[Assert]",
  "implement": "[Test]",
  "packageName": "junit.framework",
  "packageDeclaration": "package junit.framework;",
  "classSignature": "public abstract class TestCase",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": true,
  "imports": [
    "import java.lang.reflect.*;"
  ],
  "fields": [
    "private String fName;"
  ],
  "superClasses": [
    "Assert"
  ],
  "implementedTypes": [
    "Test"
  ],
  "methodSigs": {
    "countTestCases()": "0",
    "createResult()": "1",
    "run()": "2",
    "run(TestResult)": "3",
    "runBare()": "4",
    "runTest()": "5",
    "setUp()": "6",
    "tearDown()": "7",
    "toString()": "8",
    "getName()": "9",
    "setName(String)": "10",
    "TestCase()": "11",
    "TestCase(String)": "12"
  },
  "methodsBrief": [
    "public int countTestCases(){}",
    "protected TestResult createResult(){}",
    "public TestResult run(){}",
    "public void run(TestResult result){}",
    "public void runBare() throws Throwable{}",
    "protected void runTest() throws Throwable{}",
    "protected void setUp() throws Exception{}",
    "protected void tearDown() throws Exception{}",
    "public String toString(){}",
    "public String getName(){}",
    "public void setName(String name){}",
    "public TestCase(){}",
    "public TestCase(String name){}"
  ],
  "constructorSigs": [
    "TestCase()",
    "TestCase(String)"
  ],
  "constructorBrief": [
    "public TestCase(){}",
    "public TestCase(String name){}"
  ],
  "getterSetterSigs": [
    "setUp()",
    "getName()",
    "setName(String)"
  ],
  "getterSetterBrief": [
    "protected void setUp() throws Exception{}",
    "public String getName(){}",
    "public void setName(String name){}"
  ],
  "constructorDeps": {
    "java.lang.String": []
  },
  "compilationUnitCode": "package junit.framework;\r\n\r\nimport java.lang.reflect.*;\r\n\r\n/**\r\n * A test case defines the fixture to run multiple tests. To define a test case<br>\r\n * 1) implement a subclass of TestCase<br>\r\n * 2) define instance variables that store the state of the fixture<br>\r\n * 3) initialize the fixture state by overriding <code>setUp</code><br>\r\n * 4) clean-up after a test by overriding <code>tearDown</code>.<br>\r\n * Each test runs in its own fixture so there\r\n * can be no side effects among test runs.\r\n * Here is an example:\r\n * <pre>\r\n * public class MathTest extends TestCase {\r\n *     protected double fValue1;\r\n *     protected double fValue2;\r\n *\r\n *    protected void setUp() {\r\n *         fValue1= 2.0;\r\n *         fValue2= 3.0;\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * For each test implement a method which interacts\r\n * with the fixture. Verify the expected results with assertions specified\r\n * by calling <code>assertTrue</code> with a boolean.\r\n * <pre>\r\n *    public void testAdd() {\r\n *        double result= fValue1 + fValue2;\r\n *        assertTrue(result == 5.0);\r\n *    }\r\n * </pre>\r\n * Once the methods are defined you can run them. The framework supports\r\n * both a static type safe and more dynamic way to run a test.\r\n * In the static way you override the runTest method and define the method to\r\n * be invoked. A convenient way to do so is with an anonymous inner class.\r\n * <pre>\r\n * TestCase test= new MathTest(\"add\") {\r\n *        public void runTest() {\r\n *            testAdd();\r\n *        }\r\n * };\r\n * test.run();\r\n * </pre>\r\n * The dynamic way uses reflection to implement <code>runTest</code>. It dynamically finds\r\n * and invokes a method.\r\n * In this case the name of the test case has to correspond to the test method\r\n * to be run.\r\n * <pre>\r\n * TestCase= new MathTest(\"testAdd\");\r\n * test.run();\r\n * </pre>\r\n * The tests to be run can be collected into a TestSuite. JUnit provides\r\n * different <i>test runners</i> which can run a test suite and collect the results.\r\n * A test runner either expects a static method <code>suite</code> as the entry\r\n * point to get a test to run or it will extract the suite automatically.\r\n * <pre>\r\n * public static Test suite() {\r\n *      suite.addTest(new MathTest(\"testAdd\"));\r\n *      suite.addTest(new MathTest(\"testDivideByZero\"));\r\n *      return suite;\r\n *  }\r\n * </pre>\r\n * @see TestResult\r\n * @see TestSuite\r\n */\r\npublic abstract class TestCase extends Assert implements Test {\r\n\r\n    /**\r\n     * the name of the test case\r\n     */\r\n    private String fName;\r\n\r\n    public TestCase() {\r\n        fName = null;\r\n    }\r\n\r\n    public TestCase(String name) {\r\n        fName = name;\r\n    }\r\n\r\n    /**\r\n     * Counts the number of test cases executed by run(TestResult result).\r\n     */\r\n    public int countTestCases() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a default TestResult object\r\n     *\r\n     * @see TestResult\r\n     */\r\n    protected TestResult createResult() {\r\n        return new TestResult();\r\n    }\r\n\r\n    /**\r\n     * A convenience method to run this test, collecting the results with a\r\n     * default TestResult object.\r\n     *\r\n     * @see TestResult\r\n     */\r\n    public TestResult run() {\r\n        TestResult result = createResult();\r\n        run(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Runs the test case and collects the results in TestResult.\r\n     */\r\n    public void run(TestResult result) {\r\n        result.run(this);\r\n    }\r\n\r\n    /**\r\n     * Runs the bare test sequence.\r\n     * @exception Throwable if any exception is thrown\r\n     */\r\n    public void runBare() throws Throwable {\r\n        setUp();\r\n        try {\r\n            runTest();\r\n        } finally {\r\n            tearDown();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Override to run the test and assert its state.\r\n     * @exception Throwable if any exception is thrown\r\n     */\r\n    protected void runTest() throws Throwable {\r\n        assertNotNull(fName);\r\n        Method runMethod = null;\r\n        try {\r\n            // use getMethod to get all public inherited\r\n            // methods. getDeclaredMethods returns all\r\n            // methods of this class but excludes the\r\n            // inherited ones.\r\n            runMethod = getClass().getMethod(fName, null);\r\n        } catch (NoSuchMethodException e) {\r\n            fail(\"Method \\\"\" + fName + \"\\\" not found\");\r\n        }\r\n        if (!Modifier.isPublic(runMethod.getModifiers())) {\r\n            fail(\"Method \\\"\" + fName + \"\\\" should be public\");\r\n        }\r\n        try {\r\n            runMethod.invoke(this, new Class[0]);\r\n        } catch (InvocationTargetException e) {\r\n            e.fillInStackTrace();\r\n            throw e.getTargetException();\r\n        } catch (IllegalAccessException e) {\r\n            e.fillInStackTrace();\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up the fixture, for example, open a network connection.\r\n     * This method is called before a test is executed.\r\n     */\r\n    protected void setUp() throws Exception {\r\n    }\r\n\r\n    /**\r\n     * Tears down the fixture, for example, close a network connection.\r\n     * This method is called after a test is executed.\r\n     */\r\n    protected void tearDown() throws Exception {\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the test case\r\n     */\r\n    public String toString() {\r\n        return getName() + \"(\" + getClass().getName() + \")\";\r\n    }\r\n\r\n    /**\r\n     * Gets the name of a TestCase\r\n     * @return returns a String\r\n     */\r\n    public String getName() {\r\n        return fName;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of a TestCase\r\n     * @param name The name to set\r\n     */\r\n    public void setName(String name) {\r\n        fName = name;\r\n    }\r\n}\r\n",
  "classDeclarationCode": "/**\r\n * A test case defines the fixture to run multiple tests. To define a test case<br>\r\n * 1) implement a subclass of TestCase<br>\r\n * 2) define instance variables that store the state of the fixture<br>\r\n * 3) initialize the fixture state by overriding <code>setUp</code><br>\r\n * 4) clean-up after a test by overriding <code>tearDown</code>.<br>\r\n * Each test runs in its own fixture so there\r\n * can be no side effects among test runs.\r\n * Here is an example:\r\n * <pre>\r\n * public class MathTest extends TestCase {\r\n *     protected double fValue1;\r\n *     protected double fValue2;\r\n *\r\n *    protected void setUp() {\r\n *         fValue1= 2.0;\r\n *         fValue2= 3.0;\r\n *     }\r\n * }\r\n * </pre>\r\n *\r\n * For each test implement a method which interacts\r\n * with the fixture. Verify the expected results with assertions specified\r\n * by calling <code>assertTrue</code> with a boolean.\r\n * <pre>\r\n *    public void testAdd() {\r\n *        double result= fValue1 + fValue2;\r\n *        assertTrue(result == 5.0);\r\n *    }\r\n * </pre>\r\n * Once the methods are defined you can run them. The framework supports\r\n * both a static type safe and more dynamic way to run a test.\r\n * In the static way you override the runTest method and define the method to\r\n * be invoked. A convenient way to do so is with an anonymous inner class.\r\n * <pre>\r\n * TestCase test= new MathTest(\"add\") {\r\n *        public void runTest() {\r\n *            testAdd();\r\n *        }\r\n * };\r\n * test.run();\r\n * </pre>\r\n * The dynamic way uses reflection to implement <code>runTest</code>. It dynamically finds\r\n * and invokes a method.\r\n * In this case the name of the test case has to correspond to the test method\r\n * to be run.\r\n * <pre>\r\n * TestCase= new MathTest(\"testAdd\");\r\n * test.run();\r\n * </pre>\r\n * The tests to be run can be collected into a TestSuite. JUnit provides\r\n * different <i>test runners</i> which can run a test suite and collect the results.\r\n * A test runner either expects a static method <code>suite</code> as the entry\r\n * point to get a test to run or it will extract the suite automatically.\r\n * <pre>\r\n * public static Test suite() {\r\n *      suite.addTest(new MathTest(\"testAdd\"));\r\n *      suite.addTest(new MathTest(\"testDivideByZero\"));\r\n *      return suite;\r\n *  }\r\n * </pre>\r\n * @see TestResult\r\n * @see TestSuite\r\n */\r\npublic abstract class TestCase extends Assert implements Test {\r\n\r\n    /**\r\n     * the name of the test case\r\n     */\r\n    private String fName;\r\n\r\n    public TestCase() {\r\n        fName = null;\r\n    }\r\n\r\n    public TestCase(String name) {\r\n        fName = name;\r\n    }\r\n\r\n    /**\r\n     * Counts the number of test cases executed by run(TestResult result).\r\n     */\r\n    public int countTestCases() {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Creates a default TestResult object\r\n     *\r\n     * @see TestResult\r\n     */\r\n    protected TestResult createResult() {\r\n        return new TestResult();\r\n    }\r\n\r\n    /**\r\n     * A convenience method to run this test, collecting the results with a\r\n     * default TestResult object.\r\n     *\r\n     * @see TestResult\r\n     */\r\n    public TestResult run() {\r\n        TestResult result = createResult();\r\n        run(result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Runs the test case and collects the results in TestResult.\r\n     */\r\n    public void run(TestResult result) {\r\n        result.run(this);\r\n    }\r\n\r\n    /**\r\n     * Runs the bare test sequence.\r\n     * @exception Throwable if any exception is thrown\r\n     */\r\n    public void runBare() throws Throwable {\r\n        setUp();\r\n        try {\r\n            runTest();\r\n        } finally {\r\n            tearDown();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Override to run the test and assert its state.\r\n     * @exception Throwable if any exception is thrown\r\n     */\r\n    protected void runTest() throws Throwable {\r\n        assertNotNull(fName);\r\n        Method runMethod = null;\r\n        try {\r\n            // use getMethod to get all public inherited\r\n            // methods. getDeclaredMethods returns all\r\n            // methods of this class but excludes the\r\n            // inherited ones.\r\n            runMethod = getClass().getMethod(fName, null);\r\n        } catch (NoSuchMethodException e) {\r\n            fail(\"Method \\\"\" + fName + \"\\\" not found\");\r\n        }\r\n        if (!Modifier.isPublic(runMethod.getModifiers())) {\r\n            fail(\"Method \\\"\" + fName + \"\\\" should be public\");\r\n        }\r\n        try {\r\n            runMethod.invoke(this, new Class[0]);\r\n        } catch (InvocationTargetException e) {\r\n            e.fillInStackTrace();\r\n            throw e.getTargetException();\r\n        } catch (IllegalAccessException e) {\r\n            e.fillInStackTrace();\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up the fixture, for example, open a network connection.\r\n     * This method is called before a test is executed.\r\n     */\r\n    protected void setUp() throws Exception {\r\n    }\r\n\r\n    /**\r\n     * Tears down the fixture, for example, close a network connection.\r\n     * This method is called after a test is executed.\r\n     */\r\n    protected void tearDown() throws Exception {\r\n    }\r\n\r\n    /**\r\n     * Returns a string representation of the test case\r\n     */\r\n    public String toString() {\r\n        return getName() + \"(\" + getClass().getName() + \")\";\r\n    }\r\n\r\n    /**\r\n     * Gets the name of a TestCase\r\n     * @return returns a String\r\n     */\r\n    public String getName() {\r\n        return fName;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of a TestCase\r\n     * @param name The name to set\r\n     */\r\n    public void setName(String name) {\r\n        fName = name;\r\n    }\r\n}",
  "subClasses": []
}