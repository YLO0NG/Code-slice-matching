{
  "fullClassName": "junit.runner.TestCaseClassLoader",
  "className": "TestCaseClassLoader",
  "index": 28,
  "modifier": "[public ]",
  "extend": "[ClassLoader]",
  "implement": "[]",
  "packageName": "junit.runner",
  "packageDeclaration": "package junit.runner;",
  "classSignature": "public class TestCaseClassLoader",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.util.*;",
    "import java.io.*;",
    "import java.net.URL;",
    "import java.util.zip.*;"
  ],
  "fields": [
    "private Vector fPathItems;",
    "private String[] defaultExclusions= {\r\n\t\t\"junit.framework.\", \r\n\t\t\"junit.extensions.\", \r\n\t\t\"junit.runner.\"\r\n\t};",
    "static final String EXCLUDED_FILE= \"excluded.properties\";",
    "private Vector fExcluded;"
  ],
  "superClasses": [
    "ClassLoader"
  ],
  "implementedTypes": [],
  "methodSigs": {
    "scanPath(String)": "0",
    "getResource(String)": "1",
    "getResourceAsStream(String)": "2",
    "isExcluded(String)": "3",
    "loadClass(String, boolean)": "4",
    "lookupClassData(String)": "5",
    "isJar(String)": "6",
    "loadFileData(String, String)": "7",
    "getClassData(File)": "8",
    "loadJarData(String, String)": "9",
    "readExcludedPackages()": "10",
    "TestCaseClassLoader()": "11",
    "TestCaseClassLoader(String)": "12"
  },
  "methodsBrief": [
    "private void scanPath(String classPath){}",
    "public URL getResource(String name){}",
    "public InputStream getResourceAsStream(String name){}",
    "public boolean isExcluded(String name){}",
    "public synchronized Class loadClass(String name, boolean resolve)\r\r\n\t\tthrows ClassNotFoundException{}",
    "private byte[] lookupClassData(String className) throws ClassNotFoundException{}",
    "boolean isJar(String pathEntry){}",
    "private byte[] loadFileData(String path, String fileName){}",
    "private byte[] getClassData(File f){}",
    "private byte[] loadJarData(String path, String fileName){}",
    "private void readExcludedPackages(){}",
    "public TestCaseClassLoader(){}",
    "public TestCaseClassLoader(String classPath){}"
  ],
  "constructorSigs": [
    "TestCaseClassLoader()",
    "TestCaseClassLoader(String)"
  ],
  "constructorBrief": [
    "public TestCaseClassLoader(){}",
    "public TestCaseClassLoader(String classPath){}"
  ],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {
    "java.lang.System": [
      "getProperty(String)"
    ],
    "java.lang.String": [],
    "junit.runner.TestCaseClassLoader": [
      "readExcludedPackages()",
      "scanPath(String)"
    ]
  },
  "compilationUnitCode": "package junit.runner;\r\n\r\nimport java.util.*;\r\nimport java.io.*;\r\nimport java.net.URL;\r\nimport java.util.zip.*;\r\n\r\n/**\r\n * A custom class loader which enables the reloading\r\n * of classes for each test run. The class loader\r\n * can be configured with a list of package paths that\r\n * should be excluded from loading. The loading\r\n * of these packages is delegated to the system class\r\n * loader. They will be shared across test runs.\r\n * <p>\r\n * The list of excluded package paths is specified in\r\n * a properties file \"excluded.properties\" that is located in\r\n * the same place as the TestCaseClassLoader class.\r\n * <p>\r\n * <b>Known limitation:</b> the TestCaseClassLoader cannot load classes\r\n * from jar files.\r\n */\r\npublic class TestCaseClassLoader extends ClassLoader {\r\n\r\n    /**\r\n     * scanned class path\r\n     */\r\n    private Vector fPathItems;\r\n\r\n    /**\r\n     * default excluded paths\r\n     */\r\n    private String[] defaultExclusions = { \"junit.framework.\", \"junit.extensions.\", \"junit.runner.\" };\r\n\r\n    /**\r\n     * name of excluded properties file\r\n     */\r\n    static final String EXCLUDED_FILE = \"excluded.properties\";\r\n\r\n    /**\r\n     * excluded paths\r\n     */\r\n    private Vector fExcluded;\r\n\r\n    public TestCaseClassLoader() {\r\n        this(System.getProperty(\"java.class.path\"));\r\n    }\r\n\r\n    public TestCaseClassLoader(String classPath) {\r\n        scanPath(classPath);\r\n        readExcludedPackages();\r\n    }\r\n\r\n    private void scanPath(String classPath) {\r\n        String separator = System.getProperty(\"path.separator\");\r\n        fPathItems = new Vector(10);\r\n        StringTokenizer st = new StringTokenizer(classPath, separator);\r\n        while (st.hasMoreTokens()) {\r\n            fPathItems.addElement(st.nextToken());\r\n        }\r\n    }\r\n\r\n    public URL getResource(String name) {\r\n        return ClassLoader.getSystemResource(name);\r\n    }\r\n\r\n    public InputStream getResourceAsStream(String name) {\r\n        return ClassLoader.getSystemResourceAsStream(name);\r\n    }\r\n\r\n    public boolean isExcluded(String name) {\r\n        for (int i = 0; i < fExcluded.size(); i++) {\r\n            if (name.startsWith((String) fExcluded.elementAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {\r\n        Class c = findLoadedClass(name);\r\n        if (c != null)\r\n            return c;\r\n        // \r\n        // Delegate the loading of excluded classes to the\r\n        // standard class loader.\r\n        // \r\n        if (isExcluded(name)) {\r\n            try {\r\n                c = findSystemClass(name);\r\n                return c;\r\n            } catch (ClassNotFoundException e) {\r\n                // keep searching\r\n            }\r\n        }\r\n        if (c == null) {\r\n            byte[] data = lookupClassData(name);\r\n            if (data == null)\r\n                throw new ClassNotFoundException();\r\n            c = defineClass(name, data, 0, data.length);\r\n        }\r\n        if (resolve)\r\n            resolveClass(c);\r\n        return c;\r\n    }\r\n\r\n    private byte[] lookupClassData(String className) throws ClassNotFoundException {\r\n        byte[] data = null;\r\n        for (int i = 0; i < fPathItems.size(); i++) {\r\n            String path = (String) fPathItems.elementAt(i);\r\n            String fileName = className.replace('.', '/') + \".class\";\r\n            if (isJar(path)) {\r\n                data = loadJarData(path, fileName);\r\n            } else {\r\n                data = loadFileData(path, fileName);\r\n            }\r\n            if (data != null)\r\n                return data;\r\n        }\r\n        throw new ClassNotFoundException(className);\r\n    }\r\n\r\n    boolean isJar(String pathEntry) {\r\n        return pathEntry.endsWith(\".jar\") || pathEntry.endsWith(\".zip\");\r\n    }\r\n\r\n    private byte[] loadFileData(String path, String fileName) {\r\n        File file = new File(path, fileName);\r\n        if (file.exists()) {\r\n            return getClassData(file);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private byte[] getClassData(File f) {\r\n        try {\r\n            FileInputStream stream = new FileInputStream(f);\r\n            ByteArrayOutputStream out = new ByteArrayOutputStream(1000);\r\n            byte[] b = new byte[1000];\r\n            int n;\r\n            while ((n = stream.read(b)) != -1) out.write(b, 0, n);\r\n            stream.close();\r\n            out.close();\r\n            return out.toByteArray();\r\n        } catch (IOException e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private byte[] loadJarData(String path, String fileName) {\r\n        ZipFile zipFile = null;\r\n        InputStream stream = null;\r\n        File archive = new File(path);\r\n        if (!archive.exists())\r\n            return null;\r\n        try {\r\n            zipFile = new ZipFile(archive);\r\n        } catch (IOException io) {\r\n            return null;\r\n        }\r\n        ZipEntry entry = zipFile.getEntry(fileName);\r\n        if (entry == null)\r\n            return null;\r\n        int size = (int) entry.getSize();\r\n        try {\r\n            stream = zipFile.getInputStream(entry);\r\n            byte[] data = new byte[size];\r\n            int pos = 0;\r\n            while (pos < size) {\r\n                int n = stream.read(data, pos, data.length - pos);\r\n                pos += n;\r\n            }\r\n            zipFile.close();\r\n            return data;\r\n        } catch (IOException e) {\r\n        } finally {\r\n            try {\r\n                if (stream != null)\r\n                    stream.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private void readExcludedPackages() {\r\n        fExcluded = new Vector(10);\r\n        for (int i = 0; i < defaultExclusions.length; i++) fExcluded.addElement(defaultExclusions[i]);\r\n        InputStream is = getClass().getResourceAsStream(EXCLUDED_FILE);\r\n        if (is == null)\r\n            return;\r\n        Properties p = new Properties();\r\n        try {\r\n            p.load(is);\r\n        } catch (IOException e) {\r\n            return;\r\n        } finally {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n        for (Enumeration e = p.propertyNames(); e.hasMoreElements(); ) {\r\n            String key = (String) e.nextElement();\r\n            if (key.startsWith(\"excluded.\")) {\r\n                String path = p.getProperty(key);\r\n                path = path.trim();\r\n                if (path.endsWith(\"*\"))\r\n                    path = path.substring(0, path.length() - 1);\r\n                if (path.length() > 0)\r\n                    fExcluded.addElement(path);\r\n            }\r\n        }\r\n    }\r\n}\r\n",
  "classDeclarationCode": "/**\r\n * A custom class loader which enables the reloading\r\n * of classes for each test run. The class loader\r\n * can be configured with a list of package paths that\r\n * should be excluded from loading. The loading\r\n * of these packages is delegated to the system class\r\n * loader. They will be shared across test runs.\r\n * <p>\r\n * The list of excluded package paths is specified in\r\n * a properties file \"excluded.properties\" that is located in\r\n * the same place as the TestCaseClassLoader class.\r\n * <p>\r\n * <b>Known limitation:</b> the TestCaseClassLoader cannot load classes\r\n * from jar files.\r\n */\r\npublic class TestCaseClassLoader extends ClassLoader {\r\n\r\n    /**\r\n     * scanned class path\r\n     */\r\n    private Vector fPathItems;\r\n\r\n    /**\r\n     * default excluded paths\r\n     */\r\n    private String[] defaultExclusions = { \"junit.framework.\", \"junit.extensions.\", \"junit.runner.\" };\r\n\r\n    /**\r\n     * name of excluded properties file\r\n     */\r\n    static final String EXCLUDED_FILE = \"excluded.properties\";\r\n\r\n    /**\r\n     * excluded paths\r\n     */\r\n    private Vector fExcluded;\r\n\r\n    public TestCaseClassLoader() {\r\n        this(System.getProperty(\"java.class.path\"));\r\n    }\r\n\r\n    public TestCaseClassLoader(String classPath) {\r\n        scanPath(classPath);\r\n        readExcludedPackages();\r\n    }\r\n\r\n    private void scanPath(String classPath) {\r\n        String separator = System.getProperty(\"path.separator\");\r\n        fPathItems = new Vector(10);\r\n        StringTokenizer st = new StringTokenizer(classPath, separator);\r\n        while (st.hasMoreTokens()) {\r\n            fPathItems.addElement(st.nextToken());\r\n        }\r\n    }\r\n\r\n    public URL getResource(String name) {\r\n        return ClassLoader.getSystemResource(name);\r\n    }\r\n\r\n    public InputStream getResourceAsStream(String name) {\r\n        return ClassLoader.getSystemResourceAsStream(name);\r\n    }\r\n\r\n    public boolean isExcluded(String name) {\r\n        for (int i = 0; i < fExcluded.size(); i++) {\r\n            if (name.startsWith((String) fExcluded.elementAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {\r\n        Class c = findLoadedClass(name);\r\n        if (c != null)\r\n            return c;\r\n        // \r\n        // Delegate the loading of excluded classes to the\r\n        // standard class loader.\r\n        // \r\n        if (isExcluded(name)) {\r\n            try {\r\n                c = findSystemClass(name);\r\n                return c;\r\n            } catch (ClassNotFoundException e) {\r\n                // keep searching\r\n            }\r\n        }\r\n        if (c == null) {\r\n            byte[] data = lookupClassData(name);\r\n            if (data == null)\r\n                throw new ClassNotFoundException();\r\n            c = defineClass(name, data, 0, data.length);\r\n        }\r\n        if (resolve)\r\n            resolveClass(c);\r\n        return c;\r\n    }\r\n\r\n    private byte[] lookupClassData(String className) throws ClassNotFoundException {\r\n        byte[] data = null;\r\n        for (int i = 0; i < fPathItems.size(); i++) {\r\n            String path = (String) fPathItems.elementAt(i);\r\n            String fileName = className.replace('.', '/') + \".class\";\r\n            if (isJar(path)) {\r\n                data = loadJarData(path, fileName);\r\n            } else {\r\n                data = loadFileData(path, fileName);\r\n            }\r\n            if (data != null)\r\n                return data;\r\n        }\r\n        throw new ClassNotFoundException(className);\r\n    }\r\n\r\n    boolean isJar(String pathEntry) {\r\n        return pathEntry.endsWith(\".jar\") || pathEntry.endsWith(\".zip\");\r\n    }\r\n\r\n    private byte[] loadFileData(String path, String fileName) {\r\n        File file = new File(path, fileName);\r\n        if (file.exists()) {\r\n            return getClassData(file);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private byte[] getClassData(File f) {\r\n        try {\r\n            FileInputStream stream = new FileInputStream(f);\r\n            ByteArrayOutputStream out = new ByteArrayOutputStream(1000);\r\n            byte[] b = new byte[1000];\r\n            int n;\r\n            while ((n = stream.read(b)) != -1) out.write(b, 0, n);\r\n            stream.close();\r\n            out.close();\r\n            return out.toByteArray();\r\n        } catch (IOException e) {\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private byte[] loadJarData(String path, String fileName) {\r\n        ZipFile zipFile = null;\r\n        InputStream stream = null;\r\n        File archive = new File(path);\r\n        if (!archive.exists())\r\n            return null;\r\n        try {\r\n            zipFile = new ZipFile(archive);\r\n        } catch (IOException io) {\r\n            return null;\r\n        }\r\n        ZipEntry entry = zipFile.getEntry(fileName);\r\n        if (entry == null)\r\n            return null;\r\n        int size = (int) entry.getSize();\r\n        try {\r\n            stream = zipFile.getInputStream(entry);\r\n            byte[] data = new byte[size];\r\n            int pos = 0;\r\n            while (pos < size) {\r\n                int n = stream.read(data, pos, data.length - pos);\r\n                pos += n;\r\n            }\r\n            zipFile.close();\r\n            return data;\r\n        } catch (IOException e) {\r\n        } finally {\r\n            try {\r\n                if (stream != null)\r\n                    stream.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private void readExcludedPackages() {\r\n        fExcluded = new Vector(10);\r\n        for (int i = 0; i < defaultExclusions.length; i++) fExcluded.addElement(defaultExclusions[i]);\r\n        InputStream is = getClass().getResourceAsStream(EXCLUDED_FILE);\r\n        if (is == null)\r\n            return;\r\n        Properties p = new Properties();\r\n        try {\r\n            p.load(is);\r\n        } catch (IOException e) {\r\n            return;\r\n        } finally {\r\n            try {\r\n                is.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n        for (Enumeration e = p.propertyNames(); e.hasMoreElements(); ) {\r\n            String key = (String) e.nextElement();\r\n            if (key.startsWith(\"excluded.\")) {\r\n                String path = p.getProperty(key);\r\n                path = path.trim();\r\n                if (path.endsWith(\"*\"))\r\n                    path = path.substring(0, path.length() - 1);\r\n                if (path.length() > 0)\r\n                    fExcluded.addElement(path);\r\n            }\r\n        }\r\n    }\r\n}",
  "subClasses": []
}