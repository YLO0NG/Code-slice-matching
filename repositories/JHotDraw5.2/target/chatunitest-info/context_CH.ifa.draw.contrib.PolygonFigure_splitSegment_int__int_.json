{
  "targetClass": "CH.ifa.draw.contrib.PolygonFigure",
  "targetMethod": "splitSegment(int, int)",
  "dependentFields": {
    "CH.ifa.draw.contrib.PolygonFigure": "static final int TOO_CLOSE = 2;\nprivate static final long serialVersionUID = 6254089689239215026L;\nprivate int polygonFigureSerializedDataVersion = 1;\nprotected Polygon fPoly = new Polygon();"
  },
  "dependentMethods": {
    "CH.ifa.draw.contrib.PolygonFigure": "public static double distanceFromLine(int xa, int ya,\r\n                                        int xb, int yb,\r\n                                        int xc, int yc){}\npublic  void insertPointAt(Point p, int i){}"
  },
  "dependentMethodBodies": {
    "CH.ifa.draw.contrib.PolygonFigure": "* compute distance of point from line segment, or\n   * Double.MAX_VALUE if perpendicular projection is outside segment; or\n   * If pts on line are same, return distance from point\n   *\npublic static double distanceFromLine(int xa, int ya,\n                                        int xb, int yb,\n                                        int xc, int yc) {\n\n\n    // source:http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html#q7\n    //Let the point be C (XC,YC) and the line be AB (XA,YA) to (XB,YB).\n    //The length of the\n    //      line segment AB is L:\n    //\n    //                    ___________________\n    //                   |        2         2\n    //              L = \\| (XB-XA) + (YB-YA)\n    //and\n    //\n    //                  (YA-YC)(YA-YB)-(XA-XC)(XB-XA)\n    //              r = -----------------------------\n    //                              L**2\n    //\n    //                  (YA-YC)(XB-XA)-(XA-XC)(YB-YA)\n    //              s = -----------------------------\n    //                              L**2\n    //\n    //      Let I be the point of perpendicular projection of C onto AB, the\n    //\n    //              XI=XA+r(XB-XA)\n    //              YI=YA+r(YB-YA)\n    //\n    //      Distance from A to I = r*L\n    //      Distance from C to I = s*L\n    //\n    //      If r < 0 I is on backward extension of AB\n    //      If r>1 I is on ahead extension of AB\n    //      If 0<=r<=1 I is on AB\n    //\n    //      If s < 0 C is left of AB (you can just check the numerator)\n    //      If s>0 C is right of AB\n    //      If s=0 C is on AB\n\n    int xdiff = xb - xa;\n    int ydiff = yb - ya;\n    long l2 = xdiff*xdiff + ydiff*ydiff;\n\n    if (l2 == 0) return Geom.length(xa, ya, xc, yc);\n\n    double rnum =  (ya-yc) * (ya-yb) - (xa-xc) * (xb-xa);\n    double r = rnum / l2;\n\n    if (r < 0.0 || r > 1.0) return Double.MAX_VALUE;\n\n    double xi = xa + r * xdiff;\n    double yi = ya + r * ydiff;\n    double xd = xc - xi;\n    double yd = yc - yi;\n    return Math.sqrt(xd * xd + yd * yd);\n\n    /*\n      for directional version, instead use\n      double snum =  (ya-yc) * (xb-xa) - (xa-xc) * (yb-ya);\n      double s = snum / l2;\n\n      double l = Math.sqrt((double)l2);\n      return = s * l;\n      */\n  }\n\n   * Insert a node at the given point.\n   \npublic  void insertPointAt(Point p, int i) {\n    willChange();\n    int n = fPoly.npoints + 1;\n    int[] xs = new int[n];\n    int[] ys = new int[n];\n    for (int j = 0; j < i; ++j) {\n      xs[j] = fPoly.xpoints[j];\n      ys[j] = fPoly.ypoints[j];\n    }\n    xs[i] = p.x;\n    ys[i] = p.y;\n    for (int j = i; j < fPoly.npoints; ++j) {\n      xs[j+1] = fPoly.xpoints[j];\n      ys[j+1] = fPoly.ypoints[j];\n    }\n\n    fPoly = new Polygon(xs, ys, n);\n    changed();\n  }"
  }
}