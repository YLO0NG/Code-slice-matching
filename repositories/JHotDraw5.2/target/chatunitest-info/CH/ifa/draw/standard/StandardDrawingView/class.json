{
  "fullClassName": "CH.ifa.draw.standard.StandardDrawingView",
  "className": "StandardDrawingView",
  "index": 143,
  "modifier": "[public ]",
  "extend": "[JPanel]",
  "implement": "[DrawingView, MouseListener, MouseMotionListener, KeyListener]",
  "packageName": "CH.ifa.draw.standard",
  "packageDeclaration": "package CH.ifa.draw.standard;",
  "classSignature": "public  class StandardDrawingView",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.awt.Color;",
    "import java.awt.Dimension;",
    "import java.awt.Graphics;",
    "import java.awt.Point;",
    "import java.awt.PrintGraphics;",
    "import java.awt.Rectangle;",
    "import java.awt.event.KeyEvent;",
    "import java.awt.event.KeyListener;",
    "import java.awt.event.MouseEvent;",
    "import java.awt.event.MouseListener;",
    "import java.awt.event.MouseMotionListener;",
    "import java.io.IOException;",
    "import java.io.ObjectInputStream;",
    "import java.util.Enumeration;",
    "import java.util.Vector;",
    "import javax.swing.JPanel;",
    "import CH.ifa.draw.framework.Drawing;",
    "import CH.ifa.draw.framework.DrawingChangeEvent;",
    "import CH.ifa.draw.framework.DrawingEditor;",
    "import CH.ifa.draw.framework.DrawingView;",
    "import CH.ifa.draw.framework.Figure;",
    "import CH.ifa.draw.framework.FigureEnumeration;",
    "import CH.ifa.draw.framework.FigureSelection;",
    "import CH.ifa.draw.framework.Handle;",
    "import CH.ifa.draw.framework.Painter;",
    "import CH.ifa.draw.framework.PointConstrainer;",
    "import CH.ifa.draw.framework.Tool;",
    "import CH.ifa.draw.util.Command;",
    "import CH.ifa.draw.util.Geom;"
  ],
  "fields": [
    "transient private DrawingEditor   fEditor;",
    "private Drawing         fDrawing;",
    "private transient Rectangle fDamage = null;",
    "transient private Vector fSelection;",
    "transient private Vector fSelectionHandles;",
    "private Dimension fViewSize;",
    "private Point fLastClick;",
    "private Vector fBackgrounds = null;",
    "private Vector fForegrounds = null;",
    "private Painter fUpdateStrategy;",
    "private PointConstrainer fConstrainer;",
    "private static final long serialVersionUID = -3878153366174603336L;",
    "private int drawingViewSerializedDataVersion = 1;"
  ],
  "superClasses": [
    "JPanel"
  ],
  "implementedTypes": [
    "DrawingView",
    "MouseListener",
    "MouseMotionListener",
    "KeyListener"
  ],
  "methodSigs": {
    "setEditor(DrawingEditor)": "0",
    "tool()": "1",
    "drawing()": "2",
    "setDrawing(Drawing)": "3",
    "editor()": "4",
    "add(Figure)": "5",
    "remove(Figure)": "6",
    "addAll(Vector)": "7",
    "getMinimumSize()": "8",
    "getPreferredSize()": "9",
    "setDisplayUpdate(Painter)": "10",
    "selection()": "11",
    "selectionElements()": "12",
    "selectionZOrdered()": "13",
    "selectionCount()": "14",
    "addToSelection(Figure)": "15",
    "addToSelectionAll(Vector)": "16",
    "removeFromSelection(Figure)": "17",
    "toggleSelection(Figure)": "18",
    "clearSelection()": "19",
    "selectionHandles()": "20",
    "getFigureSelection()": "21",
    "findHandle(int, int)": "22",
    "selectionChanged()": "23",
    "lastClick()": "24",
    "setConstrainer(PointConstrainer)": "25",
    "getConstrainer()": "26",
    "constrainPoint(Point)": "27",
    "mousePressed(MouseEvent)": "28",
    "mouseDragged(MouseEvent)": "29",
    "mouseMoved(MouseEvent)": "30",
    "mouseReleased(MouseEvent)": "31",
    "keyPressed(KeyEvent)": "32",
    "handleCursorKey(int)": "33",
    "moveSelection(int, int)": "34",
    "checkDamage()": "35",
    "repairDamage()": "36",
    "drawingInvalidated(DrawingChangeEvent)": "37",
    "drawingRequestUpdate(DrawingChangeEvent)": "38",
    "update(Graphics)": "39",
    "paint(Graphics)": "40",
    "drawAll(Graphics)": "41",
    "drawHandles(Graphics)": "42",
    "drawDrawing(Graphics)": "43",
    "drawBackground(Graphics)": "44",
    "drawPainters(Graphics, Vector)": "45",
    "addBackground(Painter)": "46",
    "removeBackground(Painter)": "47",
    "removeForeground(Painter)": "48",
    "addForeground(Painter)": "49",
    "freezeView()": "50",
    "unfreezeView()": "51",
    "readObject(ObjectInputStream)": "52",
    "checkMinimumSize()": "53",
    "isFocusTraversable()": "54",
    "mouseEntered(MouseEvent)": "55",
    "mouseExited(MouseEvent)": "56",
    "mouseClicked(MouseEvent)": "57",
    "keyTyped(KeyEvent)": "58",
    "keyReleased(KeyEvent)": "59",
    "StandardDrawingView(DrawingEditor, int, int)": "60"
  },
  "methodsBrief": [
    "public void setEditor(DrawingEditor editor){}",
    "public Tool tool(){}",
    "public Drawing drawing(){}",
    "public void setDrawing(Drawing d){}",
    "public DrawingEditor editor(){}",
    "public Figure add(Figure figure){}",
    "public Figure remove(Figure figure){}",
    "public void addAll(Vector figures){}",
    "public Dimension getMinimumSize(){}",
    "public Dimension getPreferredSize(){}",
    "public void setDisplayUpdate(Painter updateStrategy){}",
    "public Vector selection(){}",
    "public FigureEnumeration selectionElements(){}",
    "public Vector selectionZOrdered(){}",
    "public int selectionCount(){}",
    "public void addToSelection(Figure figure){}",
    "public void addToSelectionAll(Vector figures){}",
    "public void removeFromSelection(Figure figure){}",
    "public void toggleSelection(Figure figure){}",
    "public void clearSelection(){}",
    "private Enumeration selectionHandles(){}",
    "public FigureSelection getFigureSelection(){}",
    "public Handle findHandle(int x, int y){}",
    "protected void selectionChanged(){}",
    "public Point lastClick(){}",
    "public void setConstrainer(PointConstrainer c){}",
    "public PointConstrainer getConstrainer(){}",
    "protected Point constrainPoint(Point p){}",
    "public void mousePressed(MouseEvent e){}",
    "public void mouseDragged(MouseEvent e){}",
    "public void mouseMoved(MouseEvent e){}",
    "public void mouseReleased(MouseEvent e){}",
    "public void keyPressed(KeyEvent e){}",
    "protected void handleCursorKey(int key){}",
    "private void moveSelection(int dx, int dy){}",
    "public synchronized void checkDamage(){}",
    "public void repairDamage(){}",
    "public void drawingInvalidated(DrawingChangeEvent e){}",
    "public void drawingRequestUpdate(DrawingChangeEvent e){}",
    "public void update(Graphics g){}",
    "public void paint(Graphics g){}",
    "public void drawAll(Graphics g){}",
    "public void drawHandles(Graphics g){}",
    "public void drawDrawing(Graphics g){}",
    "public void drawBackground(Graphics g){}",
    "private void drawPainters(Graphics g, Vector v){}",
    "public void addBackground(Painter painter) {}",
    "public void removeBackground(Painter painter) {}",
    "public void removeForeground(Painter painter) {}",
    "public void addForeground(Painter painter) {}",
    "public void freezeView(){}",
    "public void unfreezeView(){}",
    "private void readObject(ObjectInputStream s)\r\n        throws ClassNotFoundException, IOException{}",
    "private void checkMinimumSize(){}",
    "public boolean isFocusTraversable(){}",
    "public void mouseEntered(MouseEvent e){}",
    "public void mouseExited(MouseEvent e){}",
    "public void mouseClicked(MouseEvent e){}",
    "public void keyTyped(KeyEvent e){}",
    "public void keyReleased(KeyEvent e){}",
    "public StandardDrawingView(DrawingEditor editor, int width, int height){}"
  ],
  "constructorSigs": [
    "StandardDrawingView(DrawingEditor, int, int)"
  ],
  "constructorBrief": [
    "public StandardDrawingView(DrawingEditor editor, int width, int height){}"
  ],
  "getterSetterSigs": [
    "setEditor(DrawingEditor)",
    "setDrawing(Drawing)",
    "getMinimumSize()",
    "getPreferredSize()",
    "setDisplayUpdate(Painter)",
    "getFigureSelection()",
    "setConstrainer(PointConstrainer)",
    "getConstrainer()"
  ],
  "getterSetterBrief": [
    "public void setEditor(DrawingEditor editor){}",
    "public void setDrawing(Drawing d){}",
    "public Dimension getMinimumSize(){}",
    "public Dimension getPreferredSize(){}",
    "public void setDisplayUpdate(Painter updateStrategy){}",
    "public FigureSelection getFigureSelection(){}",
    "public void setConstrainer(PointConstrainer c){}",
    "public PointConstrainer getConstrainer(){}"
  ],
  "constructorDeps": {
    "CH.ifa.draw.framework.DrawingEditor": [],
    "CH.ifa.draw.standard.StandardDrawingView": [
      "setDisplayUpdate(Painter)"
    ],
    "javax.swing.JComponent": [
      "setBackground(Color)"
    ],
    "java.awt.Component": [
      "addKeyListener(KeyListener)",
      "addMouseListener(MouseListener)",
      "addMouseMotionListener(MouseMotionListener)"
    ]
  },
  "compilationUnitCode": "/*\n * @(#)StandardDrawingView.java 5.2\n *\n */\npackage CH.ifa.draw.standard;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Point;\nimport java.awt.PrintGraphics;\nimport java.awt.Rectangle;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport javax.swing.JPanel;\nimport CH.ifa.draw.framework.Drawing;\nimport CH.ifa.draw.framework.DrawingChangeEvent;\nimport CH.ifa.draw.framework.DrawingEditor;\nimport CH.ifa.draw.framework.DrawingView;\nimport CH.ifa.draw.framework.Figure;\nimport CH.ifa.draw.framework.FigureEnumeration;\nimport CH.ifa.draw.framework.FigureSelection;\nimport CH.ifa.draw.framework.Handle;\nimport CH.ifa.draw.framework.Painter;\nimport CH.ifa.draw.framework.PointConstrainer;\nimport CH.ifa.draw.framework.Tool;\nimport CH.ifa.draw.util.Command;\nimport CH.ifa.draw.util.Geom;\n\n/**\n * The standard implementation of DrawingView.\n * @see DrawingView\n * @see Painter\n * @see Tool\n */\npublic class StandardDrawingView extends JPanel implements DrawingView, MouseListener, MouseMotionListener, KeyListener {\n\n    /**\n     * The DrawingEditor of the view.\n     * @see #tool\n     * @see #setStatus\n     */\n    transient private DrawingEditor fEditor;\n\n    /**\n     * The shown drawing.\n     */\n    private Drawing fDrawing;\n\n    /**\n     * the accumulated damaged area\n     */\n    private transient Rectangle fDamage = null;\n\n    /**\n     * The list of currently selected figures.\n     */\n    transient private Vector fSelection;\n\n    /**\n     * The shown selection handles.\n     */\n    transient private Vector fSelectionHandles;\n\n    /**\n     * The preferred size of the view\n     */\n    private Dimension fViewSize;\n\n    /**\n     * The position of the last mouse click\n     * inside the view.\n     */\n    private Point fLastClick;\n\n    /**\n     * A vector of optional backgrounds. The vector maintains\n     * a list a view painters that are drawn before the contents,\n     * that is in the background.\n     */\n    private Vector fBackgrounds = null;\n\n    /**\n     * A vector of optional foregrounds. The vector maintains\n     * a list a view painters that are drawn after the contents,\n     * that is in the foreground.\n     */\n    private Vector fForegrounds = null;\n\n    /**\n     * The update strategy used to repair the view.\n     */\n    private Painter fUpdateStrategy;\n\n    /**\n     * The grid used to constrain points for snap to\n     * grid functionality.\n     */\n    private PointConstrainer fConstrainer;\n\n    /*\n     * Serialization support. In JavaDraw only the Drawing is serialized.\n     * However, for beans support StandardDrawingView supports\n     * serialization\n     */\n    private static final long serialVersionUID = -3878153366174603336L;\n\n    private int drawingViewSerializedDataVersion = 1;\n\n    public StandardDrawingView(DrawingEditor editor, int width, int height) {\n        fEditor = editor;\n        fViewSize = new Dimension(width, height);\n        fLastClick = new Point(0, 0);\n        fConstrainer = null;\n        fSelection = new Vector();\n        // changed from BufferedUpdateStrategy() to SimpleUpdateStrategy() as\n        // JFC/Swing uses double buffering automatically as default\n        setDisplayUpdate(new SimpleUpdateStrategy());\n        setBackground(Color.lightGray);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        addKeyListener(this);\n    }\n\n    /**\n     * Sets the view's editor.\n     */\n    public void setEditor(DrawingEditor editor) {\n        fEditor = editor;\n    }\n\n    /**\n     * Gets the current tool.\n     */\n    public Tool tool() {\n        return fEditor.tool();\n    }\n\n    /**\n     * Gets the drawing.\n     */\n    public Drawing drawing() {\n        return fDrawing;\n    }\n\n    /**\n     * Sets and installs another drawing in the view.\n     */\n    public void setDrawing(Drawing d) {\n        if (fDrawing != null) {\n            clearSelection();\n            fDrawing.removeDrawingChangeListener(this);\n        }\n        fDrawing = d;\n        if (fDrawing != null)\n            fDrawing.addDrawingChangeListener(this);\n        FigureEnumeration k = drawing().figures();\n        Dimension d1 = new Dimension(0, 0);\n        while (k.hasMoreElements()) {\n            Rectangle r = k.nextFigure().displayBox();\n            d1.width = Math.max(d1.width, r.x + r.width);\n            d1.height = Math.max(d1.height, r.y + r.height);\n        }\n        if (fViewSize.height < d1.height || fViewSize.width < d1.width) {\n            fViewSize.height = d1.height + 10;\n            fViewSize.width = d1.width + 10;\n            setSize(fViewSize);\n        }\n        repaint();\n    }\n\n    /**\n     * Gets the editor.\n     */\n    public DrawingEditor editor() {\n        return fEditor;\n    }\n\n    /**\n     * Adds a figure to the drawing.\n     * @return the added figure.\n     */\n    public Figure add(Figure figure) {\n        return drawing().add(figure);\n    }\n\n    /**\n     * Removes a figure from the drawing.\n     * @return the removed figure\n     */\n    public Figure remove(Figure figure) {\n        return drawing().remove(figure);\n    }\n\n    /**\n     * Adds a vector of figures to the drawing.\n     */\n    public void addAll(Vector figures) {\n        FigureEnumeration k = new FigureEnumerator(figures);\n        while (k.hasMoreElements()) add(k.nextFigure());\n    }\n\n    /**\n     * Gets the minimum dimension of the drawing.\n     */\n    public Dimension getMinimumSize() {\n        return fViewSize;\n    }\n\n    /**\n     * Gets the preferred dimension of the drawing..\n     */\n    public Dimension getPreferredSize() {\n        return getMinimumSize();\n    }\n\n    /**\n     * Sets the current display update strategy.\n     * @see Painter\n     */\n    public void setDisplayUpdate(Painter updateStrategy) {\n        fUpdateStrategy = updateStrategy;\n    }\n\n    /**\n     * Gets the currently selected figures.\n     * @return a vector with the selected figures. The vector\n     * is a copy of the current selection.\n     */\n    public Vector selection() {\n        // protect the vector with the current selection\n        return (Vector) fSelection.clone();\n    }\n\n    /**\n     * Gets an enumeration over the currently selected figures.\n     */\n    public FigureEnumeration selectionElements() {\n        return new FigureEnumerator(fSelection);\n    }\n\n    /**\n     * Gets the currently selected figures in Z order.\n     * @see #selection\n     * @return a vector with the selected figures. The vector\n     * is a copy of the current selection.\n     */\n    public Vector selectionZOrdered() {\n        Vector result = new Vector(fSelection.size());\n        FigureEnumeration figures = drawing().figures();\n        while (figures.hasMoreElements()) {\n            Figure f = figures.nextFigure();\n            if (fSelection.contains(f)) {\n                result.addElement(f);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the number of selected figures.\n     */\n    public int selectionCount() {\n        return fSelection.size();\n    }\n\n    /**\n     * Adds a figure to the current selection.\n     */\n    public void addToSelection(Figure figure) {\n        if (!fSelection.contains(figure)) {\n            fSelection.addElement(figure);\n            fSelectionHandles = null;\n            figure.invalidate();\n            selectionChanged();\n        }\n    }\n\n    /**\n     * Adds a vector of figures to the current selection.\n     */\n    public void addToSelectionAll(Vector figures) {\n        FigureEnumeration k = new FigureEnumerator(figures);\n        while (k.hasMoreElements()) addToSelection(k.nextFigure());\n    }\n\n    /**\n     * Removes a figure from the selection.\n     */\n    public void removeFromSelection(Figure figure) {\n        if (fSelection.contains(figure)) {\n            fSelection.removeElement(figure);\n            fSelectionHandles = null;\n            figure.invalidate();\n            selectionChanged();\n        }\n    }\n\n    /**\n     * If a figure isn't selected it is added to the selection.\n     * Otherwise it is removed from the selection.\n     */\n    public void toggleSelection(Figure figure) {\n        if (fSelection.contains(figure))\n            removeFromSelection(figure);\n        else\n            addToSelection(figure);\n        selectionChanged();\n    }\n\n    /**\n     * Clears the current selection.\n     */\n    public void clearSelection() {\n        Figure figure;\n        FigureEnumeration k = selectionElements();\n        while (k.hasMoreElements()) k.nextFigure().invalidate();\n        fSelection = new Vector();\n        fSelectionHandles = null;\n        selectionChanged();\n    }\n\n    /**\n     * Gets an enumeration of the currently active handles.\n     */\n    private Enumeration selectionHandles() {\n        if (fSelectionHandles == null) {\n            fSelectionHandles = new Vector();\n            FigureEnumeration k = selectionElements();\n            while (k.hasMoreElements()) {\n                Figure figure = k.nextFigure();\n                Enumeration kk = figure.handles().elements();\n                while (kk.hasMoreElements()) fSelectionHandles.addElement(kk.nextElement());\n            }\n        }\n        return fSelectionHandles.elements();\n    }\n\n    /**\n     * Gets the current selection as a FigureSelection. A FigureSelection\n     * can be cut, copied, pasted.\n     */\n    public FigureSelection getFigureSelection() {\n        return new FigureSelection(selectionZOrdered());\n    }\n\n    /**\n     * Finds a handle at the given coordinates.\n     * @return the hit handle, null if no handle is found.\n     */\n    public Handle findHandle(int x, int y) {\n        Handle handle;\n        if (fSelectionHandles == null) {\n            fSelectionHandles = new Vector();\n            FigureEnumeration k1 = selectionElements();\n            while (k1.hasMoreElements()) {\n                Figure figure = k1.nextFigure();\n                Enumeration kk = figure.handles().elements();\n                while (kk.hasMoreElements()) fSelectionHandles.addElement(kk.nextElement());\n            }\n        }\n        Enumeration k = fSelectionHandles.elements();\n        while (k.hasMoreElements()) {\n            handle = (Handle) k.nextElement();\n            if (handle.containsPoint(x, y))\n                return handle;\n        }\n        return null;\n    }\n\n    /**\n     * Informs that the current selection changed.\n     * By default this event is forwarded to the\n     * drawing editor.\n     */\n    protected void selectionChanged() {\n        fEditor.selectionChanged(this);\n    }\n\n    /**\n     * Gets the position of the last click inside the view.\n     */\n    public Point lastClick() {\n        return fLastClick;\n    }\n\n    /**\n     * Sets the grid spacing that is used to constrain points.\n     */\n    public void setConstrainer(PointConstrainer c) {\n        fConstrainer = c;\n    }\n\n    /**\n     * Gets the current constrainer.\n     */\n    public PointConstrainer getConstrainer() {\n        return fConstrainer;\n    }\n\n    /**\n     * Constrains a point to the current grid.\n     */\n    protected Point constrainPoint(Point p) {\n        // constrin to view size\n        Dimension size = getSize();\n        int max = size.width;\n        int value = p.x;\n        if (value < 1)\n            value = 1;\n        if (value > max)\n            value = max;\n        // p.x = Math.min(size.width, Math.max(1, p.x));\n        // p.y = Math.min(size.height, Math.max(1, p.y));\n        p.x = value;\n        p.y = Geom.range(1, size.height, p.y);\n        if (fConstrainer != null)\n            return fConstrainer.constrainPoint(p);\n        return p;\n    }\n\n    /**\n     * Handles mouse down events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mousePressed(MouseEvent e) {\n        // JDK1.1\n        requestFocus();\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        fLastClick = new Point(e.getX(), e.getY());\n        tool().mouseDown(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles mouse drag events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseDragged(MouseEvent e) {\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        tool().mouseDrag(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles mouse move events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseMoved(MouseEvent e) {\n        tool().mouseMove(e, e.getX(), e.getY());\n    }\n\n    /**\n     * Handles mouse up events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseReleased(MouseEvent e) {\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        tool().mouseUp(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles key down events. Cursor keys are handled\n     * by the view the other key events are delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {\n            Command cmd = new DeleteCommand(\"Delete\", this);\n            cmd.execute();\n        } else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP || code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_LEFT) {\n            handleCursorKey(code);\n        } else {\n            tool().keyDown(e, code);\n        }\n        checkDamage();\n    }\n\n    /**\n     * Handles cursor keys by moving all the selected figures\n     * one grid point in the cursor direction.\n     */\n    protected void handleCursorKey(int key) {\n        int dx = 0, dy = 0;\n        int stepX = 1, stepY = 1;\n        // should consider Null Object.\n        if (fConstrainer != null) {\n            stepX = fConstrainer.getStepX();\n            stepY = fConstrainer.getStepY();\n        }\n        switch(key) {\n            case KeyEvent.VK_DOWN:\n                dy = stepY;\n                break;\n            case KeyEvent.VK_UP:\n                dy = -stepY;\n                break;\n            case KeyEvent.VK_RIGHT:\n                dx = stepX;\n                break;\n            case KeyEvent.VK_LEFT:\n                dx = -stepX;\n                break;\n        }\n        moveSelection(dx, dy);\n    }\n\n    private void moveSelection(int dx, int dy) {\n        FigureEnumeration figures = selectionElements();\n        while (figures.hasMoreElements()) figures.nextFigure().moveBy(dx, dy);\n        checkDamage();\n    }\n\n    /**\n     * Refreshes the drawing if there is some accumulated damage\n     */\n    public synchronized void checkDamage() {\n        Enumeration each = drawing().drawingChangeListeners();\n        while (each.hasMoreElements()) {\n            Object l = each.nextElement();\n            if (l instanceof DrawingView) {\n                ((DrawingView) l).repairDamage();\n            }\n        }\n    }\n\n    public void repairDamage() {\n        if (fDamage != null) {\n            repaint(fDamage.x, fDamage.y, fDamage.width, fDamage.height);\n            fDamage = null;\n        }\n    }\n\n    public void drawingInvalidated(DrawingChangeEvent e) {\n        Rectangle r = e.getInvalidatedRectangle();\n        if (fDamage == null)\n            fDamage = r;\n        else\n            fDamage.add(r);\n    }\n\n    public void drawingRequestUpdate(DrawingChangeEvent e) {\n        repairDamage();\n    }\n\n    /**\n     * Updates the drawing view.\n     */\n    public void update(Graphics g) {\n        paint(g);\n    }\n\n    /**\n     * Paints the drawing view. The actual drawing is delegated to\n     * the current update strategy.\n     * @see Painter\n     */\n    public void paint(Graphics g) {\n        fUpdateStrategy.draw(g, this);\n    }\n\n    /**\n     * Draws the contents of the drawing view.\n     * The view has three layers: background, drawing, handles.\n     * The layers are drawn in back to front order.\n     */\n    public void drawAll(Graphics g) {\n        boolean isPrinting = g instanceof PrintGraphics;\n        drawBackground(g);\n        if (fBackgrounds != null && !isPrinting)\n            drawPainters(g, fBackgrounds);\n        drawDrawing(g);\n        if (fForegrounds != null && !isPrinting)\n            drawPainters(g, fForegrounds);\n        if (!isPrinting)\n            drawHandles(g);\n    }\n\n    /**\n     * Draws the currently active handles.\n     */\n    public void drawHandles(Graphics g) {\n        Enumeration k = selectionHandles();\n        while (k.hasMoreElements()) ((Handle) k.nextElement()).draw(g);\n    }\n\n    /**\n     * Draws the drawing.\n     */\n    public void drawDrawing(Graphics g) {\n        fDrawing.draw(g);\n    }\n\n    /**\n     * Draws the background. If a background pattern is set it\n     * is used to fill the background. Otherwise the background\n     * is filled in the background color.\n     */\n    public void drawBackground(Graphics g) {\n        g.setColor(getBackground());\n        g.fillRect(0, 0, getBounds().width, getBounds().height);\n    }\n\n    private void drawPainters(Graphics g, Vector v) {\n        for (int i = 0; i < v.size(); i++) ((Painter) v.elementAt(i)).draw(g, this);\n    }\n\n    /**\n     * Adds a background.\n     */\n    public void addBackground(Painter painter) {\n        if (fBackgrounds == null)\n            fBackgrounds = new Vector(3);\n        fBackgrounds.addElement(painter);\n        repaint();\n    }\n\n    /**\n     * Removes a background.\n     */\n    public void removeBackground(Painter painter) {\n        if (fBackgrounds != null)\n            fBackgrounds.removeElement(painter);\n        repaint();\n    }\n\n    /**\n     * Removes a foreground.\n     */\n    public void removeForeground(Painter painter) {\n        if (fForegrounds != null)\n            fForegrounds.removeElement(painter);\n        repaint();\n    }\n\n    /**\n     * Adds a foreground.\n     */\n    public void addForeground(Painter painter) {\n        if (fForegrounds == null)\n            fForegrounds = new Vector(3);\n        fForegrounds.addElement(painter);\n        repaint();\n    }\n\n    /**\n     * Freezes the view by acquiring the drawing lock.\n     * @see Drawing#lock\n     */\n    public void freezeView() {\n        drawing().lock();\n    }\n\n    /**\n     * Unfreezes the view by releasing the drawing lock.\n     * @see Drawing#unlock\n     */\n    public void unfreezeView() {\n        drawing().unlock();\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        // could use lazy initialization instead\n        fSelection = new Vector();\n        if (fDrawing != null)\n            fDrawing.addDrawingChangeListener(this);\n    }\n\n    private void checkMinimumSize() {\n        FigureEnumeration k = drawing().figures();\n        Dimension d = new Dimension(0, 0);\n        while (k.hasMoreElements()) {\n            Rectangle r = k.nextFigure().displayBox();\n            d.width = Math.max(d.width, r.x + r.width);\n            d.height = Math.max(d.height, r.y + r.height);\n        }\n        if (fViewSize.height < d.height || fViewSize.width < d.width) {\n            fViewSize.height = d.height + 10;\n            fViewSize.width = d.width + 10;\n            setSize(fViewSize);\n        }\n    }\n\n    public boolean isFocusTraversable() {\n        return true;\n    }\n\n    // listener methods we are not interested in\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    public void mouseExited(MouseEvent e) {\n    }\n\n    public void mouseClicked(MouseEvent e) {\n    }\n\n    public void keyTyped(KeyEvent e) {\n    }\n\n    public void keyReleased(KeyEvent e) {\n    }\n}\n",
  "classDeclarationCode": "/**\n * The standard implementation of DrawingView.\n * @see DrawingView\n * @see Painter\n * @see Tool\n */\npublic class StandardDrawingView extends JPanel implements DrawingView, MouseListener, MouseMotionListener, KeyListener {\n\n    /**\n     * The DrawingEditor of the view.\n     * @see #tool\n     * @see #setStatus\n     */\n    transient private DrawingEditor fEditor;\n\n    /**\n     * The shown drawing.\n     */\n    private Drawing fDrawing;\n\n    /**\n     * the accumulated damaged area\n     */\n    private transient Rectangle fDamage = null;\n\n    /**\n     * The list of currently selected figures.\n     */\n    transient private Vector fSelection;\n\n    /**\n     * The shown selection handles.\n     */\n    transient private Vector fSelectionHandles;\n\n    /**\n     * The preferred size of the view\n     */\n    private Dimension fViewSize;\n\n    /**\n     * The position of the last mouse click\n     * inside the view.\n     */\n    private Point fLastClick;\n\n    /**\n     * A vector of optional backgrounds. The vector maintains\n     * a list a view painters that are drawn before the contents,\n     * that is in the background.\n     */\n    private Vector fBackgrounds = null;\n\n    /**\n     * A vector of optional foregrounds. The vector maintains\n     * a list a view painters that are drawn after the contents,\n     * that is in the foreground.\n     */\n    private Vector fForegrounds = null;\n\n    /**\n     * The update strategy used to repair the view.\n     */\n    private Painter fUpdateStrategy;\n\n    /**\n     * The grid used to constrain points for snap to\n     * grid functionality.\n     */\n    private PointConstrainer fConstrainer;\n\n    /*\n     * Serialization support. In JavaDraw only the Drawing is serialized.\n     * However, for beans support StandardDrawingView supports\n     * serialization\n     */\n    private static final long serialVersionUID = -3878153366174603336L;\n\n    private int drawingViewSerializedDataVersion = 1;\n\n    public StandardDrawingView(DrawingEditor editor, int width, int height) {\n        fEditor = editor;\n        fViewSize = new Dimension(width, height);\n        fLastClick = new Point(0, 0);\n        fConstrainer = null;\n        fSelection = new Vector();\n        // changed from BufferedUpdateStrategy() to SimpleUpdateStrategy() as\n        // JFC/Swing uses double buffering automatically as default\n        setDisplayUpdate(new SimpleUpdateStrategy());\n        setBackground(Color.lightGray);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        addKeyListener(this);\n    }\n\n    /**\n     * Sets the view's editor.\n     */\n    public void setEditor(DrawingEditor editor) {\n        fEditor = editor;\n    }\n\n    /**\n     * Gets the current tool.\n     */\n    public Tool tool() {\n        return fEditor.tool();\n    }\n\n    /**\n     * Gets the drawing.\n     */\n    public Drawing drawing() {\n        return fDrawing;\n    }\n\n    /**\n     * Sets and installs another drawing in the view.\n     */\n    public void setDrawing(Drawing d) {\n        if (fDrawing != null) {\n            clearSelection();\n            fDrawing.removeDrawingChangeListener(this);\n        }\n        fDrawing = d;\n        if (fDrawing != null)\n            fDrawing.addDrawingChangeListener(this);\n        FigureEnumeration k = drawing().figures();\n        Dimension d1 = new Dimension(0, 0);\n        while (k.hasMoreElements()) {\n            Rectangle r = k.nextFigure().displayBox();\n            d1.width = Math.max(d1.width, r.x + r.width);\n            d1.height = Math.max(d1.height, r.y + r.height);\n        }\n        if (fViewSize.height < d1.height || fViewSize.width < d1.width) {\n            fViewSize.height = d1.height + 10;\n            fViewSize.width = d1.width + 10;\n            setSize(fViewSize);\n        }\n        repaint();\n    }\n\n    /**\n     * Gets the editor.\n     */\n    public DrawingEditor editor() {\n        return fEditor;\n    }\n\n    /**\n     * Adds a figure to the drawing.\n     * @return the added figure.\n     */\n    public Figure add(Figure figure) {\n        return drawing().add(figure);\n    }\n\n    /**\n     * Removes a figure from the drawing.\n     * @return the removed figure\n     */\n    public Figure remove(Figure figure) {\n        return drawing().remove(figure);\n    }\n\n    /**\n     * Adds a vector of figures to the drawing.\n     */\n    public void addAll(Vector figures) {\n        FigureEnumeration k = new FigureEnumerator(figures);\n        while (k.hasMoreElements()) add(k.nextFigure());\n    }\n\n    /**\n     * Gets the minimum dimension of the drawing.\n     */\n    public Dimension getMinimumSize() {\n        return fViewSize;\n    }\n\n    /**\n     * Gets the preferred dimension of the drawing..\n     */\n    public Dimension getPreferredSize() {\n        return getMinimumSize();\n    }\n\n    /**\n     * Sets the current display update strategy.\n     * @see Painter\n     */\n    public void setDisplayUpdate(Painter updateStrategy) {\n        fUpdateStrategy = updateStrategy;\n    }\n\n    /**\n     * Gets the currently selected figures.\n     * @return a vector with the selected figures. The vector\n     * is a copy of the current selection.\n     */\n    public Vector selection() {\n        // protect the vector with the current selection\n        return (Vector) fSelection.clone();\n    }\n\n    /**\n     * Gets an enumeration over the currently selected figures.\n     */\n    public FigureEnumeration selectionElements() {\n        return new FigureEnumerator(fSelection);\n    }\n\n    /**\n     * Gets the currently selected figures in Z order.\n     * @see #selection\n     * @return a vector with the selected figures. The vector\n     * is a copy of the current selection.\n     */\n    public Vector selectionZOrdered() {\n        Vector result = new Vector(fSelection.size());\n        FigureEnumeration figures = drawing().figures();\n        while (figures.hasMoreElements()) {\n            Figure f = figures.nextFigure();\n            if (fSelection.contains(f)) {\n                result.addElement(f);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the number of selected figures.\n     */\n    public int selectionCount() {\n        return fSelection.size();\n    }\n\n    /**\n     * Adds a figure to the current selection.\n     */\n    public void addToSelection(Figure figure) {\n        if (!fSelection.contains(figure)) {\n            fSelection.addElement(figure);\n            fSelectionHandles = null;\n            figure.invalidate();\n            selectionChanged();\n        }\n    }\n\n    /**\n     * Adds a vector of figures to the current selection.\n     */\n    public void addToSelectionAll(Vector figures) {\n        FigureEnumeration k = new FigureEnumerator(figures);\n        while (k.hasMoreElements()) addToSelection(k.nextFigure());\n    }\n\n    /**\n     * Removes a figure from the selection.\n     */\n    public void removeFromSelection(Figure figure) {\n        if (fSelection.contains(figure)) {\n            fSelection.removeElement(figure);\n            fSelectionHandles = null;\n            figure.invalidate();\n            selectionChanged();\n        }\n    }\n\n    /**\n     * If a figure isn't selected it is added to the selection.\n     * Otherwise it is removed from the selection.\n     */\n    public void toggleSelection(Figure figure) {\n        if (fSelection.contains(figure))\n            removeFromSelection(figure);\n        else\n            addToSelection(figure);\n        selectionChanged();\n    }\n\n    /**\n     * Clears the current selection.\n     */\n    public void clearSelection() {\n        Figure figure;\n        FigureEnumeration k = selectionElements();\n        while (k.hasMoreElements()) k.nextFigure().invalidate();\n        fSelection = new Vector();\n        fSelectionHandles = null;\n        selectionChanged();\n    }\n\n    /**\n     * Gets an enumeration of the currently active handles.\n     */\n    private Enumeration selectionHandles() {\n        if (fSelectionHandles == null) {\n            fSelectionHandles = new Vector();\n            FigureEnumeration k = selectionElements();\n            while (k.hasMoreElements()) {\n                Figure figure = k.nextFigure();\n                Enumeration kk = figure.handles().elements();\n                while (kk.hasMoreElements()) fSelectionHandles.addElement(kk.nextElement());\n            }\n        }\n        return fSelectionHandles.elements();\n    }\n\n    /**\n     * Gets the current selection as a FigureSelection. A FigureSelection\n     * can be cut, copied, pasted.\n     */\n    public FigureSelection getFigureSelection() {\n        return new FigureSelection(selectionZOrdered());\n    }\n\n    /**\n     * Finds a handle at the given coordinates.\n     * @return the hit handle, null if no handle is found.\n     */\n    public Handle findHandle(int x, int y) {\n        Handle handle;\n        if (fSelectionHandles == null) {\n            fSelectionHandles = new Vector();\n            FigureEnumeration k1 = selectionElements();\n            while (k1.hasMoreElements()) {\n                Figure figure = k1.nextFigure();\n                Enumeration kk = figure.handles().elements();\n                while (kk.hasMoreElements()) fSelectionHandles.addElement(kk.nextElement());\n            }\n        }\n        Enumeration k = fSelectionHandles.elements();\n        while (k.hasMoreElements()) {\n            handle = (Handle) k.nextElement();\n            if (handle.containsPoint(x, y))\n                return handle;\n        }\n        return null;\n    }\n\n    /**\n     * Informs that the current selection changed.\n     * By default this event is forwarded to the\n     * drawing editor.\n     */\n    protected void selectionChanged() {\n        fEditor.selectionChanged(this);\n    }\n\n    /**\n     * Gets the position of the last click inside the view.\n     */\n    public Point lastClick() {\n        return fLastClick;\n    }\n\n    /**\n     * Sets the grid spacing that is used to constrain points.\n     */\n    public void setConstrainer(PointConstrainer c) {\n        fConstrainer = c;\n    }\n\n    /**\n     * Gets the current constrainer.\n     */\n    public PointConstrainer getConstrainer() {\n        return fConstrainer;\n    }\n\n    /**\n     * Constrains a point to the current grid.\n     */\n    protected Point constrainPoint(Point p) {\n        // constrin to view size\n        Dimension size = getSize();\n        int max = size.width;\n        int value = p.x;\n        if (value < 1)\n            value = 1;\n        if (value > max)\n            value = max;\n        // p.x = Math.min(size.width, Math.max(1, p.x));\n        // p.y = Math.min(size.height, Math.max(1, p.y));\n        p.x = value;\n        p.y = Geom.range(1, size.height, p.y);\n        if (fConstrainer != null)\n            return fConstrainer.constrainPoint(p);\n        return p;\n    }\n\n    /**\n     * Handles mouse down events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mousePressed(MouseEvent e) {\n        // JDK1.1\n        requestFocus();\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        fLastClick = new Point(e.getX(), e.getY());\n        tool().mouseDown(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles mouse drag events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseDragged(MouseEvent e) {\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        tool().mouseDrag(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles mouse move events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseMoved(MouseEvent e) {\n        tool().mouseMove(e, e.getX(), e.getY());\n    }\n\n    /**\n     * Handles mouse up events. The event is delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void mouseReleased(MouseEvent e) {\n        Point p = constrainPoint(new Point(e.getX(), e.getY()));\n        tool().mouseUp(e, p.x, p.y);\n        checkDamage();\n    }\n\n    /**\n     * Handles key down events. Cursor keys are handled\n     * by the view the other key events are delegated to the\n     * currently active tool.\n     * @return whether the event was handled.\n     */\n    public void keyPressed(KeyEvent e) {\n        int code = e.getKeyCode();\n        if ((code == KeyEvent.VK_BACK_SPACE) || (code == KeyEvent.VK_DELETE)) {\n            Command cmd = new DeleteCommand(\"Delete\", this);\n            cmd.execute();\n        } else if (code == KeyEvent.VK_DOWN || code == KeyEvent.VK_UP || code == KeyEvent.VK_RIGHT || code == KeyEvent.VK_LEFT) {\n            handleCursorKey(code);\n        } else {\n            tool().keyDown(e, code);\n        }\n        checkDamage();\n    }\n\n    /**\n     * Handles cursor keys by moving all the selected figures\n     * one grid point in the cursor direction.\n     */\n    protected void handleCursorKey(int key) {\n        int dx = 0, dy = 0;\n        int stepX = 1, stepY = 1;\n        // should consider Null Object.\n        if (fConstrainer != null) {\n            stepX = fConstrainer.getStepX();\n            stepY = fConstrainer.getStepY();\n        }\n        switch(key) {\n            case KeyEvent.VK_DOWN:\n                dy = stepY;\n                break;\n            case KeyEvent.VK_UP:\n                dy = -stepY;\n                break;\n            case KeyEvent.VK_RIGHT:\n                dx = stepX;\n                break;\n            case KeyEvent.VK_LEFT:\n                dx = -stepX;\n                break;\n        }\n        moveSelection(dx, dy);\n    }\n\n    private void moveSelection(int dx, int dy) {\n        FigureEnumeration figures = selectionElements();\n        while (figures.hasMoreElements()) figures.nextFigure().moveBy(dx, dy);\n        checkDamage();\n    }\n\n    /**\n     * Refreshes the drawing if there is some accumulated damage\n     */\n    public synchronized void checkDamage() {\n        Enumeration each = drawing().drawingChangeListeners();\n        while (each.hasMoreElements()) {\n            Object l = each.nextElement();\n            if (l instanceof DrawingView) {\n                ((DrawingView) l).repairDamage();\n            }\n        }\n    }\n\n    public void repairDamage() {\n        if (fDamage != null) {\n            repaint(fDamage.x, fDamage.y, fDamage.width, fDamage.height);\n            fDamage = null;\n        }\n    }\n\n    public void drawingInvalidated(DrawingChangeEvent e) {\n        Rectangle r = e.getInvalidatedRectangle();\n        if (fDamage == null)\n            fDamage = r;\n        else\n            fDamage.add(r);\n    }\n\n    public void drawingRequestUpdate(DrawingChangeEvent e) {\n        repairDamage();\n    }\n\n    /**\n     * Updates the drawing view.\n     */\n    public void update(Graphics g) {\n        paint(g);\n    }\n\n    /**\n     * Paints the drawing view. The actual drawing is delegated to\n     * the current update strategy.\n     * @see Painter\n     */\n    public void paint(Graphics g) {\n        fUpdateStrategy.draw(g, this);\n    }\n\n    /**\n     * Draws the contents of the drawing view.\n     * The view has three layers: background, drawing, handles.\n     * The layers are drawn in back to front order.\n     */\n    public void drawAll(Graphics g) {\n        boolean isPrinting = g instanceof PrintGraphics;\n        drawBackground(g);\n        if (fBackgrounds != null && !isPrinting)\n            drawPainters(g, fBackgrounds);\n        drawDrawing(g);\n        if (fForegrounds != null && !isPrinting)\n            drawPainters(g, fForegrounds);\n        if (!isPrinting)\n            drawHandles(g);\n    }\n\n    /**\n     * Draws the currently active handles.\n     */\n    public void drawHandles(Graphics g) {\n        Enumeration k = selectionHandles();\n        while (k.hasMoreElements()) ((Handle) k.nextElement()).draw(g);\n    }\n\n    /**\n     * Draws the drawing.\n     */\n    public void drawDrawing(Graphics g) {\n        fDrawing.draw(g);\n    }\n\n    /**\n     * Draws the background. If a background pattern is set it\n     * is used to fill the background. Otherwise the background\n     * is filled in the background color.\n     */\n    public void drawBackground(Graphics g) {\n        g.setColor(getBackground());\n        g.fillRect(0, 0, getBounds().width, getBounds().height);\n    }\n\n    private void drawPainters(Graphics g, Vector v) {\n        for (int i = 0; i < v.size(); i++) ((Painter) v.elementAt(i)).draw(g, this);\n    }\n\n    /**\n     * Adds a background.\n     */\n    public void addBackground(Painter painter) {\n        if (fBackgrounds == null)\n            fBackgrounds = new Vector(3);\n        fBackgrounds.addElement(painter);\n        repaint();\n    }\n\n    /**\n     * Removes a background.\n     */\n    public void removeBackground(Painter painter) {\n        if (fBackgrounds != null)\n            fBackgrounds.removeElement(painter);\n        repaint();\n    }\n\n    /**\n     * Removes a foreground.\n     */\n    public void removeForeground(Painter painter) {\n        if (fForegrounds != null)\n            fForegrounds.removeElement(painter);\n        repaint();\n    }\n\n    /**\n     * Adds a foreground.\n     */\n    public void addForeground(Painter painter) {\n        if (fForegrounds == null)\n            fForegrounds = new Vector(3);\n        fForegrounds.addElement(painter);\n        repaint();\n    }\n\n    /**\n     * Freezes the view by acquiring the drawing lock.\n     * @see Drawing#lock\n     */\n    public void freezeView() {\n        drawing().lock();\n    }\n\n    /**\n     * Unfreezes the view by releasing the drawing lock.\n     * @see Drawing#unlock\n     */\n    public void unfreezeView() {\n        drawing().unlock();\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        // could use lazy initialization instead\n        fSelection = new Vector();\n        if (fDrawing != null)\n            fDrawing.addDrawingChangeListener(this);\n    }\n\n    private void checkMinimumSize() {\n        FigureEnumeration k = drawing().figures();\n        Dimension d = new Dimension(0, 0);\n        while (k.hasMoreElements()) {\n            Rectangle r = k.nextFigure().displayBox();\n            d.width = Math.max(d.width, r.x + r.width);\n            d.height = Math.max(d.height, r.y + r.height);\n        }\n        if (fViewSize.height < d.height || fViewSize.width < d.width) {\n            fViewSize.height = d.height + 10;\n            fViewSize.width = d.width + 10;\n            setSize(fViewSize);\n        }\n    }\n\n    public boolean isFocusTraversable() {\n        return true;\n    }\n\n    // listener methods we are not interested in\n    public void mouseEntered(MouseEvent e) {\n    }\n\n    public void mouseExited(MouseEvent e) {\n    }\n\n    public void mouseClicked(MouseEvent e) {\n    }\n\n    public void keyTyped(KeyEvent e) {\n    }\n\n    public void keyReleased(KeyEvent e) {\n    }\n}",
  "subClasses": []
}