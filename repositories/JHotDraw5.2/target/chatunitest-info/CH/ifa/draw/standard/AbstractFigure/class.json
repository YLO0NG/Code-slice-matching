{
  "fullClassName": "CH.ifa.draw.standard.AbstractFigure",
  "className": "AbstractFigure",
  "index": 93,
  "modifier": "[public , abstract ]",
  "extend": "[]",
  "implement": "[Figure]",
  "packageName": "CH.ifa.draw.standard",
  "packageDeclaration": "package CH.ifa.draw.standard;",
  "classSignature": "public abstract class AbstractFigure",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": true,
  "imports": [
    "import CH.ifa.draw.util.*;",
    "import CH.ifa.draw.framework.*;",
    "import java.awt.*;",
    "import java.util.*;",
    "import java.io.*;"
  ],
  "fields": [
    "private transient FigureChangeListener fListener;",
    "private static final long serialVersionUID = -10857585979273442L;",
    "private int abstractFigureSerializedDataVersion = 1;"
  ],
  "superClasses": [],
  "implementedTypes": [
    "Figure"
  ],
  "methodSigs": {
    "moveBy(int, int)": "0",
    "basicMoveBy(int, int)": "1",
    "displayBox(Point, Point)": "2",
    "basicDisplayBox(Point, Point)": "3",
    "displayBox()": "4",
    "handles()": "5",
    "figures()": "6",
    "size()": "7",
    "isEmpty()": "8",
    "findFigureInside(int, int)": "9",
    "containsPoint(int, int)": "10",
    "displayBox(Rectangle)": "11",
    "includes(Figure)": "12",
    "decompose()": "13",
    "addToContainer(FigureChangeListener)": "14",
    "removeFromContainer(FigureChangeListener)": "15",
    "addFigureChangeListener(FigureChangeListener)": "16",
    "removeFigureChangeListener(FigureChangeListener)": "17",
    "listener()": "18",
    "release()": "19",
    "invalidate()": "20",
    "willChange()": "21",
    "changed()": "22",
    "center()": "23",
    "canConnect()": "24",
    "connectionInsets()": "25",
    "connectorAt(int, int)": "26",
    "connectorVisibility(boolean)": "27",
    "connectedTextLocator(Figure)": "28",
    "getAttribute(String)": "29",
    "setAttribute(String, Object)": "30",
    "clone()": "31",
    "write(StorableOutput)": "32",
    "read(StorableInput)": "33",
    "AbstractFigure()": "34"
  },
  "methodsBrief": [
    "public void moveBy(int dx, int dy){}",
    "protected abstract void basicMoveBy(int dx, int dy);",
    "public void displayBox(Point origin, Point corner){}",
    "public abstract void basicDisplayBox(Point origin, Point corner);",
    "public abstract Rectangle displayBox();",
    "public abstract Vector handles();",
    "public FigureEnumeration figures(){}",
    "public Dimension size(){}",
    "public boolean isEmpty(){}",
    "public Figure findFigureInside(int x, int y){}",
    "public boolean containsPoint(int x, int y){}",
    "public void displayBox(Rectangle r){}",
    "public boolean includes(Figure figure){}",
    "public FigureEnumeration decompose(){}",
    "public void addToContainer(FigureChangeListener c){}",
    "public void removeFromContainer(FigureChangeListener c){}",
    "public void addFigureChangeListener(FigureChangeListener l){}",
    "public void removeFigureChangeListener(FigureChangeListener l){}",
    "public FigureChangeListener listener(){}",
    "public void release(){}",
    "public void invalidate(){}",
    "public void willChange(){}",
    "public void changed(){}",
    "public Point center(){}",
    "public boolean canConnect(){}",
    "public Insets connectionInsets(){}",
    "public Connector connectorAt(int x, int y){}",
    "public void connectorVisibility(boolean isVisible){}",
    "public Locator connectedTextLocator(Figure text){}",
    "public Object getAttribute(String name){}",
    "public void setAttribute(String name, Object value){}",
    "public Object clone(){}",
    "public void write(StorableOutput dw){}",
    "public void read(StorableInput dr) throws IOException{}",
    "protected AbstractFigure(){}"
  ],
  "constructorSigs": [
    "AbstractFigure()"
  ],
  "constructorBrief": [
    "protected AbstractFigure(){}"
  ],
  "getterSetterSigs": [
    "setAttribute(String, Object)"
  ],
  "getterSetterBrief": [
    "public void setAttribute(String name, Object value){}"
  ],
  "constructorDeps": {},
  "compilationUnitCode": "/*\n * @(#)AbstractFigure.java 5.2\n *\n */\npackage CH.ifa.draw.standard;\n\nimport CH.ifa.draw.util.*;\nimport CH.ifa.draw.framework.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\n/**\n * AbstractFigure provides default implementations for\n * the Figure interface.\n *\n * <hr>\n * <b>Design Patterns</b><P>\n * <img src=\"images/red-ball-small.gif\" width=6 height=6 alt=\" o \">\n * <b><a href=../pattlets/sld036.htm>Template Method</a></b><br>\n * Template Methods implement default and invariant behavior for\n * figure subclasses.\n * <hr>\n *\n * @see Figure\n * @see Handle\n */\npublic abstract class AbstractFigure implements Figure {\n\n    /**\n     * The listeners for a figure's changes.\n     * @see #invalidate\n     * @see #changed\n     * @see #willChange\n     */\n    private transient FigureChangeListener fListener;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = -10857585979273442L;\n\n    private int abstractFigureSerializedDataVersion = 1;\n\n    protected AbstractFigure() {\n    }\n\n    /**\n     * Moves the figure by the given offset.\n     */\n    public void moveBy(int dx, int dy) {\n        willChange();\n        basicMoveBy(dx, dy);\n        changed();\n    }\n\n    /**\n     * Moves the figure. This is the\n     * method that subclassers override. Clients usually\n     * call displayBox.\n     * @see #moveBy\n     */\n    protected abstract void basicMoveBy(int dx, int dy);\n\n    /**\n     * Changes the display box of a figure. Clients usually\n     * call this method. It changes the display box\n     * and announces the corresponding change.\n     * @param origin the new origin\n     * @param corner the new corner\n     * @see #displayBox\n     */\n    public void displayBox(Point origin, Point corner) {\n        willChange();\n        basicDisplayBox(origin, corner);\n        changed();\n    }\n\n    /**\n     * Sets the display box of a figure. This is the\n     * method that subclassers override. Clients usually\n     * call displayBox.\n     * @see #displayBox\n     */\n    public abstract void basicDisplayBox(Point origin, Point corner);\n\n    /**\n     * Gets the display box of a figure.\n     */\n    public abstract Rectangle displayBox();\n\n    /**\n     * Returns the handles of a Figure that can be used\n     * to manipulate some of its attributes.\n     * @return a Vector of handles\n     * @see Handle\n     */\n    public abstract Vector handles();\n\n    /**\n     * Returns an Enumeration of the figures contained in this figure.\n     * @see CompositeFigure\n     */\n    public FigureEnumeration figures() {\n        Vector figures = new Vector(1);\n        figures.addElement(this);\n        return new FigureEnumerator(figures);\n    }\n\n    /**\n     * Gets the size of the figure. A convenience method.\n     */\n    public Dimension size() {\n        return new Dimension(displayBox().width, displayBox().height);\n    }\n\n    /**\n     * Checks if the figure is empty. The default implementation returns\n     * true if the width or height of its display box is < 3\n     * @see Figure#isEmpty\n     */\n    public boolean isEmpty() {\n        return (size().width < 3) || (size().height < 3);\n    }\n\n    /**\n     * Returns the figure that contains the given point.\n     * In contrast to containsPoint it returns its\n     * innermost figure that contains the point.\n     *\n     * @see #containsPoint\n     */\n    public Figure findFigureInside(int x, int y) {\n        if (containsPoint(x, y))\n            return this;\n        return null;\n    }\n\n    /**\n     * Checks if a point is inside the figure.\n     */\n    public boolean containsPoint(int x, int y) {\n        return displayBox().contains(x, y);\n    }\n\n    /**\n     * Changes the display box of a figure. This is a\n     * convenience method. Implementors should only\n     * have to override basicDisplayBox\n     * @see #displayBox\n     */\n    public void displayBox(Rectangle r) {\n        displayBox(new Point(r.x, r.y), new Point(r.x + r.width, r.y + r.height));\n    }\n\n    /**\n     * Checks whether the given figure is contained in this figure.\n     */\n    public boolean includes(Figure figure) {\n        return figure == this;\n    }\n\n    /**\n     * Decomposes a figure into its parts. It returns a Vector\n     * that contains itself.\n     * @return an Enumeration for a Vector with itself as the\n     * only element.\n     */\n    public FigureEnumeration decompose() {\n        Vector figures = new Vector(1);\n        figures.addElement(this);\n        return new FigureEnumerator(figures);\n    }\n\n    /**\n     * Sets the Figure's container and registers the container\n     * as a figure change listener. A figure's container can be\n     * any kind of FigureChangeListener. A figure is not restricted\n     * to have a single container.\n     */\n    public void addToContainer(FigureChangeListener c) {\n        addFigureChangeListener(c);\n        invalidate();\n    }\n\n    /**\n     * Removes a figure from the given container and unregisters\n     * it as a change listener.\n     */\n    public void removeFromContainer(FigureChangeListener c) {\n        invalidate();\n        removeFigureChangeListener(c);\n        changed();\n    }\n\n    /**\n     * Adds a listener for this figure.\n     */\n    public void addFigureChangeListener(FigureChangeListener l) {\n        fListener = FigureChangeEventMulticaster.add(fListener, l);\n    }\n\n    /**\n     * Removes a listener for this figure.\n     */\n    public void removeFigureChangeListener(FigureChangeListener l) {\n        fListener = FigureChangeEventMulticaster.remove(fListener, l);\n    }\n\n    /**\n     * Gets the figure's listners.\n     */\n    public FigureChangeListener listener() {\n        return fListener;\n    }\n\n    /**\n     * A figure is released from the drawing. You never call this\n     * method directly. Release notifies its listeners.\n     * @see Figure#release\n     */\n    public void release() {\n        if (fListener != null)\n            fListener.figureRemoved(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Invalidates the figure. This method informs the listeners\n     * that the figure's current display box is invalid and should be\n     * refreshed.\n     */\n    public void invalidate() {\n        if (fListener != null) {\n            Rectangle r = displayBox();\n            r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);\n            fListener.figureInvalidated(new FigureChangeEvent(this, r));\n        }\n    }\n\n    /**\n     * Informes that a figure is about to change something that\n     * affects the contents of its display box.\n     *\n     * @see Figure#willChange\n     */\n    public void willChange() {\n        invalidate();\n    }\n\n    /**\n     * Informs that a figure changed the area of its display box.\n     *\n     * @see FigureChangeEvent\n     * @see Figure#changed\n     */\n    public void changed() {\n        invalidate();\n        if (fListener != null)\n            fListener.figureChanged(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Gets the center of a figure. A convenice\n     * method that is rarely overridden.\n     */\n    public Point center() {\n        return Geom.center(displayBox());\n    }\n\n    /**\n     * Checks if this figure can be connected. By default\n     * AbstractFigures can be connected.\n     */\n    public boolean canConnect() {\n        return true;\n    }\n\n    /**\n     * Returns the connection inset. The connection inset\n     * defines the area where the display box of a\n     * figure can't be connected. By default the entire\n     * display box can be connected.\n     */\n    public Insets connectionInsets() {\n        return new Insets(0, 0, 0, 0);\n    }\n\n    /**\n     * Returns the Figures connector for the specified location.\n     * By default a ChopBoxConnector is returned.\n     * @see ChopBoxConnector\n     */\n    public Connector connectorAt(int x, int y) {\n        return new ChopBoxConnector(this);\n    }\n\n    /**\n     * Sets whether the connectors should be visible.\n     * By default they are not visible and\n     */\n    public void connectorVisibility(boolean isVisible) {\n    }\n\n    /**\n     * Returns the locator used to located connected text.\n     */\n    public Locator connectedTextLocator(Figure text) {\n        return RelativeLocator.center();\n    }\n\n    /**\n     * Returns the named attribute or null if a\n     * a figure doesn't have an attribute.\n     * By default\n     * figures don't have any attributes getAttribute\n     * returns null.\n     */\n    public Object getAttribute(String name) {\n        return null;\n    }\n\n    /**\n     * Sets the named attribute to the new value. By default\n     * figures don't have any attributes and the request is ignored.\n     */\n    public void setAttribute(String name, Object value) {\n    }\n\n    /**\n     * Clones a figure. Creates a clone by using the storable\n     * mechanism to flatten the Figure to stream followed by\n     * resurrecting it from the same stream.\n     *\n     * @see Figure#clone\n     */\n    public Object clone() {\n        Object clone = null;\n        ByteArrayOutputStream output = new ByteArrayOutputStream(200);\n        try {\n            ObjectOutput writer = new ObjectOutputStream(output);\n            writer.writeObject(this);\n            writer.close();\n        } catch (IOException e) {\n            System.out.println(\"Class not found: \" + e);\n        }\n        InputStream input = new ByteArrayInputStream(output.toByteArray());\n        try {\n            ObjectInput reader = new ObjectInputStream(input);\n            clone = (Object) reader.readObject();\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"Class not found: \" + e);\n        }\n        return clone;\n    }\n\n    /**\n     * Stores the Figure to a StorableOutput.\n     */\n    public void write(StorableOutput dw) {\n    }\n\n    /**\n     * Reads the Figure from a StorableInput.\n     */\n    public void read(StorableInput dr) throws IOException {\n    }\n}\n",
  "classDeclarationCode": "/**\n * AbstractFigure provides default implementations for\n * the Figure interface.\n *\n * <hr>\n * <b>Design Patterns</b><P>\n * <img src=\"images/red-ball-small.gif\" width=6 height=6 alt=\" o \">\n * <b><a href=../pattlets/sld036.htm>Template Method</a></b><br>\n * Template Methods implement default and invariant behavior for\n * figure subclasses.\n * <hr>\n *\n * @see Figure\n * @see Handle\n */\npublic abstract class AbstractFigure implements Figure {\n\n    /**\n     * The listeners for a figure's changes.\n     * @see #invalidate\n     * @see #changed\n     * @see #willChange\n     */\n    private transient FigureChangeListener fListener;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = -10857585979273442L;\n\n    private int abstractFigureSerializedDataVersion = 1;\n\n    protected AbstractFigure() {\n    }\n\n    /**\n     * Moves the figure by the given offset.\n     */\n    public void moveBy(int dx, int dy) {\n        willChange();\n        basicMoveBy(dx, dy);\n        changed();\n    }\n\n    /**\n     * Moves the figure. This is the\n     * method that subclassers override. Clients usually\n     * call displayBox.\n     * @see #moveBy\n     */\n    protected abstract void basicMoveBy(int dx, int dy);\n\n    /**\n     * Changes the display box of a figure. Clients usually\n     * call this method. It changes the display box\n     * and announces the corresponding change.\n     * @param origin the new origin\n     * @param corner the new corner\n     * @see #displayBox\n     */\n    public void displayBox(Point origin, Point corner) {\n        willChange();\n        basicDisplayBox(origin, corner);\n        changed();\n    }\n\n    /**\n     * Sets the display box of a figure. This is the\n     * method that subclassers override. Clients usually\n     * call displayBox.\n     * @see #displayBox\n     */\n    public abstract void basicDisplayBox(Point origin, Point corner);\n\n    /**\n     * Gets the display box of a figure.\n     */\n    public abstract Rectangle displayBox();\n\n    /**\n     * Returns the handles of a Figure that can be used\n     * to manipulate some of its attributes.\n     * @return a Vector of handles\n     * @see Handle\n     */\n    public abstract Vector handles();\n\n    /**\n     * Returns an Enumeration of the figures contained in this figure.\n     * @see CompositeFigure\n     */\n    public FigureEnumeration figures() {\n        Vector figures = new Vector(1);\n        figures.addElement(this);\n        return new FigureEnumerator(figures);\n    }\n\n    /**\n     * Gets the size of the figure. A convenience method.\n     */\n    public Dimension size() {\n        return new Dimension(displayBox().width, displayBox().height);\n    }\n\n    /**\n     * Checks if the figure is empty. The default implementation returns\n     * true if the width or height of its display box is < 3\n     * @see Figure#isEmpty\n     */\n    public boolean isEmpty() {\n        return (size().width < 3) || (size().height < 3);\n    }\n\n    /**\n     * Returns the figure that contains the given point.\n     * In contrast to containsPoint it returns its\n     * innermost figure that contains the point.\n     *\n     * @see #containsPoint\n     */\n    public Figure findFigureInside(int x, int y) {\n        if (containsPoint(x, y))\n            return this;\n        return null;\n    }\n\n    /**\n     * Checks if a point is inside the figure.\n     */\n    public boolean containsPoint(int x, int y) {\n        return displayBox().contains(x, y);\n    }\n\n    /**\n     * Changes the display box of a figure. This is a\n     * convenience method. Implementors should only\n     * have to override basicDisplayBox\n     * @see #displayBox\n     */\n    public void displayBox(Rectangle r) {\n        displayBox(new Point(r.x, r.y), new Point(r.x + r.width, r.y + r.height));\n    }\n\n    /**\n     * Checks whether the given figure is contained in this figure.\n     */\n    public boolean includes(Figure figure) {\n        return figure == this;\n    }\n\n    /**\n     * Decomposes a figure into its parts. It returns a Vector\n     * that contains itself.\n     * @return an Enumeration for a Vector with itself as the\n     * only element.\n     */\n    public FigureEnumeration decompose() {\n        Vector figures = new Vector(1);\n        figures.addElement(this);\n        return new FigureEnumerator(figures);\n    }\n\n    /**\n     * Sets the Figure's container and registers the container\n     * as a figure change listener. A figure's container can be\n     * any kind of FigureChangeListener. A figure is not restricted\n     * to have a single container.\n     */\n    public void addToContainer(FigureChangeListener c) {\n        addFigureChangeListener(c);\n        invalidate();\n    }\n\n    /**\n     * Removes a figure from the given container and unregisters\n     * it as a change listener.\n     */\n    public void removeFromContainer(FigureChangeListener c) {\n        invalidate();\n        removeFigureChangeListener(c);\n        changed();\n    }\n\n    /**\n     * Adds a listener for this figure.\n     */\n    public void addFigureChangeListener(FigureChangeListener l) {\n        fListener = FigureChangeEventMulticaster.add(fListener, l);\n    }\n\n    /**\n     * Removes a listener for this figure.\n     */\n    public void removeFigureChangeListener(FigureChangeListener l) {\n        fListener = FigureChangeEventMulticaster.remove(fListener, l);\n    }\n\n    /**\n     * Gets the figure's listners.\n     */\n    public FigureChangeListener listener() {\n        return fListener;\n    }\n\n    /**\n     * A figure is released from the drawing. You never call this\n     * method directly. Release notifies its listeners.\n     * @see Figure#release\n     */\n    public void release() {\n        if (fListener != null)\n            fListener.figureRemoved(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Invalidates the figure. This method informs the listeners\n     * that the figure's current display box is invalid and should be\n     * refreshed.\n     */\n    public void invalidate() {\n        if (fListener != null) {\n            Rectangle r = displayBox();\n            r.grow(Handle.HANDLESIZE, Handle.HANDLESIZE);\n            fListener.figureInvalidated(new FigureChangeEvent(this, r));\n        }\n    }\n\n    /**\n     * Informes that a figure is about to change something that\n     * affects the contents of its display box.\n     *\n     * @see Figure#willChange\n     */\n    public void willChange() {\n        invalidate();\n    }\n\n    /**\n     * Informs that a figure changed the area of its display box.\n     *\n     * @see FigureChangeEvent\n     * @see Figure#changed\n     */\n    public void changed() {\n        invalidate();\n        if (fListener != null)\n            fListener.figureChanged(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Gets the center of a figure. A convenice\n     * method that is rarely overridden.\n     */\n    public Point center() {\n        return Geom.center(displayBox());\n    }\n\n    /**\n     * Checks if this figure can be connected. By default\n     * AbstractFigures can be connected.\n     */\n    public boolean canConnect() {\n        return true;\n    }\n\n    /**\n     * Returns the connection inset. The connection inset\n     * defines the area where the display box of a\n     * figure can't be connected. By default the entire\n     * display box can be connected.\n     */\n    public Insets connectionInsets() {\n        return new Insets(0, 0, 0, 0);\n    }\n\n    /**\n     * Returns the Figures connector for the specified location.\n     * By default a ChopBoxConnector is returned.\n     * @see ChopBoxConnector\n     */\n    public Connector connectorAt(int x, int y) {\n        return new ChopBoxConnector(this);\n    }\n\n    /**\n     * Sets whether the connectors should be visible.\n     * By default they are not visible and\n     */\n    public void connectorVisibility(boolean isVisible) {\n    }\n\n    /**\n     * Returns the locator used to located connected text.\n     */\n    public Locator connectedTextLocator(Figure text) {\n        return RelativeLocator.center();\n    }\n\n    /**\n     * Returns the named attribute or null if a\n     * a figure doesn't have an attribute.\n     * By default\n     * figures don't have any attributes getAttribute\n     * returns null.\n     */\n    public Object getAttribute(String name) {\n        return null;\n    }\n\n    /**\n     * Sets the named attribute to the new value. By default\n     * figures don't have any attributes and the request is ignored.\n     */\n    public void setAttribute(String name, Object value) {\n    }\n\n    /**\n     * Clones a figure. Creates a clone by using the storable\n     * mechanism to flatten the Figure to stream followed by\n     * resurrecting it from the same stream.\n     *\n     * @see Figure#clone\n     */\n    public Object clone() {\n        Object clone = null;\n        ByteArrayOutputStream output = new ByteArrayOutputStream(200);\n        try {\n            ObjectOutput writer = new ObjectOutputStream(output);\n            writer.writeObject(this);\n            writer.close();\n        } catch (IOException e) {\n            System.out.println(\"Class not found: \" + e);\n        }\n        InputStream input = new ByteArrayInputStream(output.toByteArray());\n        try {\n            ObjectInput reader = new ObjectInputStream(input);\n            clone = (Object) reader.readObject();\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"Class not found: \" + e);\n        }\n        return clone;\n    }\n\n    /**\n     * Stores the Figure to a StorableOutput.\n     */\n    public void write(StorableOutput dw) {\n    }\n\n    /**\n     * Reads the Figure from a StorableInput.\n     */\n    public void read(StorableInput dr) throws IOException {\n    }\n}",
  "subClasses": [
    "CH.ifa.draw.standard.CompositeFigure",
    "CH.ifa.draw.standard.DecoratorFigure"
  ]
}