{
  "fullClassName": "CH.ifa.draw.standard.CompositeFigure",
  "className": "CompositeFigure",
  "index": 115,
  "modifier": "[public , abstract ]",
  "extend": "[AbstractFigure]",
  "implement": "[FigureChangeListener]",
  "packageName": "CH.ifa.draw.standard",
  "packageDeclaration": "package CH.ifa.draw.standard;",
  "classSignature": "public abstract class CompositeFigure",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": true,
  "imports": [
    "import CH.ifa.draw.util.*;",
    "import CH.ifa.draw.framework.*;",
    "import java.awt.*;",
    "import java.util.*;",
    "import java.io.*;"
  ],
  "fields": [
    "protected Vector fFigures;",
    "private static final long serialVersionUID = 7408153435700021866L;",
    "private int compositeFigureSerializedDataVersion = 1;"
  ],
  "superClasses": [
    "AbstractFigure"
  ],
  "implementedTypes": [
    "FigureChangeListener"
  ],
  "methodSigs": {
    "add(Figure)": "0",
    "addAll(Vector)": "1",
    "remove(Figure)": "2",
    "removeAll(Vector)": "3",
    "removeAll()": "4",
    "orphan(Figure)": "5",
    "orphanAll(Vector)": "6",
    "replace(Figure, Figure)": "7",
    "sendToBack(Figure)": "8",
    "bringToFront(Figure)": "9",
    "draw(Graphics)": "10",
    "figureAt(int)": "11",
    "figures()": "12",
    "figureCount()": "13",
    "figuresReverse()": "14",
    "findFigure(int, int)": "15",
    "findFigure(Rectangle)": "16",
    "findFigureWithout(int, int, Figure)": "17",
    "findFigure(Rectangle, Figure)": "18",
    "findFigureInside(int, int)": "19",
    "findFigureInsideWithout(int, int, Figure)": "20",
    "includes(Figure)": "21",
    "basicMoveBy(int, int)": "22",
    "release()": "23",
    "figureInvalidated(FigureChangeEvent)": "24",
    "figureRequestRemove(FigureChangeEvent)": "25",
    "figureRequestUpdate(FigureChangeEvent)": "26",
    "figureChanged(FigureChangeEvent)": "27",
    "figureRemoved(FigureChangeEvent)": "28",
    "write(StorableOutput)": "29",
    "read(StorableInput)": "30",
    "readObject(ObjectInputStream)": "31",
    "CompositeFigure()": "32"
  },
  "methodsBrief": [
    "public Figure add(Figure figure){}",
    "public void addAll(Vector newFigures){}",
    "public Figure remove(Figure figure){}",
    "public void removeAll(Vector figures){}",
    "public void removeAll(){}",
    "public synchronized Figure orphan(Figure figure){}",
    "public void orphanAll(Vector newFigures){}",
    "public synchronized void replace(Figure figure, Figure replacement){}",
    "public synchronized void sendToBack(Figure figure){}",
    "public synchronized void bringToFront(Figure figure){}",
    "public void draw(Graphics g){}",
    "public Figure figureAt(int i){}",
    "public final FigureEnumeration figures(){}",
    "public int figureCount(){}",
    "public final FigureEnumeration figuresReverse(){}",
    "public Figure findFigure(int x, int y){}",
    "public Figure findFigure(Rectangle r){}",
    "public Figure findFigureWithout(int x, int y, Figure without){}",
    "public Figure findFigure(Rectangle r, Figure without){}",
    "public Figure findFigureInside(int x, int y){}",
    "public Figure findFigureInsideWithout(int x, int y, Figure without){}",
    "public boolean includes(Figure figure){}",
    "protected void basicMoveBy(int x, int y){}",
    "public void release(){}",
    "public void figureInvalidated(FigureChangeEvent e){}",
    "public void figureRequestRemove(FigureChangeEvent e){}",
    "public void figureRequestUpdate(FigureChangeEvent e){}",
    "public void figureChanged(FigureChangeEvent e){}",
    "public void figureRemoved(FigureChangeEvent e){}",
    "public void write(StorableOutput dw){}",
    "public void read(StorableInput dr) throws IOException{}",
    "private void readObject(ObjectInputStream s)\r\n        throws ClassNotFoundException, IOException{}",
    "protected CompositeFigure(){}"
  ],
  "constructorSigs": [
    "CompositeFigure()"
  ],
  "constructorBrief": [
    "protected CompositeFigure(){}"
  ],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {},
  "compilationUnitCode": "/*\n * @(#)CompositeFigure.java 5.2\n *\n */\npackage CH.ifa.draw.standard;\n\nimport CH.ifa.draw.util.*;\nimport CH.ifa.draw.framework.*;\nimport java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\n/**\n * A Figure that is composed of several figures. A CompositeFigure\n * doesn't define any layout behavior. It is up to subclassers to\n * arrange the contained figures.\n * <hr>\n * <b>Design Patterns</b><P>\n * <img src=\"images/red-ball-small.gif\" width=6 height=6 alt=\" o \">\n * <b><a href=../pattlets/sld012.htm>Composite</a></b><br>\n * CompositeFigure enables to treat a composition of figures like\n * a single figure.<br>\n * @see Figure\n */\npublic abstract class CompositeFigure extends AbstractFigure implements FigureChangeListener {\n\n    /**\n     * The figures that this figure is composed of\n     * @see #add\n     * @see #remove\n     */\n    protected Vector fFigures;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = 7408153435700021866L;\n\n    private int compositeFigureSerializedDataVersion = 1;\n\n    protected CompositeFigure() {\n        fFigures = new Vector();\n    }\n\n    /**\n     * Adds a figure to the list of figures. Initializes the\n     * the figure's container.\n     */\n    public Figure add(Figure figure) {\n        if (!fFigures.contains(figure)) {\n            fFigures.addElement(figure);\n            figure.addToContainer(this);\n        }\n        return figure;\n    }\n\n    /**\n     * Adds a vector of figures.\n     * @see #add\n     */\n    public void addAll(Vector newFigures) {\n        Enumeration k = newFigures.elements();\n        while (k.hasMoreElements()) add((Figure) k.nextElement());\n    }\n\n    /**\n     * Removes a figure from the composite.\n     * @see #removeAll\n     */\n    public Figure remove(Figure figure) {\n        if (fFigures.contains(figure)) {\n            figure.removeFromContainer(this);\n            fFigures.removeElement(figure);\n        }\n        return figure;\n    }\n\n    /**\n     * Removes a vector of figures.\n     * @see #remove\n     */\n    public void removeAll(Vector figures) {\n        Enumeration k = figures.elements();\n        while (k.hasMoreElements()) remove((Figure) k.nextElement());\n    }\n\n    /**\n     * Removes all children.\n     * @see #remove\n     */\n    public void removeAll() {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.removeFromContainer(this);\n        }\n        fFigures.removeAllElements();\n    }\n\n    /**\n     * Removes a figure from the figure list, but\n     * doesn't release it. Use this method to temporarily\n     * manipulate a figure outside of the drawing.\n     */\n    public synchronized Figure orphan(Figure figure) {\n        fFigures.removeElement(figure);\n        return figure;\n    }\n\n    /**\n     * Removes a vector of figures from the figure's list\n     * without releasing the figures.\n     * @see #orphan\n     */\n    public void orphanAll(Vector newFigures) {\n        Enumeration k = newFigures.elements();\n        while (k.hasMoreElements()) orphan((Figure) k.nextElement());\n    }\n\n    /**\n     * Replaces a figure in the drawing without\n     * removing it from the drawing.\n     */\n    public synchronized void replace(Figure figure, Figure replacement) {\n        int index = fFigures.indexOf(figure);\n        if (index != -1) {\n            // will invalidate figure\n            replacement.addToContainer(this);\n            figure.changed();\n            fFigures.setElementAt(replacement, index);\n        }\n    }\n\n    /**\n     * Sends a figure to the back of the drawing.\n     */\n    public synchronized void sendToBack(Figure figure) {\n        if (fFigures.contains(figure)) {\n            fFigures.removeElement(figure);\n            fFigures.insertElementAt(figure, 0);\n            figure.changed();\n        }\n    }\n\n    /**\n     * Brings a figure to the front.\n     */\n    public synchronized void bringToFront(Figure figure) {\n        if (fFigures.contains(figure)) {\n            fFigures.removeElement(figure);\n            fFigures.addElement(figure);\n            figure.changed();\n        }\n    }\n\n    /**\n     * Draws all the contained figures\n     * @see Figure#draw\n     */\n    public void draw(Graphics g) {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) k.nextFigure().draw(g);\n    }\n\n    /**\n     * Gets a figure at the given index.\n     */\n    public Figure figureAt(int i) {\n        return (Figure) fFigures.elementAt(i);\n    }\n\n    /**\n     * Returns an Enumeration for accessing the contained figures.\n     * The figures are returned in the drawing order.\n     */\n    public final FigureEnumeration figures() {\n        return new FigureEnumerator(fFigures);\n    }\n\n    /**\n     * Gets number of child figures.\n     */\n    public int figureCount() {\n        return fFigures.size();\n    }\n\n    /**\n     * Returns an Enumeration for accessing the contained figures\n     * in the reverse drawing order.\n     */\n    public final FigureEnumeration figuresReverse() {\n        return new ReverseFigureEnumerator(fFigures);\n    }\n\n    /**\n     * Finds a top level Figure. Use this call for hit detection that\n     * should not descend into the figure's children.\n     */\n    public Figure findFigure(int x, int y) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure.containsPoint(x, y))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure that intersects the given rectangle.\n     */\n    public Figure findFigure(Rectangle r) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            Rectangle fr = figure.displayBox();\n            if (r.intersects(fr))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure, but supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     * @param x the x coordinate\n     * @param y the y coordinate\n     * @param without the figure to be ignored during\n     * the find.\n     */\n    public Figure findFigureWithout(int x, int y, Figure without) {\n        if (without == null) {\n            FigureEnumeration k1 = figuresReverse();\n            while (k1.hasMoreElements()) {\n                Figure figure1 = k1.nextFigure();\n                if (figure1.containsPoint(x, y))\n                    return figure1;\n            }\n            return null;\n        }\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure.containsPoint(x, y) && !figure.includes(without))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure that intersects the given rectangle.\n     * It supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     */\n    public Figure findFigure(Rectangle r, Figure without) {\n        if (without == null) {\n            FigureEnumeration k1 = figuresReverse();\n            while (k1.hasMoreElements()) {\n                Figure figure1 = k1.nextFigure();\n                Rectangle fr1 = figure1.displayBox();\n                if (r.intersects(fr1))\n                    return figure1;\n            }\n            return null;\n        }\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            Rectangle fr = figure.displayBox();\n            if (r.intersects(fr) && !figure.includes(without))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a figure but descends into a figure's\n     * children. Use this method to implement <i>click-through</i>\n     * hit detection, that is, you want to detect the inner most\n     * figure containing the given point.\n     */\n    public Figure findFigureInside(int x, int y) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure().findFigureInside(x, y);\n            if (figure != null)\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a figure but descends into a figure's\n     * children. It supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     */\n    public Figure findFigureInsideWithout(int x, int y, Figure without) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure != without) {\n                Figure found = figure.findFigureInside(x, y);\n                if (found != null)\n                    return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Checks if the composite figure has the argument as one of\n     * its children.\n     */\n    public boolean includes(Figure figure) {\n        if (super.includes(figure))\n            return true;\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure f = k.nextFigure();\n            if (f.includes(figure))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Moves all the given figures by x and y. Doesn't announce\n     * any changes. Subclassers override\n     * basicMoveBy. Clients usually call moveBy.\n     * @see #moveBy\n     */\n    protected void basicMoveBy(int x, int y) {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) k.nextFigure().moveBy(x, y);\n    }\n\n    /**\n     * Releases the figure and all its children.\n     */\n    public void release() {\n        super.release();\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.release();\n        }\n    }\n\n    /**\n     * Propagates the figureInvalidated event to my listener.\n     * @see FigureChangeListener\n     */\n    public void figureInvalidated(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureInvalidated(e);\n    }\n\n    /**\n     * Propagates the removeFromDrawing request up to the container.\n     * @see FigureChangeListener\n     */\n    public void figureRequestRemove(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestRemove(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Propagates the requestUpdate request up to the container.\n     * @see FigureChangeListener\n     */\n    public void figureRequestUpdate(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestUpdate(e);\n    }\n\n    public void figureChanged(FigureChangeEvent e) {\n    }\n\n    public void figureRemoved(FigureChangeEvent e) {\n    }\n\n    /**\n     * Writes the contained figures to the StorableOutput.\n     */\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fFigures.size());\n        Enumeration k = fFigures.elements();\n        while (k.hasMoreElements()) dw.writeStorable((Storable) k.nextElement());\n    }\n\n    /**\n     * Reads the contained figures from StorableInput.\n     */\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        int size = dr.readInt();\n        fFigures = new Vector(size);\n        for (int i = 0; i < size; i++) add((Figure) dr.readStorable());\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.addToContainer(this);\n        }\n    }\n}\n",
  "classDeclarationCode": "/**\n * A Figure that is composed of several figures. A CompositeFigure\n * doesn't define any layout behavior. It is up to subclassers to\n * arrange the contained figures.\n * <hr>\n * <b>Design Patterns</b><P>\n * <img src=\"images/red-ball-small.gif\" width=6 height=6 alt=\" o \">\n * <b><a href=../pattlets/sld012.htm>Composite</a></b><br>\n * CompositeFigure enables to treat a composition of figures like\n * a single figure.<br>\n * @see Figure\n */\npublic abstract class CompositeFigure extends AbstractFigure implements FigureChangeListener {\n\n    /**\n     * The figures that this figure is composed of\n     * @see #add\n     * @see #remove\n     */\n    protected Vector fFigures;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = 7408153435700021866L;\n\n    private int compositeFigureSerializedDataVersion = 1;\n\n    protected CompositeFigure() {\n        fFigures = new Vector();\n    }\n\n    /**\n     * Adds a figure to the list of figures. Initializes the\n     * the figure's container.\n     */\n    public Figure add(Figure figure) {\n        if (!fFigures.contains(figure)) {\n            fFigures.addElement(figure);\n            figure.addToContainer(this);\n        }\n        return figure;\n    }\n\n    /**\n     * Adds a vector of figures.\n     * @see #add\n     */\n    public void addAll(Vector newFigures) {\n        Enumeration k = newFigures.elements();\n        while (k.hasMoreElements()) add((Figure) k.nextElement());\n    }\n\n    /**\n     * Removes a figure from the composite.\n     * @see #removeAll\n     */\n    public Figure remove(Figure figure) {\n        if (fFigures.contains(figure)) {\n            figure.removeFromContainer(this);\n            fFigures.removeElement(figure);\n        }\n        return figure;\n    }\n\n    /**\n     * Removes a vector of figures.\n     * @see #remove\n     */\n    public void removeAll(Vector figures) {\n        Enumeration k = figures.elements();\n        while (k.hasMoreElements()) remove((Figure) k.nextElement());\n    }\n\n    /**\n     * Removes all children.\n     * @see #remove\n     */\n    public void removeAll() {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.removeFromContainer(this);\n        }\n        fFigures.removeAllElements();\n    }\n\n    /**\n     * Removes a figure from the figure list, but\n     * doesn't release it. Use this method to temporarily\n     * manipulate a figure outside of the drawing.\n     */\n    public synchronized Figure orphan(Figure figure) {\n        fFigures.removeElement(figure);\n        return figure;\n    }\n\n    /**\n     * Removes a vector of figures from the figure's list\n     * without releasing the figures.\n     * @see #orphan\n     */\n    public void orphanAll(Vector newFigures) {\n        Enumeration k = newFigures.elements();\n        while (k.hasMoreElements()) orphan((Figure) k.nextElement());\n    }\n\n    /**\n     * Replaces a figure in the drawing without\n     * removing it from the drawing.\n     */\n    public synchronized void replace(Figure figure, Figure replacement) {\n        int index = fFigures.indexOf(figure);\n        if (index != -1) {\n            // will invalidate figure\n            replacement.addToContainer(this);\n            figure.changed();\n            fFigures.setElementAt(replacement, index);\n        }\n    }\n\n    /**\n     * Sends a figure to the back of the drawing.\n     */\n    public synchronized void sendToBack(Figure figure) {\n        if (fFigures.contains(figure)) {\n            fFigures.removeElement(figure);\n            fFigures.insertElementAt(figure, 0);\n            figure.changed();\n        }\n    }\n\n    /**\n     * Brings a figure to the front.\n     */\n    public synchronized void bringToFront(Figure figure) {\n        if (fFigures.contains(figure)) {\n            fFigures.removeElement(figure);\n            fFigures.addElement(figure);\n            figure.changed();\n        }\n    }\n\n    /**\n     * Draws all the contained figures\n     * @see Figure#draw\n     */\n    public void draw(Graphics g) {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) k.nextFigure().draw(g);\n    }\n\n    /**\n     * Gets a figure at the given index.\n     */\n    public Figure figureAt(int i) {\n        return (Figure) fFigures.elementAt(i);\n    }\n\n    /**\n     * Returns an Enumeration for accessing the contained figures.\n     * The figures are returned in the drawing order.\n     */\n    public final FigureEnumeration figures() {\n        return new FigureEnumerator(fFigures);\n    }\n\n    /**\n     * Gets number of child figures.\n     */\n    public int figureCount() {\n        return fFigures.size();\n    }\n\n    /**\n     * Returns an Enumeration for accessing the contained figures\n     * in the reverse drawing order.\n     */\n    public final FigureEnumeration figuresReverse() {\n        return new ReverseFigureEnumerator(fFigures);\n    }\n\n    /**\n     * Finds a top level Figure. Use this call for hit detection that\n     * should not descend into the figure's children.\n     */\n    public Figure findFigure(int x, int y) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure.containsPoint(x, y))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure that intersects the given rectangle.\n     */\n    public Figure findFigure(Rectangle r) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            Rectangle fr = figure.displayBox();\n            if (r.intersects(fr))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure, but supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     * @param x the x coordinate\n     * @param y the y coordinate\n     * @param without the figure to be ignored during\n     * the find.\n     */\n    public Figure findFigureWithout(int x, int y, Figure without) {\n        if (without == null) {\n            FigureEnumeration k1 = figuresReverse();\n            while (k1.hasMoreElements()) {\n                Figure figure1 = k1.nextFigure();\n                if (figure1.containsPoint(x, y))\n                    return figure1;\n            }\n            return null;\n        }\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure.containsPoint(x, y) && !figure.includes(without))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a top level Figure that intersects the given rectangle.\n     * It supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     */\n    public Figure findFigure(Rectangle r, Figure without) {\n        if (without == null) {\n            FigureEnumeration k1 = figuresReverse();\n            while (k1.hasMoreElements()) {\n                Figure figure1 = k1.nextFigure();\n                Rectangle fr1 = figure1.displayBox();\n                if (r.intersects(fr1))\n                    return figure1;\n            }\n            return null;\n        }\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            Rectangle fr = figure.displayBox();\n            if (r.intersects(fr) && !figure.includes(without))\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a figure but descends into a figure's\n     * children. Use this method to implement <i>click-through</i>\n     * hit detection, that is, you want to detect the inner most\n     * figure containing the given point.\n     */\n    public Figure findFigureInside(int x, int y) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure().findFigureInside(x, y);\n            if (figure != null)\n                return figure;\n        }\n        return null;\n    }\n\n    /**\n     * Finds a figure but descends into a figure's\n     * children. It supresses the passed\n     * in figure. Use this method to ignore a figure\n     * that is temporarily inserted into the drawing.\n     */\n    public Figure findFigureInsideWithout(int x, int y, Figure without) {\n        FigureEnumeration k = figuresReverse();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            if (figure != without) {\n                Figure found = figure.findFigureInside(x, y);\n                if (found != null)\n                    return found;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Checks if the composite figure has the argument as one of\n     * its children.\n     */\n    public boolean includes(Figure figure) {\n        if (super.includes(figure))\n            return true;\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure f = k.nextFigure();\n            if (f.includes(figure))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Moves all the given figures by x and y. Doesn't announce\n     * any changes. Subclassers override\n     * basicMoveBy. Clients usually call moveBy.\n     * @see #moveBy\n     */\n    protected void basicMoveBy(int x, int y) {\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) k.nextFigure().moveBy(x, y);\n    }\n\n    /**\n     * Releases the figure and all its children.\n     */\n    public void release() {\n        super.release();\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.release();\n        }\n    }\n\n    /**\n     * Propagates the figureInvalidated event to my listener.\n     * @see FigureChangeListener\n     */\n    public void figureInvalidated(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureInvalidated(e);\n    }\n\n    /**\n     * Propagates the removeFromDrawing request up to the container.\n     * @see FigureChangeListener\n     */\n    public void figureRequestRemove(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestRemove(new FigureChangeEvent(this));\n    }\n\n    /**\n     * Propagates the requestUpdate request up to the container.\n     * @see FigureChangeListener\n     */\n    public void figureRequestUpdate(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestUpdate(e);\n    }\n\n    public void figureChanged(FigureChangeEvent e) {\n    }\n\n    public void figureRemoved(FigureChangeEvent e) {\n    }\n\n    /**\n     * Writes the contained figures to the StorableOutput.\n     */\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fFigures.size());\n        Enumeration k = fFigures.elements();\n        while (k.hasMoreElements()) dw.writeStorable((Storable) k.nextElement());\n    }\n\n    /**\n     * Reads the contained figures from StorableInput.\n     */\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        int size = dr.readInt();\n        fFigures = new Vector(size);\n        for (int i = 0; i < size; i++) add((Figure) dr.readStorable());\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        FigureEnumeration k = figures();\n        while (k.hasMoreElements()) {\n            Figure figure = k.nextFigure();\n            figure.addToContainer(this);\n        }\n    }\n}",
  "subClasses": [
    "CH.ifa.draw.standard.StandardDrawing"
  ]
}