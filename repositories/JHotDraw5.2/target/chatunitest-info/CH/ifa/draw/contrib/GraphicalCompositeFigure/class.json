{
  "fullClassName": "CH.ifa.draw.contrib.GraphicalCompositeFigure",
  "className": "GraphicalCompositeFigure",
  "index": 7,
  "modifier": "[public ]",
  "extend": "[CompositeFigure]",
  "implement": "[Layoutable]",
  "packageName": "CH.ifa.draw.contrib",
  "packageDeclaration": "package CH.ifa.draw.contrib;",
  "classSignature": "public class GraphicalCompositeFigure",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.awt.Graphics;",
    "import java.awt.Point;",
    "import java.awt.Rectangle;",
    "import java.io.IOException;",
    "import java.util.Vector;",
    "import CH.ifa.draw.figures.RectangleFigure;",
    "import CH.ifa.draw.framework.Figure;",
    "import CH.ifa.draw.framework.FigureChangeEvent;",
    "import CH.ifa.draw.standard.CompositeFigure;",
    "import CH.ifa.draw.util.StorableInput;",
    "import CH.ifa.draw.util.StorableOutput;"
  ],
  "fields": [
    "private Figure\tmyPresentationFigure;",
    "private Layouter myLayouter;",
    "private static final long serialVersionUID = 1265742491024232713L;"
  ],
  "superClasses": [
    "CompositeFigure"
  ],
  "implementedTypes": [
    "Layoutable"
  ],
  "methodSigs": {
    "initialize()": "0",
    "clone()": "1",
    "displayBox()": "2",
    "basicDisplayBox(Point, Point)": "3",
    "basicMoveBy(int, int)": "4",
    "update()": "5",
    "draw(Graphics)": "6",
    "handles()": "7",
    "getAttribute(String)": "8",
    "setAttribute(String, Object)": "9",
    "setPresentationFigure(Figure)": "10",
    "getPresentationFigure()": "11",
    "layout()": "12",
    "setLayouter(Layouter)": "13",
    "getLayouter()": "14",
    "change()": "15",
    "figureRequestRemove(FigureChangeEvent)": "16",
    "read(StorableInput)": "17",
    "write(StorableOutput)": "18",
    "GraphicalCompositeFigure()": "19",
    "GraphicalCompositeFigure(Figure)": "20"
  },
  "methodsBrief": [
    "protected void initialize(){}",
    "public Object clone(){}",
    "public Rectangle displayBox(){}",
    "public void basicDisplayBox(Point origin, Point corner){}",
    "protected void basicMoveBy(int dx, int dy){}",
    "public void update(){}",
    "public void draw(Graphics g){}",
    "public Vector handles(){}",
    "public Object getAttribute(String name){}",
    "public void setAttribute(String name, Object value){}",
    "public void setPresentationFigure(Figure newPresentationFigure){}",
    "public Figure getPresentationFigure(){}",
    "public void layout(){}",
    "public void setLayouter(Layouter newLayouter){}",
    "public Layouter getLayouter(){}",
    "protected void change(){}",
    "public void figureRequestRemove(FigureChangeEvent e){}",
    "public void read(StorableInput dr) throws IOException{}",
    "public void write(StorableOutput dw){}",
    "public GraphicalCompositeFigure(){}",
    "public GraphicalCompositeFigure(Figure newPresentationFigure){}"
  ],
  "constructorSigs": [
    "GraphicalCompositeFigure()",
    "GraphicalCompositeFigure(Figure)"
  ],
  "constructorBrief": [
    "public GraphicalCompositeFigure(){}",
    "public GraphicalCompositeFigure(Figure newPresentationFigure){}"
  ],
  "getterSetterSigs": [
    "setAttribute(String, Object)",
    "setPresentationFigure(Figure)",
    "getPresentationFigure()",
    "setLayouter(Layouter)",
    "getLayouter()"
  ],
  "getterSetterBrief": [
    "public void setAttribute(String name, Object value){}",
    "public void setPresentationFigure(Figure newPresentationFigure){}",
    "public Figure getPresentationFigure(){}",
    "public void setLayouter(Layouter newLayouter){}",
    "public Layouter getLayouter(){}"
  ],
  "constructorDeps": {
    "CH.ifa.draw.framework.Figure": [],
    "CH.ifa.draw.contrib.GraphicalCompositeFigure": [
      "setPresentationFigure(Figure)",
      "initialize()"
    ]
  },
  "compilationUnitCode": "/*\n * @(#)GraphicalCompositeFigure.java 5.2\n *\n */\npackage CH.ifa.draw.contrib;\n\nimport java.awt.Graphics;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.io.IOException;\nimport java.util.Vector;\nimport CH.ifa.draw.figures.RectangleFigure;\nimport CH.ifa.draw.framework.Figure;\nimport CH.ifa.draw.framework.FigureChangeEvent;\nimport CH.ifa.draw.standard.CompositeFigure;\nimport CH.ifa.draw.util.StorableInput;\nimport CH.ifa.draw.util.StorableOutput;\n\n/**\n * The GraphicalCompositeFigure fills in the gap between a CompositeFigure\n * and other figures which mainly have a presentation purpose. The\n * GraphicalCompositeFigure can be configured with any Figure which\n * takes over the task for rendering the graphical presentation for\n * a CompositeFigure. Therefore, the GraphicalCompositeFigure manages\n * contained figures like the CompositeFigure does, but delegates\n * its graphical presentation to another (graphical) figure which\n * purpose it is to draw the container for all contained figures.\n *\n * @author\tWolfram Kaiser\n */\npublic class GraphicalCompositeFigure extends CompositeFigure implements Layoutable {\n\n    /**\n     * Figure which performs all presentation tasks for this\n     * CompositeFigure as CompositeFigures usually don't have\n     * an own presentation but present only the sum of all its\n     * children.\n     */\n    private Figure myPresentationFigure;\n\n    /**\n     * A Layouter determines how the CompositeFigure should\n     * be laid out graphically.\n     */\n    private Layouter myLayouter;\n\n    private static final long serialVersionUID = 1265742491024232713L;\n\n    public GraphicalCompositeFigure() {\n        this(new RectangleFigure());\n    }\n\n    public GraphicalCompositeFigure(Figure newPresentationFigure) {\n        super();\n        setPresentationFigure(newPresentationFigure);\n        initialize();\n    }\n\n    /**\n     * This method performs additional initialization operations,\n     * in this case setting the Layouter.\n     * It is called from the constructors and the clone() method.\n     * A StandardLayouter is set.\n     */\n    protected void initialize() {\n        setLayouter(new StandardLayouter(this));\n    }\n\n    /**\n     * Clones a figure and initializes it\n     *\n     * @see Figure#clone\n     */\n    public Object clone() {\n        Object cloneObject = super.clone();\n        ((GraphicalCompositeFigure) cloneObject).initialize();\n        return cloneObject;\n    }\n\n    /**\n     * Return the display area. This method is delegated to the encapsulated presentation figure.\n     */\n    public Rectangle displayBox() {\n        return getPresentationFigure().displayBox();\n    }\n\n    /**\n     * Standard presentation method which is delegated to the encapsulated presentation figure.\n     */\n    public void basicDisplayBox(Point origin, Point corner) {\n        Rectangle r = getLayouter().layout(origin, corner);\n        getPresentationFigure().basicDisplayBox(r.getLocation(), new Point(r.width, r.height));\n    }\n\n    /**\n     * Standard presentation method which is delegated to the encapsulated presentation figure.\n     * The presentation figure is moved as well as all contained figures.\n     */\n    protected void basicMoveBy(int dx, int dy) {\n        super.basicMoveBy(dx, dy);\n        getPresentationFigure().moveBy(dx, dy);\n    }\n\n    /**\n     * Expicit update: an updated involves a layout for all contained figures.\n     */\n    public void update() {\n        willChange();\n        layout();\n        change();\n        changed();\n    }\n\n    /**\n     * Draw the figure. This method is delegated to the encapsulated presentation figure.\n     */\n    public void draw(Graphics g) {\n        getPresentationFigure().draw(g);\n        super.draw(g);\n    }\n\n    /**\n     * Return default handles from the presentation figure.\n     */\n    public Vector handles() {\n        return getPresentationFigure().handles();\n    }\n\n    /**\n     * Delegate capabilities for storing and retrieving attributes to a\n     * CompositeFigure if the encapsulated presentation figure. If no\n     * presentation figure is found then the superclass' getAttribute()\n     * will be invoked (which currently returns always \"null\").\n     *\n     * @param\tname\tname of the attribute whose value should be returned\n     * @return\tvalue of the attribute with the given name\n     */\n    public Object getAttribute(String name) {\n        if (getPresentationFigure() != null) {\n            return getPresentationFigure().getAttribute(name);\n        } else {\n            return super.getAttribute(name);\n        }\n    }\n\n    /**\n     * Delegate capabilities for storing and retrieving attributes to a\n     * CompositeFigure if the encapsulated presentation figure. If no\n     * presentation figure is found then the superclass' setAttribute()\n     * will be invoked (which currently does not set an attribute).\n     *\n     * @param\tname\tname of the attribute\n     * @param\tvalue\tvalue associated with this attribute\n     */\n    public void setAttribute(String name, Object value) {\n        if (getPresentationFigure() != null) {\n            getPresentationFigure().setAttribute(name, value);\n        } else {\n            super.setAttribute(name, value);\n        }\n    }\n\n    /**\n     * Set a figure which renders this CompositeFigure. The presentation\n     * tasks for the CompositeFigure are delegated to this presentation\n     * figure.\n     *\n     * @param\tnewPresentationFigure\tfigure takes over the presentation tasks\n     */\n    public void setPresentationFigure(Figure newPresentationFigure) {\n        myPresentationFigure = newPresentationFigure;\n    }\n\n    /**\n     * Get a figure which renders this CompositeFigure. The presentation\n     * tasks for the CompositeFigure are delegated to this presentation\n     * figure.\n     *\n     * @return\tfigure takes over the presentation tasks\n     */\n    public Figure getPresentationFigure() {\n        return myPresentationFigure;\n    }\n\n    /**\n     * A layout algorithm is used to define how the child components\n     * should be laid out in relation to each other. The task for\n     * layouting the child components for presentation is delegated\n     * to a Layouter which can be plugged in at runtime.\n     */\n    public void layout() {\n        if (getLayouter() != null) {\n            Rectangle r = getLayouter().calculateLayout(displayBox().getLocation(), displayBox().getLocation());\n            displayBox(r.getLocation(), new Point(r.x + r.width, r.y + r.height));\n        }\n    }\n\n    /**\n     * Set a Layouter object which encapsulated a layout\n     * algorithm for this figure. Typically, a Layouter\n     * accesses the child components of this figure and arranges\n     * their graphical presentation. It is a good idea to set\n     * the Layouter in the protected initialize() method\n     * so it can be recreated if a GraphicalCompositeFigure is\n     * read and restored from a StorableInput stream.\n     *\n     * @param\tnewLayouter\tencapsulation of a layout algorithm.\n     */\n    public void setLayouter(Layouter newLayouter) {\n        myLayouter = newLayouter;\n    }\n\n    /**\n     * Get a Layouter object which encapsulated a layout\n     * algorithm for this figure. Typically, a Layouter\n     * accesses the child components of this figure and arranges\n     * their graphical presentation.\n     *\n     * @return\tlayout strategy used by this figure\n     */\n    public Layouter getLayouter() {\n        return myLayouter;\n    }\n\n    /**\n     * Notify the registered change listener if an exlicit change\n     * to the component (or one of its child components has occurred).\n     */\n    protected void change() {\n        if (listener() != null) {\n            listener().figureRequestUpdate(new FigureChangeEvent(this));\n        }\n    }\n\n    /**\n     * Propagates the removeFromDrawing request up to the container.\n     */\n    public void figureRequestRemove(FigureChangeEvent e) {\n        if (listener() != null) {\n            if (includes(e.getFigure())) {\n                listener().figureRequestRemove(new FigureChangeEvent(e.getFigure(), e.getInvalidatedRectangle()));\n            } else {\n                super.figureRequestRemove(e);\n            }\n        }\n    }\n\n    /**\n     * Reads the contained figures from StorableInput. The\n     * figure responsible for graphical presentation is read\n     * together with all child components. The Layouter\n     * is not stored and therefore not read.\n     */\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        setPresentationFigure((Figure) dr.readStorable());\n    }\n\n    /**\n     * Writes the contained figures to the StorableOutput. The\n     * figure responsible for graphical presentation is written\n     * together with all child components. The Layouter\n     * is not written.\n     */\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeStorable(getPresentationFigure());\n    }\n}\n",
  "classDeclarationCode": "/**\n * The GraphicalCompositeFigure fills in the gap between a CompositeFigure\n * and other figures which mainly have a presentation purpose. The\n * GraphicalCompositeFigure can be configured with any Figure which\n * takes over the task for rendering the graphical presentation for\n * a CompositeFigure. Therefore, the GraphicalCompositeFigure manages\n * contained figures like the CompositeFigure does, but delegates\n * its graphical presentation to another (graphical) figure which\n * purpose it is to draw the container for all contained figures.\n *\n * @author\tWolfram Kaiser\n */\npublic class GraphicalCompositeFigure extends CompositeFigure implements Layoutable {\n\n    /**\n     * Figure which performs all presentation tasks for this\n     * CompositeFigure as CompositeFigures usually don't have\n     * an own presentation but present only the sum of all its\n     * children.\n     */\n    private Figure myPresentationFigure;\n\n    /**\n     * A Layouter determines how the CompositeFigure should\n     * be laid out graphically.\n     */\n    private Layouter myLayouter;\n\n    private static final long serialVersionUID = 1265742491024232713L;\n\n    public GraphicalCompositeFigure() {\n        this(new RectangleFigure());\n    }\n\n    public GraphicalCompositeFigure(Figure newPresentationFigure) {\n        super();\n        setPresentationFigure(newPresentationFigure);\n        initialize();\n    }\n\n    /**\n     * This method performs additional initialization operations,\n     * in this case setting the Layouter.\n     * It is called from the constructors and the clone() method.\n     * A StandardLayouter is set.\n     */\n    protected void initialize() {\n        setLayouter(new StandardLayouter(this));\n    }\n\n    /**\n     * Clones a figure and initializes it\n     *\n     * @see Figure#clone\n     */\n    public Object clone() {\n        Object cloneObject = super.clone();\n        ((GraphicalCompositeFigure) cloneObject).initialize();\n        return cloneObject;\n    }\n\n    /**\n     * Return the display area. This method is delegated to the encapsulated presentation figure.\n     */\n    public Rectangle displayBox() {\n        return getPresentationFigure().displayBox();\n    }\n\n    /**\n     * Standard presentation method which is delegated to the encapsulated presentation figure.\n     */\n    public void basicDisplayBox(Point origin, Point corner) {\n        Rectangle r = getLayouter().layout(origin, corner);\n        getPresentationFigure().basicDisplayBox(r.getLocation(), new Point(r.width, r.height));\n    }\n\n    /**\n     * Standard presentation method which is delegated to the encapsulated presentation figure.\n     * The presentation figure is moved as well as all contained figures.\n     */\n    protected void basicMoveBy(int dx, int dy) {\n        super.basicMoveBy(dx, dy);\n        getPresentationFigure().moveBy(dx, dy);\n    }\n\n    /**\n     * Expicit update: an updated involves a layout for all contained figures.\n     */\n    public void update() {\n        willChange();\n        layout();\n        change();\n        changed();\n    }\n\n    /**\n     * Draw the figure. This method is delegated to the encapsulated presentation figure.\n     */\n    public void draw(Graphics g) {\n        getPresentationFigure().draw(g);\n        super.draw(g);\n    }\n\n    /**\n     * Return default handles from the presentation figure.\n     */\n    public Vector handles() {\n        return getPresentationFigure().handles();\n    }\n\n    /**\n     * Delegate capabilities for storing and retrieving attributes to a\n     * CompositeFigure if the encapsulated presentation figure. If no\n     * presentation figure is found then the superclass' getAttribute()\n     * will be invoked (which currently returns always \"null\").\n     *\n     * @param\tname\tname of the attribute whose value should be returned\n     * @return\tvalue of the attribute with the given name\n     */\n    public Object getAttribute(String name) {\n        if (getPresentationFigure() != null) {\n            return getPresentationFigure().getAttribute(name);\n        } else {\n            return super.getAttribute(name);\n        }\n    }\n\n    /**\n     * Delegate capabilities for storing and retrieving attributes to a\n     * CompositeFigure if the encapsulated presentation figure. If no\n     * presentation figure is found then the superclass' setAttribute()\n     * will be invoked (which currently does not set an attribute).\n     *\n     * @param\tname\tname of the attribute\n     * @param\tvalue\tvalue associated with this attribute\n     */\n    public void setAttribute(String name, Object value) {\n        if (getPresentationFigure() != null) {\n            getPresentationFigure().setAttribute(name, value);\n        } else {\n            super.setAttribute(name, value);\n        }\n    }\n\n    /**\n     * Set a figure which renders this CompositeFigure. The presentation\n     * tasks for the CompositeFigure are delegated to this presentation\n     * figure.\n     *\n     * @param\tnewPresentationFigure\tfigure takes over the presentation tasks\n     */\n    public void setPresentationFigure(Figure newPresentationFigure) {\n        myPresentationFigure = newPresentationFigure;\n    }\n\n    /**\n     * Get a figure which renders this CompositeFigure. The presentation\n     * tasks for the CompositeFigure are delegated to this presentation\n     * figure.\n     *\n     * @return\tfigure takes over the presentation tasks\n     */\n    public Figure getPresentationFigure() {\n        return myPresentationFigure;\n    }\n\n    /**\n     * A layout algorithm is used to define how the child components\n     * should be laid out in relation to each other. The task for\n     * layouting the child components for presentation is delegated\n     * to a Layouter which can be plugged in at runtime.\n     */\n    public void layout() {\n        if (getLayouter() != null) {\n            Rectangle r = getLayouter().calculateLayout(displayBox().getLocation(), displayBox().getLocation());\n            displayBox(r.getLocation(), new Point(r.x + r.width, r.y + r.height));\n        }\n    }\n\n    /**\n     * Set a Layouter object which encapsulated a layout\n     * algorithm for this figure. Typically, a Layouter\n     * accesses the child components of this figure and arranges\n     * their graphical presentation. It is a good idea to set\n     * the Layouter in the protected initialize() method\n     * so it can be recreated if a GraphicalCompositeFigure is\n     * read and restored from a StorableInput stream.\n     *\n     * @param\tnewLayouter\tencapsulation of a layout algorithm.\n     */\n    public void setLayouter(Layouter newLayouter) {\n        myLayouter = newLayouter;\n    }\n\n    /**\n     * Get a Layouter object which encapsulated a layout\n     * algorithm for this figure. Typically, a Layouter\n     * accesses the child components of this figure and arranges\n     * their graphical presentation.\n     *\n     * @return\tlayout strategy used by this figure\n     */\n    public Layouter getLayouter() {\n        return myLayouter;\n    }\n\n    /**\n     * Notify the registered change listener if an exlicit change\n     * to the component (or one of its child components has occurred).\n     */\n    protected void change() {\n        if (listener() != null) {\n            listener().figureRequestUpdate(new FigureChangeEvent(this));\n        }\n    }\n\n    /**\n     * Propagates the removeFromDrawing request up to the container.\n     */\n    public void figureRequestRemove(FigureChangeEvent e) {\n        if (listener() != null) {\n            if (includes(e.getFigure())) {\n                listener().figureRequestRemove(new FigureChangeEvent(e.getFigure(), e.getInvalidatedRectangle()));\n            } else {\n                super.figureRequestRemove(e);\n            }\n        }\n    }\n\n    /**\n     * Reads the contained figures from StorableInput. The\n     * figure responsible for graphical presentation is read\n     * together with all child components. The Layouter\n     * is not stored and therefore not read.\n     */\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        setPresentationFigure((Figure) dr.readStorable());\n    }\n\n    /**\n     * Writes the contained figures to the StorableOutput. The\n     * figure responsible for graphical presentation is written\n     * together with all child components. The Layouter\n     * is not written.\n     */\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeStorable(getPresentationFigure());\n    }\n}",
  "subClasses": []
}