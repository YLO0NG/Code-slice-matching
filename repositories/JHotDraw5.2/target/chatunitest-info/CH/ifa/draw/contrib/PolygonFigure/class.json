{
  "fullClassName": "CH.ifa.draw.contrib.PolygonFigure",
  "className": "PolygonFigure",
  "index": 12,
  "modifier": "[public ]",
  "extend": "[AttributeFigure]",
  "implement": "[]",
  "packageName": "CH.ifa.draw.contrib",
  "packageDeclaration": "package CH.ifa.draw.contrib;",
  "classSignature": "public  class PolygonFigure",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.awt.Graphics;",
    "import java.awt.Point;",
    "import java.awt.Polygon;",
    "import java.awt.Rectangle;",
    "import java.io.IOException;",
    "import java.util.Enumeration;",
    "import java.util.Vector;",
    "import CH.ifa.draw.figures.AttributeFigure;",
    "import CH.ifa.draw.framework.Connector;",
    "import CH.ifa.draw.framework.Figure;",
    "import CH.ifa.draw.framework.Locator;",
    "import CH.ifa.draw.standard.AbstractLocator;",
    "import CH.ifa.draw.util.Geom;",
    "import CH.ifa.draw.util.StorableInput;",
    "import CH.ifa.draw.util.StorableOutput;"
  ],
  "fields": [
    "static final int TOO_CLOSE = 2;",
    "private static final long serialVersionUID = 6254089689239215026L;",
    "private int polygonFigureSerializedDataVersion = 1;",
    "protected Polygon fPoly = new Polygon();"
  ],
  "superClasses": [
    "AttributeFigure"
  ],
  "implementedTypes": [],
  "methodSigs": {
    "displayBox()": "0",
    "isEmpty()": "1",
    "handles()": "2",
    "basicDisplayBox(Point, Point)": "3",
    "getPolygon()": "4",
    "center()": "5",
    "points()": "6",
    "pointCount()": "7",
    "basicMoveBy(int, int)": "8",
    "drawBackground(Graphics)": "9",
    "drawFrame(Graphics)": "10",
    "containsPoint(int, int)": "11",
    "connectorAt(int, int)": "12",
    "addPoint(int, int)": "13",
    "setPointAt(Point, int)": "14",
    "insertPointAt(Point, int)": "15",
    "removePointAt(int)": "16",
    "scaleRotate(Point, Polygon, Point)": "17",
    "smoothPoints()": "18",
    "splitSegment(int, int)": "19",
    "pointAt(int)": "20",
    "outermostPoint()": "21",
    "findSegment(int, int)": "22",
    "chop(Point)": "23",
    "write(StorableOutput)": "24",
    "read(StorableInput)": "25",
    "locator(int)": "26",
    "distanceFromLine(int, int, int, int, int, int)": "27",
    "bounds(Polygon)": "28",
    "center(Polygon)": "29",
    "chop(Polygon, Point)": "30",
    "PolygonFigure()": "31",
    "PolygonFigure(int, int)": "32",
    "PolygonFigure(Polygon)": "33"
  },
  "methodsBrief": [
    "public Rectangle displayBox(){}",
    "public boolean isEmpty(){}",
    "public Vector handles(){}",
    "public void basicDisplayBox(Point origin, Point corner){}",
    "public Polygon getPolygon(){}",
    "public Point center(){}",
    "public Enumeration points(){}",
    "public int pointCount(){}",
    "public void basicMoveBy(int dx, int dy){}",
    "public void drawBackground(Graphics g){}",
    "public void drawFrame(Graphics g){}",
    "public boolean containsPoint(int x, int y){}",
    "public Connector connectorAt(int x, int y){}",
    "public  void addPoint(int x, int y){}",
    "public  void setPointAt(Point p, int i){}",
    "public  void insertPointAt(Point p, int i){}",
    "public  void removePointAt(int i){}",
    "public  void scaleRotate(Point anchor, Polygon originalPolygon, Point p){}",
    "public void smoothPoints(){}",
    "public int splitSegment(int x, int y){}",
    "public Point pointAt(int i){}",
    "public Point outermostPoint(){}",
    "public int findSegment(int x, int y){}",
    "public Point chop(Point p){}",
    "public void write(StorableOutput dw){}",
    "public void read(StorableInput dr) throws IOException{}",
    "public static Locator locator(final int pointIndex){}",
    "public static double distanceFromLine(int xa, int ya,\r\n                                        int xb, int yb,\r\n                                        int xc, int yc){}",
    "public static Rectangle bounds(Polygon p){}",
    "public static Point center(Polygon p){}",
    "public static Point chop(Polygon poly, Point p){}",
    "public PolygonFigure(){}",
    "public PolygonFigure(int x, int y){}",
    "public PolygonFigure(Polygon p){}"
  ],
  "constructorSigs": [
    "PolygonFigure()",
    "PolygonFigure(int, int)",
    "PolygonFigure(Polygon)"
  ],
  "constructorBrief": [
    "public PolygonFigure(){}",
    "public PolygonFigure(int x, int y){}",
    "public PolygonFigure(Polygon p){}"
  ],
  "getterSetterSigs": [
    "getPolygon()",
    "setPointAt(Point, int)"
  ],
  "getterSetterBrief": [
    "public Polygon getPolygon(){}",
    "public  void setPointAt(Point p, int i){}"
  ],
  "constructorDeps": {
    "java.awt.Polygon": [
      "addPoint(int, int)"
    ]
  },
  "compilationUnitCode": "/*\n * Fri Feb 28 07:47:05 1997  Doug Lea  (dl at gee)\n * Based on PolyLineFigure\n */\npackage CH.ifa.draw.contrib;\n\nimport java.awt.Graphics;\nimport java.awt.Point;\nimport java.awt.Polygon;\nimport java.awt.Rectangle;\nimport java.io.IOException;\nimport java.util.Enumeration;\nimport java.util.Vector;\nimport CH.ifa.draw.figures.AttributeFigure;\nimport CH.ifa.draw.framework.Connector;\nimport CH.ifa.draw.framework.Figure;\nimport CH.ifa.draw.framework.Locator;\nimport CH.ifa.draw.standard.AbstractLocator;\nimport CH.ifa.draw.util.Geom;\nimport CH.ifa.draw.util.StorableInput;\nimport CH.ifa.draw.util.StorableOutput;\n\n/**\n * A scalable, rotatable polygon with an arbitrary number of points\n */\npublic class PolygonFigure extends AttributeFigure {\n\n    /**\n     * Distance threshold for smoothing away or locating points\n     */\n    static final int TOO_CLOSE = 2;\n\n    /*\n   * Serialization support.\n   */\n    private static final long serialVersionUID = 6254089689239215026L;\n\n    private int polygonFigureSerializedDataVersion = 1;\n\n    protected Polygon fPoly = new Polygon();\n\n    public PolygonFigure() {\n        super();\n    }\n\n    public PolygonFigure(int x, int y) {\n        fPoly.addPoint(x, y);\n    }\n\n    public PolygonFigure(Polygon p) {\n        fPoly = new Polygon(p.xpoints, p.ypoints, p.npoints);\n    }\n\n    public Rectangle displayBox() {\n        return bounds(fPoly);\n    }\n\n    public boolean isEmpty() {\n        return (fPoly.npoints < 3 || (size().width < TOO_CLOSE) && (size().height < TOO_CLOSE));\n    }\n\n    public Vector handles() {\n        Vector handles = new Vector(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; i++) handles.addElement(new PolygonHandle(this, locator(i), i));\n        handles.addElement(new PolygonScaleHandle(this));\n        // handles.addElement(new PolygonPointAddHandle(this));\n        return handles;\n    }\n\n    public void basicDisplayBox(Point origin, Point corner) {\n        Rectangle r = displayBox();\n        int dx = origin.x - r.x;\n        int dy = origin.y - r.y;\n        fPoly.translate(dx, dy);\n        r = displayBox();\n        Point oldCorner = new Point(r.x + r.width, r.y + r.height);\n        Polygon p = getPolygon();\n        scaleRotate(oldCorner, p, corner);\n    }\n\n    /**\n     * return a copy of the raw polygon\n     */\n    public Polygon getPolygon() {\n        return new Polygon(fPoly.xpoints, fPoly.ypoints, fPoly.npoints);\n    }\n\n    public Point center() {\n        return center(fPoly);\n    }\n\n    public Enumeration points() {\n        Vector pts = new Vector(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; ++i) pts.addElement(new Point(fPoly.xpoints[i], fPoly.ypoints[i]));\n        return pts.elements();\n    }\n\n    public int pointCount() {\n        return fPoly.npoints;\n    }\n\n    public void basicMoveBy(int dx, int dy) {\n        fPoly.translate(dx, dy);\n    }\n\n    public void drawBackground(Graphics g) {\n        g.fillPolygon(fPoly);\n    }\n\n    public void drawFrame(Graphics g) {\n        g.drawPolygon(fPoly);\n    }\n\n    public boolean containsPoint(int x, int y) {\n        return fPoly.contains(x, y);\n    }\n\n    public Connector connectorAt(int x, int y) {\n        return new ChopPolygonConnector(this);\n    }\n\n    /**\n     * Adds a node to the list of points.\n     */\n    public void addPoint(int x, int y) {\n        fPoly.addPoint(x, y);\n        changed();\n    }\n\n    /**\n     * Changes the position of a node.\n     */\n    public void setPointAt(Point p, int i) {\n        willChange();\n        fPoly.xpoints[i] = p.x;\n        fPoly.ypoints[i] = p.y;\n        changed();\n    }\n\n    /**\n     * Insert a node at the given point.\n     */\n    public void insertPointAt(Point p, int i) {\n        willChange();\n        int n = fPoly.npoints + 1;\n        int[] xs = new int[n];\n        int[] ys = new int[n];\n        for (int j = 0; j < i; ++j) {\n            xs[j] = fPoly.xpoints[j];\n            ys[j] = fPoly.ypoints[j];\n        }\n        xs[i] = p.x;\n        ys[i] = p.y;\n        for (int j = i; j < fPoly.npoints; ++j) {\n            xs[j + 1] = fPoly.xpoints[j];\n            ys[j + 1] = fPoly.ypoints[j];\n        }\n        fPoly = new Polygon(xs, ys, n);\n        changed();\n    }\n\n    public void removePointAt(int i) {\n        willChange();\n        int n = fPoly.npoints - 1;\n        int[] xs = new int[n];\n        int[] ys = new int[n];\n        for (int j = 0; j < i; ++j) {\n            xs[j] = fPoly.xpoints[j];\n            ys[j] = fPoly.ypoints[j];\n        }\n        for (int j = i; j < n; ++j) {\n            xs[j] = fPoly.xpoints[j + 1];\n            ys[j] = fPoly.ypoints[j + 1];\n        }\n        fPoly = new Polygon(xs, ys, n);\n        changed();\n    }\n\n    /**\n     * Scale and rotate relative to anchor\n     */\n    public void scaleRotate(Point anchor, Polygon originalPolygon, Point p) {\n        willChange();\n        long sx = 0;\n        long sy = 0;\n        int n1 = originalPolygon.npoints;\n        for (int i1 = 0; i1 < n1; i1++) {\n            sx += originalPolygon.xpoints[i1];\n            sy += originalPolygon.ypoints[i1];\n        }\n        // use center to determine relative angles and lengths\n        Point ctr = new Point((int) (sx / n1), (int) (sy / n1));\n        double anchorLen = Geom.length(ctr.x, ctr.y, anchor.x, anchor.y);\n        if (anchorLen > 0.0) {\n            double newLen = Geom.length(ctr.x, ctr.y, p.x, p.y);\n            double ratio = newLen / anchorLen;\n            double anchorAngle = Math.atan2(anchor.y - ctr.y, anchor.x - ctr.x);\n            double newAngle = Math.atan2(p.y - ctr.y, p.x - ctr.x);\n            double rotation = newAngle - anchorAngle;\n            int n = originalPolygon.npoints;\n            int[] xs = new int[n];\n            int[] ys = new int[n];\n            for (int i = 0; i < n; ++i) {\n                int x = originalPolygon.xpoints[i];\n                int y = originalPolygon.ypoints[i];\n                double l = Geom.length(ctr.x, ctr.y, x, y) * ratio;\n                double a = Math.atan2(y - ctr.y, x - ctr.x) + rotation;\n                xs[i] = (int) (ctr.x + l * Math.cos(a) + 0.5);\n                ys[i] = (int) (ctr.y + l * Math.sin(a) + 0.5);\n            }\n            fPoly = new Polygon(xs, ys, n);\n        }\n        changed();\n    }\n\n    /**\n     * Remove points that are nearly colinear with others\n     */\n    public void smoothPoints() {\n        willChange();\n        boolean removed = false;\n        int n = fPoly.npoints;\n        do {\n            removed = false;\n            int i = 0;\n            while (i < n && n >= 3) {\n                int nxt = (i + 1) % n;\n                int prv = (i - 1 + n) % n;\n                if ((distanceFromLine(fPoly.xpoints[prv], fPoly.ypoints[prv], fPoly.xpoints[nxt], fPoly.ypoints[nxt], fPoly.xpoints[i], fPoly.ypoints[i]) < TOO_CLOSE)) {\n                    removed = true;\n                    --n;\n                    for (int j = i; j < n; ++j) {\n                        fPoly.xpoints[j] = fPoly.xpoints[j + 1];\n                        fPoly.ypoints[j] = fPoly.ypoints[j + 1];\n                    }\n                } else\n                    ++i;\n            }\n        } while (removed);\n        if (n != fPoly.npoints)\n            fPoly = new Polygon(fPoly.xpoints, fPoly.ypoints, n);\n        changed();\n    }\n\n    /**\n     * Splits the segment at the given point if a segment was hit.\n     * @return the index of the segment or -1 if no segment was hit.\n     */\n    public int splitSegment(int x, int y) {\n        double dist = TOO_CLOSE;\n        int best = -1;\n        for (int i1 = 0; i1 < fPoly.npoints; i1++) {\n            int n = (i1 + 1) % fPoly.npoints;\n            double d = distanceFromLine(fPoly.xpoints[i1], fPoly.ypoints[i1], fPoly.xpoints[n], fPoly.ypoints[n], x, y);\n            if (d < dist) {\n                dist = d;\n                best = i1;\n            }\n        }\n        int i = best;\n        if (i != -1) {\n            insertPointAt(new Point(x, y), i + 1);\n            return i + 1;\n        } else\n            return -1;\n    }\n\n    public Point pointAt(int i) {\n        return new Point(fPoly.xpoints[i], fPoly.ypoints[i]);\n    }\n\n    /**\n     * Return the point on the polygon that is furthest from the center\n     */\n    public Point outermostPoint() {\n        Point ctr = center();\n        int outer = 0;\n        long dist = 0;\n        for (int i = 0; i < fPoly.npoints; ++i) {\n            long d = Geom.length2(ctr.x, ctr.y, fPoly.xpoints[i], fPoly.ypoints[i]);\n            if (d > dist) {\n                dist = d;\n                outer = i;\n            }\n        }\n        return new Point(fPoly.xpoints[outer], fPoly.ypoints[outer]);\n    }\n\n    /**\n     * Gets the segment that is hit by the given point.\n     * @return the index of the segment or -1 if no segment was hit.\n     */\n    public int findSegment(int x, int y) {\n        double dist = TOO_CLOSE;\n        int best = -1;\n        for (int i = 0; i < fPoly.npoints; i++) {\n            int n = (i + 1) % fPoly.npoints;\n            double d = distanceFromLine(fPoly.xpoints[i], fPoly.ypoints[i], fPoly.xpoints[n], fPoly.ypoints[n], x, y);\n            if (d < dist) {\n                dist = d;\n                best = i;\n            }\n        }\n        return best;\n    }\n\n    public Point chop(Point p) {\n        return chop(fPoly, p);\n    }\n\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; ++i) {\n            dw.writeInt(fPoly.xpoints[i]);\n            dw.writeInt(fPoly.ypoints[i]);\n        }\n    }\n\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        int size = dr.readInt();\n        int[] xs = new int[size];\n        int[] ys = new int[size];\n        for (int i = 0; i < size; i++) {\n            xs[i] = dr.readInt();\n            ys[i] = dr.readInt();\n        }\n        fPoly = new Polygon(xs, ys, size);\n    }\n\n    /**\n     * Creates a locator for the point with the given index.\n     */\n    public static Locator locator(final int pointIndex) {\n        return new AbstractLocator() {\n\n            public Point locate(Figure owner) {\n                PolygonFigure plf = (PolygonFigure) owner;\n                // guard against changing PolygonFigures -> temporary hack\n                if (pointIndex < plf.pointCount())\n                    return ((PolygonFigure) owner).pointAt(pointIndex);\n                return new Point(-1, -1);\n            }\n        };\n    }\n\n    /**\n     * compute distance of point from line segment, or\n     * Double.MAX_VALUE if perpendicular projection is outside segment; or\n     * If pts on line are same, return distance from point\n     */\n    public static double distanceFromLine(int xa, int ya, int xb, int yb, int xc, int yc) {\n        // source:http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html#q7\n        // Let the point be C (XC,YC) and the line be AB (XA,YA) to (XB,YB).\n        // The length of the\n        // line segment AB is L:\n        // \n        // ___________________\n        // |        2         2\n        // L = \\| (XB-XA) + (YB-YA)\n        // and\n        // \n        // (YA-YC)(YA-YB)-(XA-XC)(XB-XA)\n        // r = -----------------------------\n        // L**2\n        // \n        // (YA-YC)(XB-XA)-(XA-XC)(YB-YA)\n        // s = -----------------------------\n        // L**2\n        // \n        // Let I be the point of perpendicular projection of C onto AB, the\n        // \n        // XI=XA+r(XB-XA)\n        // YI=YA+r(YB-YA)\n        // \n        // Distance from A to I = r*L\n        // Distance from C to I = s*L\n        // \n        // If r < 0 I is on backward extension of AB\n        // If r>1 I is on ahead extension of AB\n        // If 0<=r<=1 I is on AB\n        // \n        // If s < 0 C is left of AB (you can just check the numerator)\n        // If s>0 C is right of AB\n        // If s=0 C is on AB\n        int xdiff = xb - xa;\n        int ydiff = yb - ya;\n        long l2 = xdiff * xdiff + ydiff * ydiff;\n        if (l2 == 0)\n            return Geom.length(xa, ya, xc, yc);\n        double rnum = (ya - yc) * (ya - yb) - (xa - xc) * (xb - xa);\n        double r = rnum / l2;\n        if (r < 0.0 || r > 1.0)\n            return Double.MAX_VALUE;\n        double xi = xa + r * xdiff;\n        double yi = ya + r * ydiff;\n        double xd = xc - xi;\n        double yd = yc - yi;\n        return Math.sqrt(xd * xd + yd * yd);\n        /*\n      for directional version, instead use\n      double snum =  (ya-yc) * (xb-xa) - (xa-xc) * (yb-ya);\n      double s = snum / l2;\n\n      double l = Math.sqrt((double)l2);\n      return = s * l;\n      */\n    }\n\n    /**\n     * replacement for builtin Polygon.getBounds that doesn't always update?\n     */\n    public static Rectangle bounds(Polygon p) {\n        int minx = Integer.MAX_VALUE;\n        int miny = Integer.MAX_VALUE;\n        int maxx = Integer.MIN_VALUE;\n        int maxy = Integer.MIN_VALUE;\n        int n = p.npoints;\n        for (int i = 0; i < n; i++) {\n            int x = p.xpoints[i];\n            int y = p.ypoints[i];\n            if (x > maxx)\n                maxx = x;\n            if (x < minx)\n                minx = x;\n            if (y > maxy)\n                maxy = y;\n            if (y < miny)\n                miny = y;\n        }\n        return new Rectangle(minx, miny, maxx - minx, maxy - miny);\n    }\n\n    public static Point center(Polygon p) {\n        long sx = 0;\n        long sy = 0;\n        int n = p.npoints;\n        for (int i = 0; i < n; i++) {\n            sx += p.xpoints[i];\n            sy += p.ypoints[i];\n        }\n        return new Point((int) (sx / n), (int) (sy / n));\n    }\n\n    public static Point chop(Polygon poly, Point p) {\n        long sx = 0;\n        long sy = 0;\n        int n = poly.npoints;\n        for (int i1 = 0; i1 < n; i1++) {\n            sx += poly.xpoints[i1];\n            sy += poly.ypoints[i1];\n        }\n        Point ctr = new Point((int) (sx / n), (int) (sy / n));\n        int cx = -1;\n        int cy = -1;\n        long len = Long.MAX_VALUE;\n        // Try for points along edge\n        for (int i = 0; i < poly.npoints; ++i) {\n            int nxt = (i + 1) % poly.npoints;\n            Point chop = Geom.intersect(poly.xpoints[i], poly.ypoints[i], poly.xpoints[nxt], poly.ypoints[nxt], p.x, p.y, ctr.x, ctr.y);\n            if (chop != null) {\n                long cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n                if (cl < len) {\n                    len = cl;\n                    cx = chop.x;\n                    cy = chop.y;\n                }\n            }\n        }\n        // if none found, pick closest vertex\n        // if (len ==  Long.MAX_VALUE) {\n        {\n            // try anyway\n            for (int i = 0; i < poly.npoints; ++i) {\n                long l = Geom.length2(poly.xpoints[i], poly.ypoints[i], p.x, p.y);\n                if (l < len) {\n                    len = l;\n                    cx = poly.xpoints[i];\n                    cy = poly.ypoints[i];\n                }\n            }\n        }\n        return new Point(cx, cy);\n    }\n}\n",
  "classDeclarationCode": "/**\n * A scalable, rotatable polygon with an arbitrary number of points\n */\npublic class PolygonFigure extends AttributeFigure {\n\n    /**\n     * Distance threshold for smoothing away or locating points\n     */\n    static final int TOO_CLOSE = 2;\n\n    /*\n   * Serialization support.\n   */\n    private static final long serialVersionUID = 6254089689239215026L;\n\n    private int polygonFigureSerializedDataVersion = 1;\n\n    protected Polygon fPoly = new Polygon();\n\n    public PolygonFigure() {\n        super();\n    }\n\n    public PolygonFigure(int x, int y) {\n        fPoly.addPoint(x, y);\n    }\n\n    public PolygonFigure(Polygon p) {\n        fPoly = new Polygon(p.xpoints, p.ypoints, p.npoints);\n    }\n\n    public Rectangle displayBox() {\n        return bounds(fPoly);\n    }\n\n    public boolean isEmpty() {\n        return (fPoly.npoints < 3 || (size().width < TOO_CLOSE) && (size().height < TOO_CLOSE));\n    }\n\n    public Vector handles() {\n        Vector handles = new Vector(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; i++) handles.addElement(new PolygonHandle(this, locator(i), i));\n        handles.addElement(new PolygonScaleHandle(this));\n        // handles.addElement(new PolygonPointAddHandle(this));\n        return handles;\n    }\n\n    public void basicDisplayBox(Point origin, Point corner) {\n        Rectangle r = displayBox();\n        int dx = origin.x - r.x;\n        int dy = origin.y - r.y;\n        fPoly.translate(dx, dy);\n        r = displayBox();\n        Point oldCorner = new Point(r.x + r.width, r.y + r.height);\n        Polygon p = getPolygon();\n        scaleRotate(oldCorner, p, corner);\n    }\n\n    /**\n     * return a copy of the raw polygon\n     */\n    public Polygon getPolygon() {\n        return new Polygon(fPoly.xpoints, fPoly.ypoints, fPoly.npoints);\n    }\n\n    public Point center() {\n        return center(fPoly);\n    }\n\n    public Enumeration points() {\n        Vector pts = new Vector(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; ++i) pts.addElement(new Point(fPoly.xpoints[i], fPoly.ypoints[i]));\n        return pts.elements();\n    }\n\n    public int pointCount() {\n        return fPoly.npoints;\n    }\n\n    public void basicMoveBy(int dx, int dy) {\n        fPoly.translate(dx, dy);\n    }\n\n    public void drawBackground(Graphics g) {\n        g.fillPolygon(fPoly);\n    }\n\n    public void drawFrame(Graphics g) {\n        g.drawPolygon(fPoly);\n    }\n\n    public boolean containsPoint(int x, int y) {\n        return fPoly.contains(x, y);\n    }\n\n    public Connector connectorAt(int x, int y) {\n        return new ChopPolygonConnector(this);\n    }\n\n    /**\n     * Adds a node to the list of points.\n     */\n    public void addPoint(int x, int y) {\n        fPoly.addPoint(x, y);\n        changed();\n    }\n\n    /**\n     * Changes the position of a node.\n     */\n    public void setPointAt(Point p, int i) {\n        willChange();\n        fPoly.xpoints[i] = p.x;\n        fPoly.ypoints[i] = p.y;\n        changed();\n    }\n\n    /**\n     * Insert a node at the given point.\n     */\n    public void insertPointAt(Point p, int i) {\n        willChange();\n        int n = fPoly.npoints + 1;\n        int[] xs = new int[n];\n        int[] ys = new int[n];\n        for (int j = 0; j < i; ++j) {\n            xs[j] = fPoly.xpoints[j];\n            ys[j] = fPoly.ypoints[j];\n        }\n        xs[i] = p.x;\n        ys[i] = p.y;\n        for (int j = i; j < fPoly.npoints; ++j) {\n            xs[j + 1] = fPoly.xpoints[j];\n            ys[j + 1] = fPoly.ypoints[j];\n        }\n        fPoly = new Polygon(xs, ys, n);\n        changed();\n    }\n\n    public void removePointAt(int i) {\n        willChange();\n        int n = fPoly.npoints - 1;\n        int[] xs = new int[n];\n        int[] ys = new int[n];\n        for (int j = 0; j < i; ++j) {\n            xs[j] = fPoly.xpoints[j];\n            ys[j] = fPoly.ypoints[j];\n        }\n        for (int j = i; j < n; ++j) {\n            xs[j] = fPoly.xpoints[j + 1];\n            ys[j] = fPoly.ypoints[j + 1];\n        }\n        fPoly = new Polygon(xs, ys, n);\n        changed();\n    }\n\n    /**\n     * Scale and rotate relative to anchor\n     */\n    public void scaleRotate(Point anchor, Polygon originalPolygon, Point p) {\n        willChange();\n        long sx = 0;\n        long sy = 0;\n        int n1 = originalPolygon.npoints;\n        for (int i1 = 0; i1 < n1; i1++) {\n            sx += originalPolygon.xpoints[i1];\n            sy += originalPolygon.ypoints[i1];\n        }\n        // use center to determine relative angles and lengths\n        Point ctr = new Point((int) (sx / n1), (int) (sy / n1));\n        double anchorLen = Geom.length(ctr.x, ctr.y, anchor.x, anchor.y);\n        if (anchorLen > 0.0) {\n            double newLen = Geom.length(ctr.x, ctr.y, p.x, p.y);\n            double ratio = newLen / anchorLen;\n            double anchorAngle = Math.atan2(anchor.y - ctr.y, anchor.x - ctr.x);\n            double newAngle = Math.atan2(p.y - ctr.y, p.x - ctr.x);\n            double rotation = newAngle - anchorAngle;\n            int n = originalPolygon.npoints;\n            int[] xs = new int[n];\n            int[] ys = new int[n];\n            for (int i = 0; i < n; ++i) {\n                int x = originalPolygon.xpoints[i];\n                int y = originalPolygon.ypoints[i];\n                double l = Geom.length(ctr.x, ctr.y, x, y) * ratio;\n                double a = Math.atan2(y - ctr.y, x - ctr.x) + rotation;\n                xs[i] = (int) (ctr.x + l * Math.cos(a) + 0.5);\n                ys[i] = (int) (ctr.y + l * Math.sin(a) + 0.5);\n            }\n            fPoly = new Polygon(xs, ys, n);\n        }\n        changed();\n    }\n\n    /**\n     * Remove points that are nearly colinear with others\n     */\n    public void smoothPoints() {\n        willChange();\n        boolean removed = false;\n        int n = fPoly.npoints;\n        do {\n            removed = false;\n            int i = 0;\n            while (i < n && n >= 3) {\n                int nxt = (i + 1) % n;\n                int prv = (i - 1 + n) % n;\n                if ((distanceFromLine(fPoly.xpoints[prv], fPoly.ypoints[prv], fPoly.xpoints[nxt], fPoly.ypoints[nxt], fPoly.xpoints[i], fPoly.ypoints[i]) < TOO_CLOSE)) {\n                    removed = true;\n                    --n;\n                    for (int j = i; j < n; ++j) {\n                        fPoly.xpoints[j] = fPoly.xpoints[j + 1];\n                        fPoly.ypoints[j] = fPoly.ypoints[j + 1];\n                    }\n                } else\n                    ++i;\n            }\n        } while (removed);\n        if (n != fPoly.npoints)\n            fPoly = new Polygon(fPoly.xpoints, fPoly.ypoints, n);\n        changed();\n    }\n\n    /**\n     * Splits the segment at the given point if a segment was hit.\n     * @return the index of the segment or -1 if no segment was hit.\n     */\n    public int splitSegment(int x, int y) {\n        double dist = TOO_CLOSE;\n        int best = -1;\n        for (int i1 = 0; i1 < fPoly.npoints; i1++) {\n            int n = (i1 + 1) % fPoly.npoints;\n            double d = distanceFromLine(fPoly.xpoints[i1], fPoly.ypoints[i1], fPoly.xpoints[n], fPoly.ypoints[n], x, y);\n            if (d < dist) {\n                dist = d;\n                best = i1;\n            }\n        }\n        int i = best;\n        if (i != -1) {\n            insertPointAt(new Point(x, y), i + 1);\n            return i + 1;\n        } else\n            return -1;\n    }\n\n    public Point pointAt(int i) {\n        return new Point(fPoly.xpoints[i], fPoly.ypoints[i]);\n    }\n\n    /**\n     * Return the point on the polygon that is furthest from the center\n     */\n    public Point outermostPoint() {\n        Point ctr = center();\n        int outer = 0;\n        long dist = 0;\n        for (int i = 0; i < fPoly.npoints; ++i) {\n            long d = Geom.length2(ctr.x, ctr.y, fPoly.xpoints[i], fPoly.ypoints[i]);\n            if (d > dist) {\n                dist = d;\n                outer = i;\n            }\n        }\n        return new Point(fPoly.xpoints[outer], fPoly.ypoints[outer]);\n    }\n\n    /**\n     * Gets the segment that is hit by the given point.\n     * @return the index of the segment or -1 if no segment was hit.\n     */\n    public int findSegment(int x, int y) {\n        double dist = TOO_CLOSE;\n        int best = -1;\n        for (int i = 0; i < fPoly.npoints; i++) {\n            int n = (i + 1) % fPoly.npoints;\n            double d = distanceFromLine(fPoly.xpoints[i], fPoly.ypoints[i], fPoly.xpoints[n], fPoly.ypoints[n], x, y);\n            if (d < dist) {\n                dist = d;\n                best = i;\n            }\n        }\n        return best;\n    }\n\n    public Point chop(Point p) {\n        return chop(fPoly, p);\n    }\n\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fPoly.npoints);\n        for (int i = 0; i < fPoly.npoints; ++i) {\n            dw.writeInt(fPoly.xpoints[i]);\n            dw.writeInt(fPoly.ypoints[i]);\n        }\n    }\n\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        int size = dr.readInt();\n        int[] xs = new int[size];\n        int[] ys = new int[size];\n        for (int i = 0; i < size; i++) {\n            xs[i] = dr.readInt();\n            ys[i] = dr.readInt();\n        }\n        fPoly = new Polygon(xs, ys, size);\n    }\n\n    /**\n     * Creates a locator for the point with the given index.\n     */\n    public static Locator locator(final int pointIndex) {\n        return new AbstractLocator() {\n\n            public Point locate(Figure owner) {\n                PolygonFigure plf = (PolygonFigure) owner;\n                // guard against changing PolygonFigures -> temporary hack\n                if (pointIndex < plf.pointCount())\n                    return ((PolygonFigure) owner).pointAt(pointIndex);\n                return new Point(-1, -1);\n            }\n        };\n    }\n\n    /**\n     * compute distance of point from line segment, or\n     * Double.MAX_VALUE if perpendicular projection is outside segment; or\n     * If pts on line are same, return distance from point\n     */\n    public static double distanceFromLine(int xa, int ya, int xb, int yb, int xc, int yc) {\n        // source:http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html#q7\n        // Let the point be C (XC,YC) and the line be AB (XA,YA) to (XB,YB).\n        // The length of the\n        // line segment AB is L:\n        // \n        // ___________________\n        // |        2         2\n        // L = \\| (XB-XA) + (YB-YA)\n        // and\n        // \n        // (YA-YC)(YA-YB)-(XA-XC)(XB-XA)\n        // r = -----------------------------\n        // L**2\n        // \n        // (YA-YC)(XB-XA)-(XA-XC)(YB-YA)\n        // s = -----------------------------\n        // L**2\n        // \n        // Let I be the point of perpendicular projection of C onto AB, the\n        // \n        // XI=XA+r(XB-XA)\n        // YI=YA+r(YB-YA)\n        // \n        // Distance from A to I = r*L\n        // Distance from C to I = s*L\n        // \n        // If r < 0 I is on backward extension of AB\n        // If r>1 I is on ahead extension of AB\n        // If 0<=r<=1 I is on AB\n        // \n        // If s < 0 C is left of AB (you can just check the numerator)\n        // If s>0 C is right of AB\n        // If s=0 C is on AB\n        int xdiff = xb - xa;\n        int ydiff = yb - ya;\n        long l2 = xdiff * xdiff + ydiff * ydiff;\n        if (l2 == 0)\n            return Geom.length(xa, ya, xc, yc);\n        double rnum = (ya - yc) * (ya - yb) - (xa - xc) * (xb - xa);\n        double r = rnum / l2;\n        if (r < 0.0 || r > 1.0)\n            return Double.MAX_VALUE;\n        double xi = xa + r * xdiff;\n        double yi = ya + r * ydiff;\n        double xd = xc - xi;\n        double yd = yc - yi;\n        return Math.sqrt(xd * xd + yd * yd);\n        /*\n      for directional version, instead use\n      double snum =  (ya-yc) * (xb-xa) - (xa-xc) * (yb-ya);\n      double s = snum / l2;\n\n      double l = Math.sqrt((double)l2);\n      return = s * l;\n      */\n    }\n\n    /**\n     * replacement for builtin Polygon.getBounds that doesn't always update?\n     */\n    public static Rectangle bounds(Polygon p) {\n        int minx = Integer.MAX_VALUE;\n        int miny = Integer.MAX_VALUE;\n        int maxx = Integer.MIN_VALUE;\n        int maxy = Integer.MIN_VALUE;\n        int n = p.npoints;\n        for (int i = 0; i < n; i++) {\n            int x = p.xpoints[i];\n            int y = p.ypoints[i];\n            if (x > maxx)\n                maxx = x;\n            if (x < minx)\n                minx = x;\n            if (y > maxy)\n                maxy = y;\n            if (y < miny)\n                miny = y;\n        }\n        return new Rectangle(minx, miny, maxx - minx, maxy - miny);\n    }\n\n    public static Point center(Polygon p) {\n        long sx = 0;\n        long sy = 0;\n        int n = p.npoints;\n        for (int i = 0; i < n; i++) {\n            sx += p.xpoints[i];\n            sy += p.ypoints[i];\n        }\n        return new Point((int) (sx / n), (int) (sy / n));\n    }\n\n    public static Point chop(Polygon poly, Point p) {\n        long sx = 0;\n        long sy = 0;\n        int n = poly.npoints;\n        for (int i1 = 0; i1 < n; i1++) {\n            sx += poly.xpoints[i1];\n            sy += poly.ypoints[i1];\n        }\n        Point ctr = new Point((int) (sx / n), (int) (sy / n));\n        int cx = -1;\n        int cy = -1;\n        long len = Long.MAX_VALUE;\n        // Try for points along edge\n        for (int i = 0; i < poly.npoints; ++i) {\n            int nxt = (i + 1) % poly.npoints;\n            Point chop = Geom.intersect(poly.xpoints[i], poly.ypoints[i], poly.xpoints[nxt], poly.ypoints[nxt], p.x, p.y, ctr.x, ctr.y);\n            if (chop != null) {\n                long cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n                if (cl < len) {\n                    len = cl;\n                    cx = chop.x;\n                    cy = chop.y;\n                }\n            }\n        }\n        // if none found, pick closest vertex\n        // if (len ==  Long.MAX_VALUE) {\n        {\n            // try anyway\n            for (int i = 0; i < poly.npoints; ++i) {\n                long l = Geom.length2(poly.xpoints[i], poly.ypoints[i], p.x, p.y);\n                if (l < len) {\n                    len = l;\n                    cx = poly.xpoints[i];\n                    cy = poly.ypoints[i];\n                }\n            }\n        }\n        return new Point(cx, cy);\n    }\n}",
  "subClasses": []
}