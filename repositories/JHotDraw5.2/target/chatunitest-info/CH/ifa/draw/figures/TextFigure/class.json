{
  "fullClassName": "CH.ifa.draw.figures.TextFigure",
  "className": "TextFigure",
  "index": 52,
  "modifier": "[public ]",
  "extend": "[AttributeFigure]",
  "implement": "[FigureChangeListener, TextHolder]",
  "packageName": "CH.ifa.draw.figures",
  "packageDeclaration": "package CH.ifa.draw.figures;",
  "classSignature": "public  class TextFigure",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.util.*;",
    "import java.awt.*;",
    "import java.io.*;",
    "import CH.ifa.draw.framework.*;",
    "import CH.ifa.draw.standard.*;",
    "import CH.ifa.draw.util.*;"
  ],
  "fields": [
    "private int               fOriginX;",
    "private int               fOriginY;",
    "transient private boolean fSizeIsDirty = true;",
    "transient private int     fWidth;",
    "transient private int     fHeight;",
    "private String  fText;",
    "private Font    fFont;",
    "private boolean fIsReadOnly;",
    "private Figure  fObservedFigure = null;",
    "private OffsetLocator fLocator = null;",
    "private static String fgCurrentFontName  = \"Helvetica\";",
    "private static int    fgCurrentFontSize  = 12;",
    "private static int    fgCurrentFontStyle = Font.PLAIN;",
    "private static final long serialVersionUID = 4599820785949456124L;",
    "private int textFigureSerializedDataVersion = 1;"
  ],
  "superClasses": [
    "AttributeFigure"
  ],
  "implementedTypes": [
    "FigureChangeListener",
    "TextHolder"
  ],
  "methodSigs": {
    "moveBy(int, int)": "0",
    "basicMoveBy(int, int)": "1",
    "basicDisplayBox(Point, Point)": "2",
    "displayBox()": "3",
    "textDisplayBox()": "4",
    "readOnly()": "5",
    "setReadOnly(boolean)": "6",
    "getFont()": "7",
    "setFont(Font)": "8",
    "changed()": "9",
    "getAttribute(String)": "10",
    "setAttribute(String, Object)": "11",
    "getText()": "12",
    "setText(String)": "13",
    "acceptsTyping()": "14",
    "drawBackground(Graphics)": "15",
    "drawFrame(Graphics)": "16",
    "textExtent()": "17",
    "markDirty()": "18",
    "overlayColumns()": "19",
    "handles()": "20",
    "write(StorableOutput)": "21",
    "read(StorableInput)": "22",
    "readObject(ObjectInputStream)": "23",
    "connect(Figure)": "24",
    "figureChanged(FigureChangeEvent)": "25",
    "figureRemoved(FigureChangeEvent)": "26",
    "figureRequestRemove(FigureChangeEvent)": "27",
    "figureInvalidated(FigureChangeEvent)": "28",
    "figureRequestUpdate(FigureChangeEvent)": "29",
    "updateLocation()": "30",
    "release()": "31",
    "disconnect()": "32",
    "createCurrentFont()": "33",
    "setCurrentFontName(String)": "34",
    "setCurrentFontSize(int)": "35",
    "setCurrentFontStyle(int)": "36",
    "TextFigure()": "37"
  },
  "methodsBrief": [
    "public void moveBy(int x, int y){}",
    "protected void basicMoveBy(int x, int y){}",
    "public void basicDisplayBox(Point newOrigin, Point newCorner){}",
    "public Rectangle displayBox(){}",
    "public Rectangle textDisplayBox(){}",
    "public boolean readOnly(){}",
    "public void setReadOnly(boolean isReadOnly){}",
    "public Font getFont(){}",
    "public void setFont(Font newFont){}",
    "public void changed(){}",
    "public Object getAttribute(String name){}",
    "public void setAttribute(String name, Object value){}",
    "public String getText(){}",
    "public void setText(String newText){}",
    "public boolean acceptsTyping(){}",
    "public void drawBackground(Graphics g){}",
    "public void drawFrame(Graphics g){}",
    "private Dimension textExtent(){}",
    "private void markDirty(){}",
    "public int overlayColumns(){}",
    "public Vector handles(){}",
    "public void write(StorableOutput dw){}",
    "public void read(StorableInput dr) throws IOException{}",
    "private void readObject(ObjectInputStream s)\r\n        throws ClassNotFoundException, IOException{}",
    "public void connect(Figure figure){}",
    "public void figureChanged(FigureChangeEvent e){}",
    "public void figureRemoved(FigureChangeEvent e){}",
    "public void figureRequestRemove(FigureChangeEvent e){}",
    "public void figureInvalidated(FigureChangeEvent e){}",
    "public void figureRequestUpdate(FigureChangeEvent e){}",
    "protected void updateLocation(){}",
    "public void release(){}",
    "public void disconnect(){}",
    "static public Font createCurrentFont(){}",
    "static public void setCurrentFontName(String name){}",
    "static public void setCurrentFontSize(int size){}",
    "static public void setCurrentFontStyle(int style){}",
    "public TextFigure(){}"
  ],
  "constructorSigs": [
    "TextFigure()"
  ],
  "constructorBrief": [
    "public TextFigure(){}"
  ],
  "getterSetterSigs": [
    "setReadOnly(boolean)",
    "getFont()",
    "setFont(Font)",
    "setAttribute(String, Object)",
    "getText()",
    "setText(String)",
    "setCurrentFontName(String)",
    "setCurrentFontSize(int)",
    "setCurrentFontStyle(int)"
  ],
  "getterSetterBrief": [
    "public void setReadOnly(boolean isReadOnly){}",
    "public Font getFont(){}",
    "public void setFont(Font newFont){}",
    "public void setAttribute(String name, Object value){}",
    "public String getText(){}",
    "public void setText(String newText){}",
    "static public void setCurrentFontName(String name){}",
    "static public void setCurrentFontSize(int size){}",
    "static public void setCurrentFontStyle(int style){}"
  ],
  "constructorDeps": {
    "CH.ifa.draw.figures.TextFigure": [
      "createCurrentFont()",
      "setAttribute(String, Object)"
    ],
    "CH.ifa.draw.util.ColorMap": [
      "color(String)"
    ]
  },
  "compilationUnitCode": "/*\n * @(#)TextFigure.java 5.2\n *\n */\npackage CH.ifa.draw.figures;\n\nimport java.util.*;\nimport java.awt.*;\nimport java.io.*;\nimport CH.ifa.draw.framework.*;\nimport CH.ifa.draw.standard.*;\nimport CH.ifa.draw.util.*;\n\n/**\n * A text figure.\n *\n * @see TextTool\n */\npublic class TextFigure extends AttributeFigure implements FigureChangeListener, TextHolder {\n\n    private int fOriginX;\n\n    private int fOriginY;\n\n    // cache of the TextFigure's size\n    transient private boolean fSizeIsDirty = true;\n\n    transient private int fWidth;\n\n    transient private int fHeight;\n\n    private String fText;\n\n    private Font fFont;\n\n    private boolean fIsReadOnly;\n\n    private Figure fObservedFigure = null;\n\n    private OffsetLocator fLocator = null;\n\n    private static String fgCurrentFontName = \"Helvetica\";\n\n    private static int fgCurrentFontSize = 12;\n\n    private static int fgCurrentFontStyle = Font.PLAIN;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = 4599820785949456124L;\n\n    private int textFigureSerializedDataVersion = 1;\n\n    public TextFigure() {\n        fOriginX = 0;\n        fOriginY = 0;\n        fFont = createCurrentFont();\n        setAttribute(\"FillColor\", ColorMap.color(\"None\"));\n        fText = new String(\"\");\n        fSizeIsDirty = true;\n    }\n\n    public void moveBy(int x, int y) {\n        willChange();\n        basicMoveBy(x, y);\n        if (fLocator != null)\n            fLocator.moveBy(x, y);\n        changed();\n    }\n\n    protected void basicMoveBy(int x, int y) {\n        fOriginX += x;\n        fOriginY += y;\n    }\n\n    public void basicDisplayBox(Point newOrigin, Point newCorner) {\n        fOriginX = newOrigin.x;\n        fOriginY = newOrigin.y;\n    }\n\n    public Rectangle displayBox() {\n        Dimension extent = textExtent();\n        return new Rectangle(fOriginX, fOriginY, extent.width, extent.height);\n    }\n\n    public Rectangle textDisplayBox() {\n        return displayBox();\n    }\n\n    /**\n     * Tests whether this figure is read only.\n     */\n    public boolean readOnly() {\n        return fIsReadOnly;\n    }\n\n    /**\n     * Sets the read only status of the text figure.\n     */\n    public void setReadOnly(boolean isReadOnly) {\n        fIsReadOnly = isReadOnly;\n    }\n\n    /**\n     * Gets the font.\n     */\n    public Font getFont() {\n        return fFont;\n    }\n\n    /**\n     * Sets the font.\n     */\n    public void setFont(Font newFont) {\n        willChange();\n        fFont = newFont;\n        markDirty();\n        changed();\n    }\n\n    /**\n     * Updates the location whenever the figure changes itself.\n     */\n    public void changed() {\n        super.changed();\n        updateLocation();\n    }\n\n    /**\n     * A text figure understands the \"FontSize\", \"FontStyle\", and \"FontName\"\n     * attributes.\n     */\n    public Object getAttribute(String name) {\n        Font font = getFont();\n        if (name.equals(\"FontSize\"))\n            return new Integer(font.getSize());\n        if (name.equals(\"FontStyle\"))\n            return new Integer(font.getStyle());\n        if (name.equals(\"FontName\"))\n            return font.getName();\n        return super.getAttribute(name);\n    }\n\n    /**\n     * A text figure understands the \"FontSize\", \"FontStyle\", and \"FontName\"\n     * attributes.\n     */\n    public void setAttribute(String name, Object value) {\n        Font font = getFont();\n        if (name.equals(\"FontSize\")) {\n            Integer s = (Integer) value;\n            willChange();\n            fFont = new Font(font.getName(), font.getStyle(), s.intValue());\n            markDirty();\n            changed();\n        } else if (name.equals(\"FontStyle\")) {\n            Integer s = (Integer) value;\n            int style = font.getStyle();\n            if (s.intValue() == Font.PLAIN)\n                style = font.PLAIN;\n            else\n                style = style ^ s.intValue();\n            setFont(new Font(font.getName(), style, font.getSize()));\n        } else if (name.equals(\"FontName\")) {\n            String n = (String) value;\n            setFont(new Font(n, font.getStyle(), font.getSize()));\n        } else\n            super.setAttribute(name, value);\n    }\n\n    /**\n     * Gets the text shown by the text figure.\n     */\n    public String getText() {\n        return fText;\n    }\n\n    /**\n     * Sets the text shown by the text figure.\n     */\n    public void setText(String newText) {\n        if (!newText.equals(fText)) {\n            willChange();\n            fText = new String(newText);\n            markDirty();\n            changed();\n        }\n    }\n\n    /**\n     * Tests whether the figure accepts typing.\n     */\n    public boolean acceptsTyping() {\n        return !fIsReadOnly;\n    }\n\n    public void drawBackground(Graphics g) {\n        Rectangle r = displayBox();\n        g.fillRect(r.x, r.y, r.width, r.height);\n    }\n\n    public void drawFrame(Graphics g) {\n        g.setFont(fFont);\n        g.setColor((Color) getAttribute(\"TextColor\"));\n        FontMetrics metrics = g.getFontMetrics(fFont);\n        g.drawString(fText, fOriginX, fOriginY + metrics.getAscent());\n    }\n\n    private Dimension textExtent() {\n        if (!fSizeIsDirty)\n            return new Dimension(fWidth, fHeight);\n        FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);\n        fWidth = metrics.stringWidth(fText);\n        fHeight = metrics.getHeight();\n        fSizeIsDirty = false;\n        return new Dimension(metrics.stringWidth(fText), metrics.getHeight());\n    }\n\n    private void markDirty() {\n        fSizeIsDirty = true;\n    }\n\n    /**\n     * Gets the number of columns to be overlaid when the figure is edited.\n     */\n    public int overlayColumns() {\n        int length = getText().length();\n        int columns = 20;\n        if (length != 0)\n            columns = getText().length() + 3;\n        return columns;\n    }\n\n    public Vector handles() {\n        Vector handles = new Vector();\n        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));\n        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));\n        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));\n        handles.addElement(new FontSizeHandle(this, RelativeLocator.southWest()));\n        return handles;\n    }\n\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fOriginX);\n        dw.writeInt(fOriginY);\n        dw.writeString(fText);\n        dw.writeString(fFont.getName());\n        dw.writeInt(fFont.getStyle());\n        dw.writeInt(fFont.getSize());\n        dw.writeBoolean(fIsReadOnly);\n        dw.writeStorable(fObservedFigure);\n        dw.writeStorable(fLocator);\n    }\n\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        markDirty();\n        fOriginX = dr.readInt();\n        fOriginY = dr.readInt();\n        fText = dr.readString();\n        fFont = new Font(dr.readString(), dr.readInt(), dr.readInt());\n        fIsReadOnly = dr.readBoolean();\n        fObservedFigure = (Figure) dr.readStorable();\n        if (fObservedFigure != null)\n            fObservedFigure.addFigureChangeListener(this);\n        fLocator = (OffsetLocator) dr.readStorable();\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        if (fObservedFigure != null)\n            fObservedFigure.addFigureChangeListener(this);\n        markDirty();\n    }\n\n    public void connect(Figure figure) {\n        if (fObservedFigure != null)\n            fObservedFigure.removeFigureChangeListener(this);\n        fObservedFigure = figure;\n        fLocator = new OffsetLocator(figure.connectedTextLocator(this));\n        fObservedFigure.addFigureChangeListener(this);\n        if (fLocator != null) {\n            Point p = fLocator.locate(fObservedFigure);\n            p.x -= size().width / 2 + fOriginX;\n            p.y -= size().height / 2 + fOriginY;\n            if (p.x != 0 || p.y != 0) {\n                willChange();\n                basicMoveBy(p.x, p.y);\n                changed();\n            }\n        }\n    }\n\n    public void figureChanged(FigureChangeEvent e) {\n        updateLocation();\n    }\n\n    public void figureRemoved(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestRemove(new FigureChangeEvent(this));\n    }\n\n    public void figureRequestRemove(FigureChangeEvent e) {\n    }\n\n    public void figureInvalidated(FigureChangeEvent e) {\n    }\n\n    public void figureRequestUpdate(FigureChangeEvent e) {\n    }\n\n    /**\n     * Updates the location relative to the connected figure.\n     * The TextFigure is centered around the located point.\n     */\n    protected void updateLocation() {\n        if (fLocator != null) {\n            Point p = fLocator.locate(fObservedFigure);\n            p.x -= size().width / 2 + fOriginX;\n            p.y -= size().height / 2 + fOriginY;\n            if (p.x != 0 || p.y != 0) {\n                willChange();\n                basicMoveBy(p.x, p.y);\n                changed();\n            }\n        }\n    }\n\n    public void release() {\n        super.release();\n        if (fObservedFigure != null)\n            fObservedFigure.removeFigureChangeListener(this);\n    }\n\n    /**\n     * Disconnects the text figure.\n     */\n    public void disconnect() {\n        fObservedFigure.removeFigureChangeListener(this);\n        fObservedFigure = null;\n        fLocator = null;\n    }\n\n    /**\n     * Creates the current font to be used for new text figures.\n     */\n    static public Font createCurrentFont() {\n        return new Font(fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);\n    }\n\n    /**\n     * Sets the current font name\n     */\n    static public void setCurrentFontName(String name) {\n        fgCurrentFontName = name;\n    }\n\n    /**\n     * Sets the current font size.\n     */\n    static public void setCurrentFontSize(int size) {\n        fgCurrentFontSize = size;\n    }\n\n    /**\n     * Sets the current font style.\n     */\n    static public void setCurrentFontStyle(int style) {\n        fgCurrentFontStyle = style;\n    }\n}\n",
  "classDeclarationCode": "/**\n * A text figure.\n *\n * @see TextTool\n */\npublic class TextFigure extends AttributeFigure implements FigureChangeListener, TextHolder {\n\n    private int fOriginX;\n\n    private int fOriginY;\n\n    // cache of the TextFigure's size\n    transient private boolean fSizeIsDirty = true;\n\n    transient private int fWidth;\n\n    transient private int fHeight;\n\n    private String fText;\n\n    private Font fFont;\n\n    private boolean fIsReadOnly;\n\n    private Figure fObservedFigure = null;\n\n    private OffsetLocator fLocator = null;\n\n    private static String fgCurrentFontName = \"Helvetica\";\n\n    private static int fgCurrentFontSize = 12;\n\n    private static int fgCurrentFontStyle = Font.PLAIN;\n\n    /*\n     * Serialization support.\n     */\n    private static final long serialVersionUID = 4599820785949456124L;\n\n    private int textFigureSerializedDataVersion = 1;\n\n    public TextFigure() {\n        fOriginX = 0;\n        fOriginY = 0;\n        fFont = createCurrentFont();\n        setAttribute(\"FillColor\", ColorMap.color(\"None\"));\n        fText = new String(\"\");\n        fSizeIsDirty = true;\n    }\n\n    public void moveBy(int x, int y) {\n        willChange();\n        basicMoveBy(x, y);\n        if (fLocator != null)\n            fLocator.moveBy(x, y);\n        changed();\n    }\n\n    protected void basicMoveBy(int x, int y) {\n        fOriginX += x;\n        fOriginY += y;\n    }\n\n    public void basicDisplayBox(Point newOrigin, Point newCorner) {\n        fOriginX = newOrigin.x;\n        fOriginY = newOrigin.y;\n    }\n\n    public Rectangle displayBox() {\n        Dimension extent = textExtent();\n        return new Rectangle(fOriginX, fOriginY, extent.width, extent.height);\n    }\n\n    public Rectangle textDisplayBox() {\n        return displayBox();\n    }\n\n    /**\n     * Tests whether this figure is read only.\n     */\n    public boolean readOnly() {\n        return fIsReadOnly;\n    }\n\n    /**\n     * Sets the read only status of the text figure.\n     */\n    public void setReadOnly(boolean isReadOnly) {\n        fIsReadOnly = isReadOnly;\n    }\n\n    /**\n     * Gets the font.\n     */\n    public Font getFont() {\n        return fFont;\n    }\n\n    /**\n     * Sets the font.\n     */\n    public void setFont(Font newFont) {\n        willChange();\n        fFont = newFont;\n        markDirty();\n        changed();\n    }\n\n    /**\n     * Updates the location whenever the figure changes itself.\n     */\n    public void changed() {\n        super.changed();\n        updateLocation();\n    }\n\n    /**\n     * A text figure understands the \"FontSize\", \"FontStyle\", and \"FontName\"\n     * attributes.\n     */\n    public Object getAttribute(String name) {\n        Font font = getFont();\n        if (name.equals(\"FontSize\"))\n            return new Integer(font.getSize());\n        if (name.equals(\"FontStyle\"))\n            return new Integer(font.getStyle());\n        if (name.equals(\"FontName\"))\n            return font.getName();\n        return super.getAttribute(name);\n    }\n\n    /**\n     * A text figure understands the \"FontSize\", \"FontStyle\", and \"FontName\"\n     * attributes.\n     */\n    public void setAttribute(String name, Object value) {\n        Font font = getFont();\n        if (name.equals(\"FontSize\")) {\n            Integer s = (Integer) value;\n            willChange();\n            fFont = new Font(font.getName(), font.getStyle(), s.intValue());\n            markDirty();\n            changed();\n        } else if (name.equals(\"FontStyle\")) {\n            Integer s = (Integer) value;\n            int style = font.getStyle();\n            if (s.intValue() == Font.PLAIN)\n                style = font.PLAIN;\n            else\n                style = style ^ s.intValue();\n            setFont(new Font(font.getName(), style, font.getSize()));\n        } else if (name.equals(\"FontName\")) {\n            String n = (String) value;\n            setFont(new Font(n, font.getStyle(), font.getSize()));\n        } else\n            super.setAttribute(name, value);\n    }\n\n    /**\n     * Gets the text shown by the text figure.\n     */\n    public String getText() {\n        return fText;\n    }\n\n    /**\n     * Sets the text shown by the text figure.\n     */\n    public void setText(String newText) {\n        if (!newText.equals(fText)) {\n            willChange();\n            fText = new String(newText);\n            markDirty();\n            changed();\n        }\n    }\n\n    /**\n     * Tests whether the figure accepts typing.\n     */\n    public boolean acceptsTyping() {\n        return !fIsReadOnly;\n    }\n\n    public void drawBackground(Graphics g) {\n        Rectangle r = displayBox();\n        g.fillRect(r.x, r.y, r.width, r.height);\n    }\n\n    public void drawFrame(Graphics g) {\n        g.setFont(fFont);\n        g.setColor((Color) getAttribute(\"TextColor\"));\n        FontMetrics metrics = g.getFontMetrics(fFont);\n        g.drawString(fText, fOriginX, fOriginY + metrics.getAscent());\n    }\n\n    private Dimension textExtent() {\n        if (!fSizeIsDirty)\n            return new Dimension(fWidth, fHeight);\n        FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(fFont);\n        fWidth = metrics.stringWidth(fText);\n        fHeight = metrics.getHeight();\n        fSizeIsDirty = false;\n        return new Dimension(metrics.stringWidth(fText), metrics.getHeight());\n    }\n\n    private void markDirty() {\n        fSizeIsDirty = true;\n    }\n\n    /**\n     * Gets the number of columns to be overlaid when the figure is edited.\n     */\n    public int overlayColumns() {\n        int length = getText().length();\n        int columns = 20;\n        if (length != 0)\n            columns = getText().length() + 3;\n        return columns;\n    }\n\n    public Vector handles() {\n        Vector handles = new Vector();\n        handles.addElement(new NullHandle(this, RelativeLocator.northWest()));\n        handles.addElement(new NullHandle(this, RelativeLocator.northEast()));\n        handles.addElement(new NullHandle(this, RelativeLocator.southEast()));\n        handles.addElement(new FontSizeHandle(this, RelativeLocator.southWest()));\n        return handles;\n    }\n\n    public void write(StorableOutput dw) {\n        super.write(dw);\n        dw.writeInt(fOriginX);\n        dw.writeInt(fOriginY);\n        dw.writeString(fText);\n        dw.writeString(fFont.getName());\n        dw.writeInt(fFont.getStyle());\n        dw.writeInt(fFont.getSize());\n        dw.writeBoolean(fIsReadOnly);\n        dw.writeStorable(fObservedFigure);\n        dw.writeStorable(fLocator);\n    }\n\n    public void read(StorableInput dr) throws IOException {\n        super.read(dr);\n        markDirty();\n        fOriginX = dr.readInt();\n        fOriginY = dr.readInt();\n        fText = dr.readString();\n        fFont = new Font(dr.readString(), dr.readInt(), dr.readInt());\n        fIsReadOnly = dr.readBoolean();\n        fObservedFigure = (Figure) dr.readStorable();\n        if (fObservedFigure != null)\n            fObservedFigure.addFigureChangeListener(this);\n        fLocator = (OffsetLocator) dr.readStorable();\n    }\n\n    private void readObject(ObjectInputStream s) throws ClassNotFoundException, IOException {\n        s.defaultReadObject();\n        if (fObservedFigure != null)\n            fObservedFigure.addFigureChangeListener(this);\n        markDirty();\n    }\n\n    public void connect(Figure figure) {\n        if (fObservedFigure != null)\n            fObservedFigure.removeFigureChangeListener(this);\n        fObservedFigure = figure;\n        fLocator = new OffsetLocator(figure.connectedTextLocator(this));\n        fObservedFigure.addFigureChangeListener(this);\n        if (fLocator != null) {\n            Point p = fLocator.locate(fObservedFigure);\n            p.x -= size().width / 2 + fOriginX;\n            p.y -= size().height / 2 + fOriginY;\n            if (p.x != 0 || p.y != 0) {\n                willChange();\n                basicMoveBy(p.x, p.y);\n                changed();\n            }\n        }\n    }\n\n    public void figureChanged(FigureChangeEvent e) {\n        updateLocation();\n    }\n\n    public void figureRemoved(FigureChangeEvent e) {\n        if (listener() != null)\n            listener().figureRequestRemove(new FigureChangeEvent(this));\n    }\n\n    public void figureRequestRemove(FigureChangeEvent e) {\n    }\n\n    public void figureInvalidated(FigureChangeEvent e) {\n    }\n\n    public void figureRequestUpdate(FigureChangeEvent e) {\n    }\n\n    /**\n     * Updates the location relative to the connected figure.\n     * The TextFigure is centered around the located point.\n     */\n    protected void updateLocation() {\n        if (fLocator != null) {\n            Point p = fLocator.locate(fObservedFigure);\n            p.x -= size().width / 2 + fOriginX;\n            p.y -= size().height / 2 + fOriginY;\n            if (p.x != 0 || p.y != 0) {\n                willChange();\n                basicMoveBy(p.x, p.y);\n                changed();\n            }\n        }\n    }\n\n    public void release() {\n        super.release();\n        if (fObservedFigure != null)\n            fObservedFigure.removeFigureChangeListener(this);\n    }\n\n    /**\n     * Disconnects the text figure.\n     */\n    public void disconnect() {\n        fObservedFigure.removeFigureChangeListener(this);\n        fObservedFigure = null;\n        fLocator = null;\n    }\n\n    /**\n     * Creates the current font to be used for new text figures.\n     */\n    static public Font createCurrentFont() {\n        return new Font(fgCurrentFontName, fgCurrentFontStyle, fgCurrentFontSize);\n    }\n\n    /**\n     * Sets the current font name\n     */\n    static public void setCurrentFontName(String name) {\n        fgCurrentFontName = name;\n    }\n\n    /**\n     * Sets the current font size.\n     */\n    static public void setCurrentFontSize(int size) {\n        fgCurrentFontSize = size;\n    }\n\n    /**\n     * Sets the current font style.\n     */\n    static public void setCurrentFontStyle(int style) {\n        fgCurrentFontStyle = style;\n    }\n}",
  "subClasses": [
    "CH.ifa.draw.figures.NumberTextFigure"
  ]
}