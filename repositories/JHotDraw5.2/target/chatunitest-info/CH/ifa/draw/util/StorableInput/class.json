{
  "fullClassName": "CH.ifa.draw.util.StorableInput",
  "className": "StorableInput",
  "index": 167,
  "modifier": "[public ]",
  "extend": "[Object]",
  "implement": "[]",
  "packageName": "CH.ifa.draw.util",
  "packageDeclaration": "package CH.ifa.draw.util;",
  "classSignature": "public  class StorableInput",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.util.*;",
    "import java.io.*;",
    "import java.awt.Color;"
  ],
  "fields": [
    "private StreamTokenizer fTokenizer;",
    "private Vector          fMap;"
  ],
  "superClasses": [
    "Object"
  ],
  "implementedTypes": [],
  "methodSigs": {
    "readStorable()": "0",
    "readString()": "1",
    "readInt()": "2",
    "readColor()": "3",
    "readDouble()": "4",
    "readBoolean()": "5",
    "makeInstance(String)": "6",
    "map(Storable)": "7",
    "retrieve(int)": "8",
    "StorableInput(InputStream)": "9"
  },
  "methodsBrief": [
    "public Storable readStorable() throws IOException{}",
    "public String readString() throws IOException{}",
    "public int readInt() throws IOException{}",
    "public Color readColor() throws IOException{}",
    "public double readDouble() throws IOException{}",
    "public boolean readBoolean() throws IOException{}",
    "private Object makeInstance(String className) throws IOException{}",
    "private void map(Storable storable){}",
    "private Storable retrieve(int ref){}",
    "public StorableInput(InputStream stream){}"
  ],
  "constructorSigs": [
    "StorableInput(InputStream)"
  ],
  "constructorBrief": [
    "public StorableInput(InputStream stream){}"
  ],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {
    "java.io.InputStream": [],
    "java.io.StreamTokenizer": [
      "wordChars(int, int)"
    ]
  },
  "compilationUnitCode": "/*\n * @(#)StorableInput.java 5.2\n *\n */\npackage CH.ifa.draw.util;\n\nimport java.util.*;\nimport java.io.*;\nimport java.awt.Color;\n\n/**\n * An input stream that can be used to resurrect Storable objects.\n * StorableInput preserves the object identity of the stored objects.\n *\n * @see Storable\n * @see StorableOutput\n */\npublic class StorableInput extends Object {\n\n    private StreamTokenizer fTokenizer;\n\n    private Vector fMap;\n\n    public StorableInput(InputStream stream) {\n        Reader r = new BufferedReader(new InputStreamReader(stream));\n        fTokenizer = new StreamTokenizer(r);\n        // include inner class separate in class names\n        fTokenizer.wordChars('$', '$');\n        fMap = new Vector();\n    }\n\n    /**\n     * Reads and resurrects a Storable object from the input stream.\n     */\n    public Storable readStorable() throws IOException {\n        Storable storable;\n        String s = readString();\n        if (s.equals(\"NULL\"))\n            return null;\n        if (s.equals(\"REF\")) {\n            int ref = readInt();\n            return (Storable) retrieve(ref);\n        }\n        storable = (Storable) makeInstance(s);\n        map(storable);\n        storable.read(this);\n        return storable;\n    }\n\n    /**\n     * Reads a string from the input stream.\n     */\n    public String readString() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_WORD || token == '\"') {\n            return fTokenizer.sval;\n        }\n        String msg = \"String expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads an int from the input stream.\n     */\n    public int readInt() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return (int) fTokenizer.nval;\n        String msg = \"Integer expected in line: \" + fTokenizer.lineno();\n        IOException exception = new IOException(msg);\n        exception.printStackTrace();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads a color from the input stream.\n     */\n    public Color readColor() throws IOException {\n        return new Color(readInt(), readInt(), readInt());\n    }\n\n    /**\n     * Reads a double from the input stream.\n     */\n    public double readDouble() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return fTokenizer.nval;\n        String msg = \"Double expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads a boolean from the input stream.\n     */\n    public boolean readBoolean() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return ((int) fTokenizer.nval) == 1;\n        String msg = \"Integer expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    private Object makeInstance(String className) throws IOException {\n        try {\n            Class cl = Class.forName(className);\n            return cl.newInstance();\n        } catch (NoSuchMethodError e) {\n            throw new IOException(\"Class \" + className + \" does not seem to have a no-arg constructor\");\n        } catch (ClassNotFoundException e) {\n            throw new IOException(\"No class: \" + className);\n        } catch (InstantiationException e) {\n            throw new IOException(\"Cannot instantiate: \" + className);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Class (\" + className + \") not accessible\");\n        }\n    }\n\n    private void map(Storable storable) {\n        if (!fMap.contains(storable))\n            fMap.addElement(storable);\n    }\n\n    private Storable retrieve(int ref) {\n        return (Storable) fMap.elementAt(ref);\n    }\n}\n",
  "classDeclarationCode": "/**\n * An input stream that can be used to resurrect Storable objects.\n * StorableInput preserves the object identity of the stored objects.\n *\n * @see Storable\n * @see StorableOutput\n */\npublic class StorableInput extends Object {\n\n    private StreamTokenizer fTokenizer;\n\n    private Vector fMap;\n\n    public StorableInput(InputStream stream) {\n        Reader r = new BufferedReader(new InputStreamReader(stream));\n        fTokenizer = new StreamTokenizer(r);\n        // include inner class separate in class names\n        fTokenizer.wordChars('$', '$');\n        fMap = new Vector();\n    }\n\n    /**\n     * Reads and resurrects a Storable object from the input stream.\n     */\n    public Storable readStorable() throws IOException {\n        Storable storable;\n        String s = readString();\n        if (s.equals(\"NULL\"))\n            return null;\n        if (s.equals(\"REF\")) {\n            int ref = readInt();\n            return (Storable) retrieve(ref);\n        }\n        storable = (Storable) makeInstance(s);\n        map(storable);\n        storable.read(this);\n        return storable;\n    }\n\n    /**\n     * Reads a string from the input stream.\n     */\n    public String readString() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_WORD || token == '\"') {\n            return fTokenizer.sval;\n        }\n        String msg = \"String expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads an int from the input stream.\n     */\n    public int readInt() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return (int) fTokenizer.nval;\n        String msg = \"Integer expected in line: \" + fTokenizer.lineno();\n        IOException exception = new IOException(msg);\n        exception.printStackTrace();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads a color from the input stream.\n     */\n    public Color readColor() throws IOException {\n        return new Color(readInt(), readInt(), readInt());\n    }\n\n    /**\n     * Reads a double from the input stream.\n     */\n    public double readDouble() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return fTokenizer.nval;\n        String msg = \"Double expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    /**\n     * Reads a boolean from the input stream.\n     */\n    public boolean readBoolean() throws IOException {\n        int token = fTokenizer.nextToken();\n        if (token == StreamTokenizer.TT_NUMBER)\n            return ((int) fTokenizer.nval) == 1;\n        String msg = \"Integer expected in line: \" + fTokenizer.lineno();\n        throw new IOException(msg);\n    }\n\n    private Object makeInstance(String className) throws IOException {\n        try {\n            Class cl = Class.forName(className);\n            return cl.newInstance();\n        } catch (NoSuchMethodError e) {\n            throw new IOException(\"Class \" + className + \" does not seem to have a no-arg constructor\");\n        } catch (ClassNotFoundException e) {\n            throw new IOException(\"No class: \" + className);\n        } catch (InstantiationException e) {\n            throw new IOException(\"Cannot instantiate: \" + className);\n        } catch (IllegalAccessException e) {\n            throw new IOException(\"Class (\" + className + \") not accessible\");\n        }\n    }\n\n    private void map(Storable storable) {\n        if (!fMap.contains(storable))\n            fMap.addElement(storable);\n    }\n\n    private Storable retrieve(int ref) {\n        return (Storable) fMap.elementAt(ref);\n    }\n}",
  "subClasses": []
}