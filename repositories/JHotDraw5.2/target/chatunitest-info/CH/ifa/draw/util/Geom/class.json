{
  "fullClassName": "CH.ifa.draw.util.Geom",
  "className": "Geom",
  "index": 157,
  "modifier": "[public ]",
  "extend": "[]",
  "implement": "[]",
  "packageName": "CH.ifa.draw.util",
  "packageDeclaration": "package CH.ifa.draw.util;",
  "classSignature": "public class Geom",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.awt.Rectangle;",
    "import java.awt.Point;"
  ],
  "fields": [
    "static public final int NORTH = 1;",
    "static public final int SOUTH = 2;",
    "static public final int WEST = 3;",
    "static public final int EAST = 4;"
  ],
  "superClasses": [],
  "implementedTypes": [],
  "methodSigs": {
    "lineContainsPoint(int, int, int, int, int, int)": "0",
    "direction(int, int, int, int)": "1",
    "south(Rectangle)": "2",
    "center(Rectangle)": "3",
    "west(Rectangle)": "4",
    "east(Rectangle)": "5",
    "north(Rectangle)": "6",
    "range(int, int, int)": "7",
    "length2(int, int, int, int)": "8",
    "length(int, int, int, int)": "9",
    "pointToAngle(Rectangle, Point)": "10",
    "angleToPoint(Rectangle, double)": "11",
    "polarToPoint(double, double, double)": "12",
    "ovalAngleToPoint(Rectangle, double)": "13",
    "intersect(int, int, int, int, int, int, int, int)": "14",
    "Geom()": "15"
  },
  "methodsBrief": [
    "static public boolean lineContainsPoint(int x1, int y1,\r\n                            int x2, int y2,\r\n                            int px, int py){}",
    "static public int direction(int x1, int y1, int x2, int y2){}",
    "static public Point south(Rectangle r){}",
    "static public Point center(Rectangle r){}",
    "static public Point west(Rectangle r){}",
    "static public Point east(Rectangle r){}",
    "static public Point north(Rectangle r){}",
    "static public int range(int min, int max, int value){}",
    "static public long length2(int x1, int y1, int x2, int y2){}",
    "static public long length(int x1, int y1, int x2, int y2){}",
    "static public double pointToAngle(Rectangle r, Point p){}",
    "static public Point angleToPoint(Rectangle r, double angle){}",
    "static public Point polarToPoint(double angle, double fx, double fy){}",
    "static public Point ovalAngleToPoint(Rectangle r, double angle){}",
    "static public Point intersect(int xa, // line 1 point 1 x\r\n                                int ya, // line 1 point 1 y\r\n                                int xb, // line 1 point 2 x\r\n                                int yb, // line 1 point 2 y\r\n                                int xc, // line 2 point 1 x\r\n                                int yc, // line 2 point 1 y\r\n                                int xd, // line 2 point 2 x\r\n                                int yd){}",
    "private Geom(){}"
  ],
  "constructorSigs": [
    "Geom()"
  ],
  "constructorBrief": [
    "private Geom(){}"
  ],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {},
  "compilationUnitCode": "/*\n * @(#)Geom.java 5.2\n *\n */\npackage CH.ifa.draw.util;\n\nimport java.awt.Rectangle;\nimport java.awt.Point;\n\n/**\n * Some geometric utilities.\n */\npublic class Geom {\n\n    private Geom() {\n    }\n\n    /**\n     * Tests if a point is on a line.\n     */\n    static public boolean lineContainsPoint(int x1, int y1, int x2, int y2, int px, int py) {\n        Rectangle r = new Rectangle(new Point(x1, y1));\n        r.add(x2, y2);\n        r.grow(2, 2);\n        if (!r.contains(px, py))\n            return false;\n        double a, b, x, y;\n        if (x1 == x2)\n            return (Math.abs(px - x1) < 3);\n        if (y1 == y2)\n            return (Math.abs(py - y1) < 3);\n        a = (double) (y1 - y2) / (double) (x1 - x2);\n        b = (double) y1 - a * (double) x1;\n        x = (py - b) / a;\n        y = a * px + b;\n        return (Math.min(Math.abs(x - px), Math.abs(y - py)) < 4);\n    }\n\n    static public final int NORTH = 1;\n\n    static public final int SOUTH = 2;\n\n    static public final int WEST = 3;\n\n    static public final int EAST = 4;\n\n    /**\n     * Returns the direction NORTH, SOUTH, WEST, EAST from\n     * one point to another one.\n     */\n    static public int direction(int x1, int y1, int x2, int y2) {\n        int direction = 0;\n        int vx = x2 - x1;\n        int vy = y2 - y1;\n        if (vy < vx && vx > -vy)\n            direction = EAST;\n        else if (vy > vx && vy > -vx)\n            direction = NORTH;\n        else if (vx < vy && vx < -vy)\n            direction = WEST;\n        else\n            direction = SOUTH;\n        return direction;\n    }\n\n    static public Point south(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y + r.height);\n    }\n\n    static public Point center(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y + r.height / 2);\n    }\n\n    static public Point west(Rectangle r) {\n        return new Point(r.x, r.y + r.height / 2);\n    }\n\n    static public Point east(Rectangle r) {\n        return new Point(r.x + r.width, r.y + r.height / 2);\n    }\n\n    static public Point north(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y);\n    }\n\n    /**\n     * Constains a value to the given range.\n     * @return the constrained value\n     */\n    static public int range(int min, int max, int value) {\n        if (value < min)\n            value = min;\n        if (value > max)\n            value = max;\n        return value;\n    }\n\n    /**\n     * Gets the square distance between two points.\n     */\n    static public long length2(int x1, int y1, int x2, int y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    /**\n     * Gets the distance between to points\n     */\n    static public long length(int x1, int y1, int x2, int y2) {\n        return (long) Math.sqrt(length2(x1, y1, x2, y2));\n    }\n\n    /**\n     * Gets the angle of a point relative to a rectangle.\n     */\n    static public double pointToAngle(Rectangle r, Point p) {\n        int px = p.x - (r.x + r.width / 2);\n        int py = p.y - (r.y + r.height / 2);\n        return Math.atan2(py * r.width, px * r.height);\n    }\n\n    /**\n     * Gets the point on a rectangle that corresponds to the given angle.\n     */\n    static public Point angleToPoint(Rectangle r, double angle) {\n        double si = Math.sin(angle);\n        double co = Math.cos(angle);\n        double e = 0.0001;\n        int x = 0, y = 0;\n        if (Math.abs(si) > e) {\n            x = (int) ((1.0 + co / Math.abs(si)) / 2.0 * r.width);\n            int max = r.width;\n            int value = x;\n            if (value < 0)\n                value = 0;\n            if (value > max)\n                value = max;\n            x = value;\n        } else if (co >= 0.0)\n            x = r.width;\n        if (Math.abs(co) > e) {\n            y = (int) ((1.0 + si / Math.abs(co)) / 2.0 * r.height);\n            y = range(0, r.height, y);\n        } else if (si >= 0.0)\n            y = r.height;\n        return new Point(r.x + x, r.y + y);\n    }\n\n    /**\n     * Converts a polar to a point\n     */\n    static public Point polarToPoint(double angle, double fx, double fy) {\n        double si = Math.sin(angle);\n        double co = Math.cos(angle);\n        return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));\n    }\n\n    /**\n     * Gets the point on an oval that corresponds to the given angle.\n     */\n    static public Point ovalAngleToPoint(Rectangle r, double angle) {\n        Point center = Geom.center(r);\n        Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);\n        return new Point(center.x + p.x, center.y + p.y);\n    }\n\n    /**\n     * Standard line intersection algorithm\n     * Return the point of intersection if it exists, else null\n     */\n    // from Doug Lea's PolygonFigure\n    static public // line 1 point 1 x\n    Point // line 1 point 1 x\n    intersect(// line 1 point 1 x\n    int xa, // line 1 point 1 y\n    int ya, // line 1 point 2 x\n    int xb, // line 1 point 2 y\n    int yb, // line 2 point 1 x\n    int xc, // line 2 point 1 y\n    int yc, // line 2 point 2 x\n    int xd, int yd) {\n        // line 2 point 2 y\n        // source: http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html\n        // eq: for lines AB and CD\n        // (YA-YC)(XD-XC)-(XA-XC)(YD-YC)\n        // r = -----------------------------  (eqn 1)\n        // (XB-XA)(YD-YC)-(YB-YA)(XD-XC)\n        // \n        // (YA-YC)(XB-XA)-(XA-XC)(YB-YA)\n        // s = -----------------------------  (eqn 2)\n        // (XB-XA)(YD-YC)-(YB-YA)(XD-XC)\n        // XI = XA + r(XB-XA)\n        // YI = YA + r(YB-YA)\n        double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));\n        double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));\n        if (denom == 0.0) {\n            // parallel\n            if (rnum == 0.0) {\n                // coincident; pick one end of first line\n                if ((xa < xb && (xb < xc || xb < xd)) || (xa > xb && (xb > xc || xb > xd)))\n                    return new Point(xb, yb);\n                else\n                    return new Point(xa, ya);\n            } else\n                return null;\n        }\n        double r = rnum / denom;\n        double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));\n        double s = snum / denom;\n        if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {\n            int px = (int) (xa + (xb - xa) * r);\n            int py = (int) (ya + (yb - ya) * r);\n            return new Point(px, py);\n        } else\n            return null;\n    }\n}\n",
  "classDeclarationCode": "/**\n * Some geometric utilities.\n */\npublic class Geom {\n\n    private Geom() {\n    }\n\n    /**\n     * Tests if a point is on a line.\n     */\n    static public boolean lineContainsPoint(int x1, int y1, int x2, int y2, int px, int py) {\n        Rectangle r = new Rectangle(new Point(x1, y1));\n        r.add(x2, y2);\n        r.grow(2, 2);\n        if (!r.contains(px, py))\n            return false;\n        double a, b, x, y;\n        if (x1 == x2)\n            return (Math.abs(px - x1) < 3);\n        if (y1 == y2)\n            return (Math.abs(py - y1) < 3);\n        a = (double) (y1 - y2) / (double) (x1 - x2);\n        b = (double) y1 - a * (double) x1;\n        x = (py - b) / a;\n        y = a * px + b;\n        return (Math.min(Math.abs(x - px), Math.abs(y - py)) < 4);\n    }\n\n    static public final int NORTH = 1;\n\n    static public final int SOUTH = 2;\n\n    static public final int WEST = 3;\n\n    static public final int EAST = 4;\n\n    /**\n     * Returns the direction NORTH, SOUTH, WEST, EAST from\n     * one point to another one.\n     */\n    static public int direction(int x1, int y1, int x2, int y2) {\n        int direction = 0;\n        int vx = x2 - x1;\n        int vy = y2 - y1;\n        if (vy < vx && vx > -vy)\n            direction = EAST;\n        else if (vy > vx && vy > -vx)\n            direction = NORTH;\n        else if (vx < vy && vx < -vy)\n            direction = WEST;\n        else\n            direction = SOUTH;\n        return direction;\n    }\n\n    static public Point south(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y + r.height);\n    }\n\n    static public Point center(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y + r.height / 2);\n    }\n\n    static public Point west(Rectangle r) {\n        return new Point(r.x, r.y + r.height / 2);\n    }\n\n    static public Point east(Rectangle r) {\n        return new Point(r.x + r.width, r.y + r.height / 2);\n    }\n\n    static public Point north(Rectangle r) {\n        return new Point(r.x + r.width / 2, r.y);\n    }\n\n    /**\n     * Constains a value to the given range.\n     * @return the constrained value\n     */\n    static public int range(int min, int max, int value) {\n        if (value < min)\n            value = min;\n        if (value > max)\n            value = max;\n        return value;\n    }\n\n    /**\n     * Gets the square distance between two points.\n     */\n    static public long length2(int x1, int y1, int x2, int y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n\n    /**\n     * Gets the distance between to points\n     */\n    static public long length(int x1, int y1, int x2, int y2) {\n        return (long) Math.sqrt(length2(x1, y1, x2, y2));\n    }\n\n    /**\n     * Gets the angle of a point relative to a rectangle.\n     */\n    static public double pointToAngle(Rectangle r, Point p) {\n        int px = p.x - (r.x + r.width / 2);\n        int py = p.y - (r.y + r.height / 2);\n        return Math.atan2(py * r.width, px * r.height);\n    }\n\n    /**\n     * Gets the point on a rectangle that corresponds to the given angle.\n     */\n    static public Point angleToPoint(Rectangle r, double angle) {\n        double si = Math.sin(angle);\n        double co = Math.cos(angle);\n        double e = 0.0001;\n        int x = 0, y = 0;\n        if (Math.abs(si) > e) {\n            x = (int) ((1.0 + co / Math.abs(si)) / 2.0 * r.width);\n            int max = r.width;\n            int value = x;\n            if (value < 0)\n                value = 0;\n            if (value > max)\n                value = max;\n            x = value;\n        } else if (co >= 0.0)\n            x = r.width;\n        if (Math.abs(co) > e) {\n            y = (int) ((1.0 + si / Math.abs(co)) / 2.0 * r.height);\n            y = range(0, r.height, y);\n        } else if (si >= 0.0)\n            y = r.height;\n        return new Point(r.x + x, r.y + y);\n    }\n\n    /**\n     * Converts a polar to a point\n     */\n    static public Point polarToPoint(double angle, double fx, double fy) {\n        double si = Math.sin(angle);\n        double co = Math.cos(angle);\n        return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));\n    }\n\n    /**\n     * Gets the point on an oval that corresponds to the given angle.\n     */\n    static public Point ovalAngleToPoint(Rectangle r, double angle) {\n        Point center = Geom.center(r);\n        Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);\n        return new Point(center.x + p.x, center.y + p.y);\n    }\n\n    /**\n     * Standard line intersection algorithm\n     * Return the point of intersection if it exists, else null\n     */\n    // from Doug Lea's PolygonFigure\n    static public // line 1 point 1 x\n    Point // line 1 point 1 x\n    intersect(// line 1 point 1 x\n    int xa, // line 1 point 1 y\n    int ya, // line 1 point 2 x\n    int xb, // line 1 point 2 y\n    int yb, // line 2 point 1 x\n    int xc, // line 2 point 1 y\n    int yc, // line 2 point 2 x\n    int xd, int yd) {\n        // line 2 point 2 y\n        // source: http://vision.dai.ed.ac.uk/andrewfg/c-g-a-faq.html\n        // eq: for lines AB and CD\n        // (YA-YC)(XD-XC)-(XA-XC)(YD-YC)\n        // r = -----------------------------  (eqn 1)\n        // (XB-XA)(YD-YC)-(YB-YA)(XD-XC)\n        // \n        // (YA-YC)(XB-XA)-(XA-XC)(YB-YA)\n        // s = -----------------------------  (eqn 2)\n        // (XB-XA)(YD-YC)-(YB-YA)(XD-XC)\n        // XI = XA + r(XB-XA)\n        // YI = YA + r(YB-YA)\n        double denom = ((xb - xa) * (yd - yc) - (yb - ya) * (xd - xc));\n        double rnum = ((ya - yc) * (xd - xc) - (xa - xc) * (yd - yc));\n        if (denom == 0.0) {\n            // parallel\n            if (rnum == 0.0) {\n                // coincident; pick one end of first line\n                if ((xa < xb && (xb < xc || xb < xd)) || (xa > xb && (xb > xc || xb > xd)))\n                    return new Point(xb, yb);\n                else\n                    return new Point(xa, ya);\n            } else\n                return null;\n        }\n        double r = rnum / denom;\n        double snum = ((ya - yc) * (xb - xa) - (xa - xc) * (yb - ya));\n        double s = snum / denom;\n        if (0.0 <= r && r <= 1.0 && 0.0 <= s && s <= 1.0) {\n            int px = (int) (xa + (xb - xa) * r);\n            int py = (int) (ya + (yb - ya) * r);\n            return new Point(px, py);\n        } else\n            return null;\n    }\n}",
  "subClasses": []
}