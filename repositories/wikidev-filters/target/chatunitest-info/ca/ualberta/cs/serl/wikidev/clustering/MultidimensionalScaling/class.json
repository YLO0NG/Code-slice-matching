{
  "fullClassName": "ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling",
  "className": "MultidimensionalScaling",
  "index": 30,
  "modifier": "[public ]",
  "extend": "[]",
  "implement": "[]",
  "packageName": "ca.ualberta.cs.serl.wikidev.clustering",
  "packageDeclaration": "package ca.ualberta.cs.serl.wikidev.clustering;",
  "classSignature": "public class MultidimensionalScaling",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.util.ArrayList;"
  ],
  "fields": [
    "private double[][] betaMatrix;",
    "private double[][] alphaMatrix;",
    "private double[][] hMatrix;",
    "private double[][] distanceMatrix;",
    "private double[][] squareDistanceMatrix;",
    "private int dimensions;"
  ],
  "superClasses": [],
  "implementedTypes": [],
  "methodSigs": {
    "getDistanceMatrix()": "0",
    "getAlphaMatrix()": "1",
    "getHMatrix()": "2",
    "getBetaMatrix()": "3",
    "findNegativeEigenValue(double[])": "4",
    "getConstant(double[])": "5",
    "changeDistances(double[])": "6",
    "mds()": "7",
    "getNewBetaMatrix()": "8",
    "cMDS()": "9",
    "MultidimensionalScaling(double[][])": "10"
  },
  "methodsBrief": [
    "public double[][] getDistanceMatrix(){}",
    "public double[][] getAlphaMatrix(){}",
    "private void getHMatrix(){}",
    "public double[][] getBetaMatrix(){}",
    "public boolean findNegativeEigenValue(double[] eigenValues){}",
    "private double getConstant(double[] eigenValues){}",
    "public void changeDistances(double[] eigenValues){}",
    "public float[][] mds(){}",
    "private double[][] getNewBetaMatrix(){}",
    "public double[][] cMDS(){}",
    "public MultidimensionalScaling(double[][] distanceMatrix){}"
  ],
  "constructorSigs": [
    "MultidimensionalScaling(double[][])"
  ],
  "constructorBrief": [
    "public MultidimensionalScaling(double[][] distanceMatrix){}"
  ],
  "getterSetterSigs": [
    "getDistanceMatrix()",
    "getAlphaMatrix()",
    "getHMatrix()",
    "getBetaMatrix()",
    "getNewBetaMatrix()"
  ],
  "getterSetterBrief": [
    "public double[][] getDistanceMatrix(){}",
    "public double[][] getAlphaMatrix(){}",
    "private void getHMatrix(){}",
    "public double[][] getBetaMatrix(){}",
    "private double[][] getNewBetaMatrix(){}"
  ],
  "constructorDeps": {
    "double[]": [],
    "java.lang.Math": [
      "pow(double, double)"
    ],
    "ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling": [
      "getHMatrix()"
    ]
  },
  "compilationUnitCode": "package ca.ualberta.cs.serl.wikidev.clustering;\n\nimport java.util.ArrayList;\n\npublic class MultidimensionalScaling {\n\n    private double[][] betaMatrix;\n\n    private double[][] alphaMatrix;\n\n    private double[][] hMatrix;\n\n    private double[][] distanceMatrix;\n\n    private double[][] squareDistanceMatrix;\n\n    private int dimensions;\n\n    /*public MultidimensionalScaling(ArrayList<Entity> entities) {\n\t\talphaMatrix = new double[entities.size()][entities.size()];\n\t\tdistanceMatrix = new double[entities.size()][entities.size()];\n\t\tsquareDistanceMatrix = new double[entities.size()][entities.size()];\n\t\tfor(int i=0;i<entities.size();i++) {\n\t\t\tfor(int j=0;j<entities.size();j++) {\n\t\t\t\t\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdistanceMatrix[i][j] = DistanceCalculator.getDistance(\n\t\t\t\t\t\t\tentities.get(i).getEntitySet(), entities.get(j)\n\t\t\t\t\t\t\t\t\t.getFullEntitySet());\n\t\t\t\t\tsquareDistanceMatrix[i][j] = Math.pow(DistanceCalculator\n\t\t\t\t\t\t\t.getDistance(entities.get(i).getEntitySet(),\n\t\t\t\t\t\t\t\t\tentities.get(j).getFullEntitySet()), 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdistanceMatrix[i][j] = 0.0;\n\t\t\t\t\tsquareDistanceMatrix[i][j] = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgetAlphaMatrix();\n\t\tbetaMatrix = new double[entities.size()][entities.size()];\n\t}*/\n    public MultidimensionalScaling(double[][] distanceMatrix) {\n        hMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n        this.distanceMatrix = distanceMatrix;\n        squareDistanceMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                squareDistanceMatrix[i][j] = Math.pow(this.distanceMatrix[i][j], 2);\n            }\n        }\n        getHMatrix();\n        betaMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n    }\n\n    public double[][] getDistanceMatrix() {\n        return distanceMatrix;\n    }\n\n    public double[][] getAlphaMatrix() {\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                alphaMatrix[i][j] = -(1.0 / 2.0) * squareDistanceMatrix[i][j];\n            }\n        }\n        return alphaMatrix;\n    }\n\n    private void getHMatrix() {\n        double[][] identity = MatrixOperator.identity(distanceMatrix.length);\n        double[] one = MatrixOperator.oneVector(distanceMatrix.length);\n        // double[][] transposeOne = MatrixOperator.transpose(one);\n        double[] scaled = MatrixOperator.scaleVector(one, (1.0 / distanceMatrix.length));\n        double oneProduct = MatrixOperator.vectorProduct(scaled, one);\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                hMatrix[i][j] = identity[i][j] - oneProduct;\n            }\n        }\n    }\n\n    public double[][] getBetaMatrix() {\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                betaMatrix[i][j] = alphaMatrix[i][j];\n            }\n        }\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    betaMatrix[i][j] -= alphaMatrix[i][k];\n                }\n            }\n        }\n        for (int j = 0; j < alphaMatrix.length; j++) {\n            for (int i = 0; i < alphaMatrix.length; i++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    betaMatrix[i][j] -= alphaMatrix[k][j];\n                }\n            }\n        }\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    for (int m = 0; m < alphaMatrix.length; m++) {\n                        betaMatrix[i][j] += alphaMatrix[k][m];\n                    }\n                }\n            }\n        }\n        return betaMatrix;\n    }\n\n    public boolean findNegativeEigenValue(double[] eigenValues) {\n        for (int i = 0; i < eigenValues.length; i++) {\n            if (eigenValues[i] < 0.0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private double getConstant(double[] eigenValues) {\n        double eigenValue = eigenValues[0];\n        return -2.0 * eigenValue;\n    }\n\n    public void changeDistances(double[] eigenValues) {\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                if (i != j) {\n                    squareDistanceMatrix[i][j] += getConstant(eigenValues);\n                }\n            }\n        }\n    }\n\n    public float[][] mds() {\n        dimensions = 2;\n        float[][] coordinates = new float[distanceMatrix.length][dimensions];\n        while (true) {\n            getAlphaMatrix();\n            double[][] B = getBetaMatrix();\n            // double[] eigenValues = MatrixOperator.getEigenValues(B);\n            // if(findNegativeEigenValue(eigenValues)) {\n            // changeDistances(eigenValues);\n            // }\n            // else {\n            double[][] eigenVectors = MatrixOperator.getEigenVectors(B);\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                for (int j = 0; j < dimensions; j++) {\n                    if (eigenVectors[j][i] >= 0.0) {\n                        coordinates[i][j] = (float) eigenVectors[j][i];\n                    } else {\n                        coordinates[i][j] = (float) -eigenVectors[j][i];\n                    }\n                }\n            }\n            return coordinates;\n            // }\n        }\n    }\n\n    private double[][] getNewBetaMatrix() {\n        /*double[] rowSums = new double[distanceMatrix.length];\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\trowSums[i] = MatrixOperator.getRowSum(distanceMatrix, i);\n\t\t}\n\t\tdouble[] rowAvgs = MatrixOperator.scaleVector(rowSums, 1.0/distanceMatrix.length);\n\t\tdouble[] colSums = new double[distanceMatrix.length];\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\tcolSums[i] = MatrixOperator.getColumnSum(distanceMatrix, i);\n\t\t}\n\t\tdouble[] colAvgs = MatrixOperator.scaleVector(colSums, 1.0/distanceMatrix.length);\n\t\tdouble totalAvg = (1.0/Math.pow(distanceMatrix.length, 2))*MatrixOperator.getTotalSum(distanceMatrix);\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\tfor(int j=0; j<distanceMatrix.length; j++) {\n\t\t\t\tbetaMatrix[i][j] = -(1.0/2.0)*(distanceMatrix[i][j] - rowAvgs[i] - colAvgs[j] + totalAvg);\n\t\t\t}\n\t\t}*/\n        double[][] scaled = MatrixOperator.scaleMatrix(hMatrix, -1.0 / 2.0);\n        betaMatrix = MatrixOperator.matrixProduct(scaled, squareDistanceMatrix);\n        betaMatrix = MatrixOperator.matrixProduct(betaMatrix, hMatrix);\n        return betaMatrix;\n    }\n\n    public double[][] cMDS() {\n        // dimensions = 2;\n        getHMatrix();\n        double[][] B = getNewBetaMatrix();\n        double[] eigenValues = MatrixOperator.getEigenValues(B);\n        double[][] eigenVectors = MatrixOperator.getEigenVectors(B);\n        for (int k = 0; k < eigenValues.length; k++) {\n            if (eigenValues[k] < 0) {\n                eigenValues[k] = 0;\n            }\n        }\n        for (int k = 0; k < eigenValues.length; k++) {\n            if (eigenValues[k] > 0) {\n                dimensions++;\n            }\n        }\n        // dimensions = 2;\n        double[][] coordinates = new double[distanceMatrix.length][dimensions];\n        double[] sqrtEigenValues = MatrixOperator.vectorPower(eigenValues, 1.0 / 2.0);\n        double[][] eigenValuesDiagonal = MatrixOperator.diagonal(sqrtEigenValues);\n        double[][] x = MatrixOperator.matrixProduct(eigenVectors, eigenValuesDiagonal);\n        /*for(int i=0;i<distanceMatrix.length;i++) {\n\t\t\tfor(int j=0;j<dimensions;j++) {\n\t\t\t\tif(eigenVectors[j][i] >= 0.0) {\n\t\t\t\t\tcoordinates[i][j] = (float)eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoordinates[i][j] = (float)-eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n        ArrayList<Integer> indices = new ArrayList<Integer>();\n        int counter = 0;\n        for (int i = 0; i < x.length; i++) {\n            if (x[0][i] != 0.0) {\n                indices.add(i);\n                counter++;\n            }\n            if (counter == dimensions)\n                break;\n        }\n        if (!indices.isEmpty()) {\n            for (int i = 0; i < x.length; i++) {\n                for (int j = 0; j < indices.size(); j++) {\n                    coordinates[i][j] = x[i][indices.get(j)];\n                }\n            }\n            return coordinates;\n        } else {\n            return coordinates;\n        }\n    }\n}\n",
  "classDeclarationCode": "public class MultidimensionalScaling {\n\n    private double[][] betaMatrix;\n\n    private double[][] alphaMatrix;\n\n    private double[][] hMatrix;\n\n    private double[][] distanceMatrix;\n\n    private double[][] squareDistanceMatrix;\n\n    private int dimensions;\n\n    /*public MultidimensionalScaling(ArrayList<Entity> entities) {\n\t\talphaMatrix = new double[entities.size()][entities.size()];\n\t\tdistanceMatrix = new double[entities.size()][entities.size()];\n\t\tsquareDistanceMatrix = new double[entities.size()][entities.size()];\n\t\tfor(int i=0;i<entities.size();i++) {\n\t\t\tfor(int j=0;j<entities.size();j++) {\n\t\t\t\t\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdistanceMatrix[i][j] = DistanceCalculator.getDistance(\n\t\t\t\t\t\t\tentities.get(i).getEntitySet(), entities.get(j)\n\t\t\t\t\t\t\t\t\t.getFullEntitySet());\n\t\t\t\t\tsquareDistanceMatrix[i][j] = Math.pow(DistanceCalculator\n\t\t\t\t\t\t\t.getDistance(entities.get(i).getEntitySet(),\n\t\t\t\t\t\t\t\t\tentities.get(j).getFullEntitySet()), 2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdistanceMatrix[i][j] = 0.0;\n\t\t\t\t\tsquareDistanceMatrix[i][j] = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgetAlphaMatrix();\n\t\tbetaMatrix = new double[entities.size()][entities.size()];\n\t}*/\n    public MultidimensionalScaling(double[][] distanceMatrix) {\n        hMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n        this.distanceMatrix = distanceMatrix;\n        squareDistanceMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                squareDistanceMatrix[i][j] = Math.pow(this.distanceMatrix[i][j], 2);\n            }\n        }\n        getHMatrix();\n        betaMatrix = new double[distanceMatrix.length][distanceMatrix.length];\n    }\n\n    public double[][] getDistanceMatrix() {\n        return distanceMatrix;\n    }\n\n    public double[][] getAlphaMatrix() {\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                alphaMatrix[i][j] = -(1.0 / 2.0) * squareDistanceMatrix[i][j];\n            }\n        }\n        return alphaMatrix;\n    }\n\n    private void getHMatrix() {\n        double[][] identity = MatrixOperator.identity(distanceMatrix.length);\n        double[] one = MatrixOperator.oneVector(distanceMatrix.length);\n        // double[][] transposeOne = MatrixOperator.transpose(one);\n        double[] scaled = MatrixOperator.scaleVector(one, (1.0 / distanceMatrix.length));\n        double oneProduct = MatrixOperator.vectorProduct(scaled, one);\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                hMatrix[i][j] = identity[i][j] - oneProduct;\n            }\n        }\n    }\n\n    public double[][] getBetaMatrix() {\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                betaMatrix[i][j] = alphaMatrix[i][j];\n            }\n        }\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    betaMatrix[i][j] -= alphaMatrix[i][k];\n                }\n            }\n        }\n        for (int j = 0; j < alphaMatrix.length; j++) {\n            for (int i = 0; i < alphaMatrix.length; i++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    betaMatrix[i][j] -= alphaMatrix[k][j];\n                }\n            }\n        }\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                for (int k = 0; k < alphaMatrix.length; k++) {\n                    for (int m = 0; m < alphaMatrix.length; m++) {\n                        betaMatrix[i][j] += alphaMatrix[k][m];\n                    }\n                }\n            }\n        }\n        return betaMatrix;\n    }\n\n    public boolean findNegativeEigenValue(double[] eigenValues) {\n        for (int i = 0; i < eigenValues.length; i++) {\n            if (eigenValues[i] < 0.0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private double getConstant(double[] eigenValues) {\n        double eigenValue = eigenValues[0];\n        return -2.0 * eigenValue;\n    }\n\n    public void changeDistances(double[] eigenValues) {\n        for (int i = 0; i < alphaMatrix.length; i++) {\n            for (int j = 0; j < alphaMatrix.length; j++) {\n                if (i != j) {\n                    squareDistanceMatrix[i][j] += getConstant(eigenValues);\n                }\n            }\n        }\n    }\n\n    public float[][] mds() {\n        dimensions = 2;\n        float[][] coordinates = new float[distanceMatrix.length][dimensions];\n        while (true) {\n            getAlphaMatrix();\n            double[][] B = getBetaMatrix();\n            // double[] eigenValues = MatrixOperator.getEigenValues(B);\n            // if(findNegativeEigenValue(eigenValues)) {\n            // changeDistances(eigenValues);\n            // }\n            // else {\n            double[][] eigenVectors = MatrixOperator.getEigenVectors(B);\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                for (int j = 0; j < dimensions; j++) {\n                    if (eigenVectors[j][i] >= 0.0) {\n                        coordinates[i][j] = (float) eigenVectors[j][i];\n                    } else {\n                        coordinates[i][j] = (float) -eigenVectors[j][i];\n                    }\n                }\n            }\n            return coordinates;\n            // }\n        }\n    }\n\n    private double[][] getNewBetaMatrix() {\n        /*double[] rowSums = new double[distanceMatrix.length];\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\trowSums[i] = MatrixOperator.getRowSum(distanceMatrix, i);\n\t\t}\n\t\tdouble[] rowAvgs = MatrixOperator.scaleVector(rowSums, 1.0/distanceMatrix.length);\n\t\tdouble[] colSums = new double[distanceMatrix.length];\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\tcolSums[i] = MatrixOperator.getColumnSum(distanceMatrix, i);\n\t\t}\n\t\tdouble[] colAvgs = MatrixOperator.scaleVector(colSums, 1.0/distanceMatrix.length);\n\t\tdouble totalAvg = (1.0/Math.pow(distanceMatrix.length, 2))*MatrixOperator.getTotalSum(distanceMatrix);\n\t\tfor(int i=0; i<distanceMatrix.length; i++) {\n\t\t\tfor(int j=0; j<distanceMatrix.length; j++) {\n\t\t\t\tbetaMatrix[i][j] = -(1.0/2.0)*(distanceMatrix[i][j] - rowAvgs[i] - colAvgs[j] + totalAvg);\n\t\t\t}\n\t\t}*/\n        double[][] scaled = MatrixOperator.scaleMatrix(hMatrix, -1.0 / 2.0);\n        betaMatrix = MatrixOperator.matrixProduct(scaled, squareDistanceMatrix);\n        betaMatrix = MatrixOperator.matrixProduct(betaMatrix, hMatrix);\n        return betaMatrix;\n    }\n\n    public double[][] cMDS() {\n        // dimensions = 2;\n        getHMatrix();\n        double[][] B = getNewBetaMatrix();\n        double[] eigenValues = MatrixOperator.getEigenValues(B);\n        double[][] eigenVectors = MatrixOperator.getEigenVectors(B);\n        for (int k = 0; k < eigenValues.length; k++) {\n            if (eigenValues[k] < 0) {\n                eigenValues[k] = 0;\n            }\n        }\n        for (int k = 0; k < eigenValues.length; k++) {\n            if (eigenValues[k] > 0) {\n                dimensions++;\n            }\n        }\n        // dimensions = 2;\n        double[][] coordinates = new double[distanceMatrix.length][dimensions];\n        double[] sqrtEigenValues = MatrixOperator.vectorPower(eigenValues, 1.0 / 2.0);\n        double[][] eigenValuesDiagonal = MatrixOperator.diagonal(sqrtEigenValues);\n        double[][] x = MatrixOperator.matrixProduct(eigenVectors, eigenValuesDiagonal);\n        /*for(int i=0;i<distanceMatrix.length;i++) {\n\t\t\tfor(int j=0;j<dimensions;j++) {\n\t\t\t\tif(eigenVectors[j][i] >= 0.0) {\n\t\t\t\t\tcoordinates[i][j] = (float)eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoordinates[i][j] = (float)-eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n        ArrayList<Integer> indices = new ArrayList<Integer>();\n        int counter = 0;\n        for (int i = 0; i < x.length; i++) {\n            if (x[0][i] != 0.0) {\n                indices.add(i);\n                counter++;\n            }\n            if (counter == dimensions)\n                break;\n        }\n        if (!indices.isEmpty()) {\n            for (int i = 0; i < x.length; i++) {\n                for (int j = 0; j < indices.size(); j++) {\n                    coordinates[i][j] = x[i][indices.get(j)];\n                }\n            }\n            return coordinates;\n        } else {\n            return coordinates;\n        }\n    }\n}",
  "subClasses": []
}