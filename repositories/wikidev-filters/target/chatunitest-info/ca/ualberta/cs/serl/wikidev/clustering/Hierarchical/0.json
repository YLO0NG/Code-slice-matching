{
  "className": "Hierarchical",
  "methodName": "clustering",
  "brief": "public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts){}",
  "methodSignature": "clustering(ArrayList)",
  "sourceCode": "public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts) {\n\t\tArrayList<Cluster> clusters = new ArrayList<Cluster>();\n\t\tfor(IArtifact artifact : artifacts) {\n\t\t\tCluster cluster = new Cluster();\n\t\t\tcluster.addArtifact(artifact);\n\t\t\tclusters.add(cluster);\n\t\t}\n\t\twhile(clusters.size()>2) {\n\t\t\tdouble minVal = 2.0;\n\t\t\tint minRow = 0;\n\t\t\tint minCol = 1;\n\t\t\tfor(int i=0; i<distanceMatrix.length;i++) {\n\t\t\t\tfor(int j=0;j<distanceMatrix.length;j++) {\n\t\t\t\t\tif (i != j) {\n\t\t\t\t\t\tif (distanceMatrix[i][j] < minVal) {\n\t\t\t\t\t\t\tminVal = distanceMatrix[i][j];\n\t\t\t\t\t\t\tminRow = i;\n\t\t\t\t\t\t\tminCol = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minVal >= THRESHOLD) break;\n\t\t\t\n\t\t\tif(minRow < minCol) {\n\t\t\t\tclusters.get(minRow).addArtifacts(clusters.get(minCol).getArtifacts());\n\t\t\t\tdouble[] newDistances = new double[distanceMatrix.length-1];\n\t\t\t\tfor(int i=0;i<distanceMatrix.length;i++) {\n\t\t\t\t\t\tif (i != minCol) {\n\t\t\t\t\t\t\tif (i != minRow) {\n\t\t\t\t\t\t\t\tif (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n\t\t\t\t\t\t\t\t\tif (i > minCol) {\n\t\t\t\t\t\t\t\t\t\tnewDistances[i - 1] = distanceMatrix[minRow][i];\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDistances[i] = distanceMatrix[minRow][i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (i > minCol) {\n\t\t\t\t\t\t\t\t\t\tnewDistances[i - 1] = distanceMatrix[minCol][i];\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDistances[i] = distanceMatrix[minCol][i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnewDistances[i] = 0.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdistanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n\t\t\t\tdistanceMatrix = deleteColumns(distanceMatrix, minCol);\n\t\t\t\tdistanceMatrix = insertRows(distanceMatrix, minRow, newDistances);\n\t\t\t\tdistanceMatrix = deleteColumns(distanceMatrix, minRow);\n\t\t\t\tdistanceMatrix = insertColumns(distanceMatrix, minRow, newDistances);\n\t\t\t\tclusters.remove(minCol);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclusters.get(minCol).addArtifacts(clusters.get(minRow).getArtifacts());\n\t\t\t\tdouble[] newDistances = new double[distanceMatrix.length-1];\n\t\t\t\tfor(int i=0;i<distanceMatrix.length;i++) {\n\t\t\t\t\tif (i != minRow) {\n\t\t\t\t\t\tif (i != minCol) {\n\t\t\t\t\t\t\tif (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n\t\t\t\t\t\t\t\tif (i > minRow) {\n\t\t\t\t\t\t\t\t\tnewDistances[i - 1] = distanceMatrix[minRow][i];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDistances[i] = distanceMatrix[minRow][i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (i > minRow) {\n\t\t\t\t\t\t\t\t\tnewDistances[i - 1] = distanceMatrix[minCol][i];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDistances[i] = distanceMatrix[minCol][i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tnewDistances[i] = 0.0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tdistanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n\t\t\t\tdistanceMatrix = deleteColumns(distanceMatrix, minCol);\n\t\t\t\tdistanceMatrix = insertRows(distanceMatrix, minCol, newDistances);\n\t\t\t\tdistanceMatrix = deleteColumns(distanceMatrix, minRow);\n\t\t\t\tdistanceMatrix = insertColumns(distanceMatrix, minCol, newDistances);\n\t\t\t\tclusters.remove(minRow);\n\t\t\t}\n\t\t}\n\t\treturn clusters;\n\t}",
  "useField": true,
  "isConstructor": false,
  "isGetSet": false,
  "isPublic": true,
  "isBoolean": false,
  "isAbstract": false,
  "parameters": [
    "ArrayList<IArtifact>"
  ],
  "dependentMethods": {
    "ca.ualberta.cs.serl.wikidev.clustering.Cluster": [
      "addArtifact(IArtifact)",
      "getArtifacts()",
      "addArtifacts(IArtifact>)"
    ],
    "java.util.ArrayList": [
      "get(int)",
      "remove(int)",
      "add(E)",
      "size()"
    ]
  },
  "full_method_info": "public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts) {\n    ArrayList<Cluster> clusters = new ArrayList<Cluster>();\n    for (IArtifact artifact : artifacts) {\n        Cluster cluster = new Cluster();\n        cluster.addArtifact(artifact);\n        clusters.add(cluster);\n    }\n    while (clusters.size() > 2) {\n        double minVal = 2.0;\n        int minRow = 0;\n        int minCol = 1;\n        for (int i = 0; i < distanceMatrix.length; i++) {\n            for (int j = 0; j < distanceMatrix.length; j++) {\n                if (i != j) {\n                    if (distanceMatrix[i][j] < minVal) {\n                        minVal = distanceMatrix[i][j];\n                        minRow = i;\n                        minCol = j;\n                    }\n                }\n            }\n        }\n        if (minVal >= THRESHOLD)\n            break;\n        if (minRow < minCol) {\n            clusters.get(minRow).addArtifacts(clusters.get(minCol).getArtifacts());\n            double[] newDistances = new double[distanceMatrix.length - 1];\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                if (i != minCol) {\n                    if (i != minRow) {\n                        if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                            if (i > minCol) {\n                                newDistances[i - 1] = distanceMatrix[minRow][i];\n                            } else {\n                                newDistances[i] = distanceMatrix[minRow][i];\n                            }\n                        } else {\n                            if (i > minCol) {\n                                newDistances[i - 1] = distanceMatrix[minCol][i];\n                            } else {\n                                newDistances[i] = distanceMatrix[minCol][i];\n                            }\n                        }\n                    } else {\n                        newDistances[i] = 0.0;\n                    }\n                }\n            }\n            distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n            distanceMatrix = deleteColumns(distanceMatrix, minCol);\n            distanceMatrix = insertRows(distanceMatrix, minRow, newDistances);\n            distanceMatrix = deleteColumns(distanceMatrix, minRow);\n            distanceMatrix = insertColumns(distanceMatrix, minRow, newDistances);\n            clusters.remove(minCol);\n        } else {\n            clusters.get(minCol).addArtifacts(clusters.get(minRow).getArtifacts());\n            double[] newDistances = new double[distanceMatrix.length - 1];\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                if (i != minRow) {\n                    if (i != minCol) {\n                        if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                            if (i > minRow) {\n                                newDistances[i - 1] = distanceMatrix[minRow][i];\n                            } else {\n                                newDistances[i] = distanceMatrix[minRow][i];\n                            }\n                        } else {\n                            if (i > minRow) {\n                                newDistances[i - 1] = distanceMatrix[minCol][i];\n                            } else {\n                                newDistances[i] = distanceMatrix[minCol][i];\n                            }\n                        }\n                    } else {\n                        newDistances[i] = 0.0;\n                    }\n                }\n            }\n            distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n            distanceMatrix = deleteColumns(distanceMatrix, minCol);\n            distanceMatrix = insertRows(distanceMatrix, minCol, newDistances);\n            distanceMatrix = deleteColumns(distanceMatrix, minRow);\n            distanceMatrix = insertColumns(distanceMatrix, minCol, newDistances);\n            clusters.remove(minRow);\n        }\n    }\n    return clusters;\n}",
  "method_comment": "",
  "method_annotation": ""
}