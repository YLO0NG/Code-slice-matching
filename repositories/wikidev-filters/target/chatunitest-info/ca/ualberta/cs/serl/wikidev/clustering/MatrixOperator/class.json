{
  "fullClassName": "ca.ualberta.cs.serl.wikidev.clustering.MatrixOperator",
  "className": "MatrixOperator",
  "index": 29,
  "modifier": "[public ]",
  "extend": "[]",
  "implement": "[]",
  "packageName": "ca.ualberta.cs.serl.wikidev.clustering",
  "packageDeclaration": "package ca.ualberta.cs.serl.wikidev.clustering;",
  "classSignature": "public class MatrixOperator",
  "hasConstructor": false,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import static org.math.array.DoubleArray.sum;",
    "import static org.math.array.LinearAlgebra.eigen;",
    "import static org.math.array.LinearAlgebra.minus;",
    "import java.io.BufferedWriter;",
    "import java.io.FileWriter;",
    "import java.io.IOException;",
    "import java.util.ArrayList;",
    "import java.util.Iterator;",
    "import java.util.Set;",
    "import java.util.TreeMap;",
    "import org.math.array.DoubleArray;",
    "import org.math.array.LinearAlgebra;",
    "import Jama.EigenvalueDecomposition;",
    "import Jama.Matrix;"
  ],
  "fields": [
    "private static double[][] adjacencyMatrix;"
  ],
  "superClasses": [],
  "implementedTypes": [],
  "methodSigs": {
    "getFiedlerVector(double[][])": "0",
    "getEigenValues(double[][])": "1",
    "getEigenVectors(double[][])": "2",
    "multiplyMatrixes(double[][], double[][])": "3",
    "getAuthorityVector(double[][])": "4",
    "getHubVector(double[][])": "5",
    "getMeanVector(double[][])": "6",
    "getPrincipalEigenVector(double[][])": "7",
    "getMean(double[])": "8",
    "getStandardDeviation(double[])": "9",
    "saveResults(String, double[], double[], double[], double, double)": "10",
    "setAdjacencyMatrix(double[][])": "11",
    "getConnectedComponents()": "12",
    "dfs(int[], int, int)": "13",
    "getVectorNorm(double[])": "14",
    "normalizeVector(double[])": "15",
    "identity(int)": "16",
    "one(int, int)": "17",
    "scaleMatrix(double[][], double)": "18",
    "transpose(double[][])": "19",
    "matrixProduct(double[][], double[][])": "20",
    "vectorPower(double[], double)": "21",
    "matrixVectorProduct(double[][], double[])": "22",
    "diagonal(double[])": "23",
    "getRowSum(double[][], int)": "24",
    "getColumnSum(double[][], int)": "25",
    "getTotalSum(double[][])": "26",
    "scaleVector(double[], double)": "27",
    "oneVector(int)": "28",
    "vectorProduct(double[], double[])": "29",
    "getColumn(double[][], int)": "30"
  },
  "methodsBrief": [
    "public static double[] getFiedlerVector(double[][] A){}",
    "public static double[] getEigenValues(double[][] A){}",
    "public static double[][] getEigenVectors(double[][] A){}",
    "private static double[][] multiplyMatrixes(double[][] A, double[][] B){}",
    "public static double[] getAuthorityVector(double[][] adjacency){}",
    "public static double[] getHubVector(double[][] adjacency){}",
    "public static double[] getMeanVector(double[][] adjacency){}",
    "private static double[] getPrincipalEigenVector(double[][] A){}",
    "public static double getMean(double[] vector){}",
    "public static double getStandardDeviation(double[] vector){}",
    "public static void saveResults(String project, double[] authority, double[] hub, double[] meanVector, double mean, double sd){}",
    "public static void setAdjacencyMatrix(double[][] adjacencyMatrix){}",
    "public static TreeMap<Integer, ArrayList<Integer>> getConnectedComponents(){}",
    "private static void dfs(int[] component, int v, int cn){}",
    "private static double getVectorNorm(double[] vector){}",
    "public static double[] normalizeVector(double[] vector){}",
    "public static double[][] identity(int m){}",
    "public static double[][] one(int m, int n){}",
    "public static double[][] scaleMatrix(double[][] matrix, double v){}",
    "public static double[][] transpose(double[][] matrix){}",
    "public static double[][] matrixProduct(double[][] A, double[][] B){}",
    "public static double[] vectorPower(double[] v, double n){}",
    "public static double[] matrixVectorProduct(double[][] matrix, double[] vector){}",
    "public static double[][] diagonal(double[] c){}",
    "public static double getRowSum(double[][] m, int i){}",
    "public static double getColumnSum(double[][] m, int j){}",
    "public static double getTotalSum(double[][] m){}",
    "public static double[] scaleVector(double[] vector, double v){}",
    "public static double[] oneVector(int m){}",
    "public static double vectorProduct(double[] v1, double[] v2){}",
    "public static double[] getColumn(double[][] matrix, int i){}"
  ],
  "constructorSigs": [],
  "constructorBrief": [],
  "getterSetterSigs": [
    "setAdjacencyMatrix(double[][])",
    "getConnectedComponents()"
  ],
  "getterSetterBrief": [
    "public static void setAdjacencyMatrix(double[][] adjacencyMatrix){}",
    "public static TreeMap<Integer, ArrayList<Integer>> getConnectedComponents(){}"
  ],
  "constructorDeps": {},
  "compilationUnitCode": "package ca.ualberta.cs.serl.wikidev.clustering;\n\nimport static org.math.array.DoubleArray.sum;\nimport static org.math.array.LinearAlgebra.eigen;\nimport static org.math.array.LinearAlgebra.minus;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport org.math.array.DoubleArray;\nimport org.math.array.LinearAlgebra;\nimport Jama.EigenvalueDecomposition;\nimport Jama.Matrix;\n\npublic class MatrixOperator {\n\n    private static double[][] adjacencyMatrix;\n\n    public static double[] getFiedlerVector(double[][] A) {\n        // D - degree matrix\n        double[][] D = new double[A.length][A[0].length];\n        // L - Laplacian matrix\n        double[][] L = new double[A.length][A[0].length];\n        // sumRow is row matrix, each column i in sumRow contains\n        // the sum value of column i in the adjacency matrix\n        double[] sumRow = sum(A);\n        // fill the degree matrix with the degrees of each node.\n        for (int i = 0; i < D[0].length; i++) {\n            D[i][i] = sumRow[i];\n        }\n        // L = D - A\n        L = minus(D, A);\n        EigenvalueDecomposition LEigenDec = eigen(L);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        // keys are the Eigen values sorted in ascending order\n        // values are the corresponding positions in eigenValues matrix\n        TreeMap<Double, Integer> sortedEigenValues = new TreeMap<Double, Integer>();\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            // \\E1\\EB\\EB\\DC\\E6\\EF\\F5\\EC\\E5 \\F0\\F1\\FC\\F3\\E7\\EC\\EF \\F3\\F4\\E9\\F2 \\E1\\F1\\ED\\E7\\F4\\E9\\EA\\DD\\F2 \\F4\\E9\\EC\\DD\\F2\n            double value;\n            if (eigenValues.get(i, i) < 0.0)\n                value = -eigenValues.get(i, i);\n            else\n                value = eigenValues.get(i, i);\n            sortedEigenValues.put(value, i);\n        }\n        Set<Double> keySet = sortedEigenValues.keySet();\n        Iterator<Double> keyIt = keySet.iterator();\n        int minIndex = 0;\n        double threshold = 0.00001;\n        while (keyIt.hasNext()) {\n            Double key = keyIt.next();\n            if (key > threshold) {\n                minIndex = sortedEigenValues.get(key);\n                break;\n            }\n        }\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return DoubleArray.getColumnCopy(eigenVectors2, minIndex);\n    }\n\n    public static double[] getEigenValues(double[][] A) {\n        EigenvalueDecomposition LEigenDec = eigen(A);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        double[] eigenValues2 = new double[eigenValues.getColumnDimension()];\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            eigenValues2[i] = eigenValues.get(i, i);\n        }\n        return eigenValues2;\n    }\n\n    public static double[][] getEigenVectors(double[][] A) {\n        EigenvalueDecomposition LEigenDec = eigen(A);\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return eigenVectors2;\n    }\n\n    private static double[][] multiplyMatrixes(double[][] A, double[][] B) {\n        double[][] product = new double[A.length][A.length];\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < A.length; j++) {\n                for (int k = 0; k < A.length; k++) product[i][j] = product[i][j] + A[i][k] * B[k][j];\n            }\n        }\n        return product;\n    }\n\n    public static double[] getAuthorityVector(double[][] adjacency) {\n        double[][] transpose = transpose(adjacency);\n        double[][] product = multiplyMatrixes(transpose, adjacency);\n        return getPrincipalEigenVector(product);\n    }\n\n    /*private static double[][] transpose(double[][] adjacency) {\n\t\tdouble[][] transpose = new double[adjacency.length][adjacency[0].length];\n\t\tfor(int i=0;i<adjacency.length;i++) {\n\t\t\tfor(int j=0;j<adjacency[0].length;j++) {\n\t\t\t\ttranspose[i][j] = adjacency[j][i];\n\t\t\t}\n\t\t}\n\t\treturn transpose;\n\t}*/\n    public static double[] getHubVector(double[][] adjacency) {\n        double[][] transpose = transpose(adjacency);\n        double[][] product = multiplyMatrixes(adjacency, transpose);\n        return getPrincipalEigenVector(product);\n    }\n\n    public static double[] getMeanVector(double[][] adjacency) {\n        double[] authority = getAuthorityVector(adjacency);\n        double[] hub = getHubVector(adjacency);\n        double[] mean = new double[hub.length];\n        for (int i = 0; i < hub.length; i++) {\n            mean[i] = (authority[i] + hub[i]) / 2;\n        }\n        return mean;\n    }\n\n    private static double[] getPrincipalEigenVector(double[][] A) {\n        // D - degree matrix\n        double[][] D = new double[A.length][A[0].length];\n        // L - Laplacian matrix\n        double[][] L = new double[A.length][A[0].length];\n        // sumRow is row matrix, each column i in sumRow contains\n        // the sum value of column i in the adjacency matrix\n        double[] sumRow = DoubleArray.sum(A);\n        // fill the degree matrix with the degrees of each node.\n        for (int i = 0; i < D[0].length; i++) {\n            D[i][i] = sumRow[i];\n        }\n        // L = D - A\n        L = minus(D, A);\n        EigenvalueDecomposition LEigenDec = eigen(L);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        // keys are the Eigen values sorted in ascending order\n        // values are the corresponding positions in eigenValues matrix\n        TreeMap<Double, Integer> sortedEigenValues = new TreeMap<Double, Integer>();\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            // \\E1\\EB\\EB\\DC\\E6\\EF\\F5\\EC\\E5 \\F0\\F1\\FC\\F3\\E7\\EC\\EF \\F3\\F4\\E9\\F2 \\E1\\F1\\ED\\E7\\F4\\E9\\EA\\DD\\F2 \\F4\\E9\\EC\\DD\\F2\n            double value;\n            if (eigenValues.get(i, i) < 0.0)\n                value = -eigenValues.get(i, i);\n            else\n                value = eigenValues.get(i, i);\n            sortedEigenValues.put(value, i);\n        }\n        /*Set<Double> keySet = sortedEigenValues.keySet();\n        Iterator<Double> keyIt = keySet.iterator();\n        int maxIndex = 0;*/\n        Double lastKey = sortedEigenValues.lastKey();\n        int maxIndex = sortedEigenValues.get(lastKey);\n        /*while(keyIt.hasNext()) {\n            Double key = keyIt.next();\n            maxIndex = sortedEigenValues.get(key);\n            if(maxIndex > sortedEigenValues.get(key)) {\n            \tmaxIndex = sortedEigenValues.get(key);\n            }\n        }*/\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return DoubleArray.getColumnCopy(eigenVectors2, maxIndex);\n    }\n\n    public static double getMean(double[] vector) {\n        double sum = 0;\n        double mean = 0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += vector[i];\n        }\n        if (vector.length > 0) {\n            mean = sum / vector.length;\n        }\n        return mean;\n    }\n\n    public static double getStandardDeviation(double[] vector) {\n        double mean = getMean(vector);\n        double sum = 0;\n        double sd = 0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += Math.pow((vector[i] - mean), 2);\n        }\n        if (vector.length > 0) {\n            sd = Math.sqrt(sum / vector.length);\n        }\n        return sd;\n    }\n\n    public static void saveResults(String project, double[] authority, double[] hub, double[] meanVector, double mean, double sd) {\n        try {\n            BufferedWriter out = new BufferedWriter(new FileWriter(\"C://results\" + \"(\" + project + \")\" + \".txt\"));\n            out.write(project);\n            out.newLine();\n            out.write('[');\n            for (int i = 0; i < authority.length; i++) {\n                out.write(authority[i] + \", \");\n            }\n            out.newLine();\n            for (int i = 0; i < hub.length; i++) {\n                out.write(hub[i] + \", \");\n            }\n            out.newLine();\n            for (int i = 0; i < meanVector.length; i++) {\n                out.write(meanVector[i] + \", \");\n            }\n            out.newLine();\n            out.write(\"\" + mean);\n            out.newLine();\n            out.write(\"\" + sd);\n            out.newLine();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void setAdjacencyMatrix(double[][] adjacencyMatrix) {\n        MatrixOperator.adjacencyMatrix = adjacencyMatrix;\n    }\n\n    public static TreeMap<Integer, ArrayList<Integer>> getConnectedComponents() {\n        int[] component = new int[adjacencyMatrix.length];\n        int cn = 0;\n        for (int i = 0; i < component.length; i++) {\n            if (component[i] == 0) {\n                cn++;\n                dfs(component, i, cn);\n            }\n        }\n        TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<Integer, ArrayList<Integer>>();\n        for (int i = 0; i < component.length; i++) {\n            if (!map.containsKey(component[i])) {\n                ArrayList<Integer> l = new ArrayList<Integer>();\n                l.add(i);\n                map.put(component[i], l);\n            } else {\n                ArrayList<Integer> l = map.get(component[i]);\n                l.add(i);\n            }\n        }\n        return map;\n    }\n\n    private static void dfs(int[] component, int v, int cn) {\n        component[v] = cn;\n        for (int w = 0; w < adjacencyMatrix[v].length; w++) {\n            if (adjacencyMatrix[v][w] != 0)\n                if (component[w] == 0)\n                    dfs(component, w, cn);\n        }\n    }\n\n    private static double getVectorNorm(double[] vector) {\n        double sum = 0.0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += Math.pow(vector[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    public static double[] normalizeVector(double[] vector) {\n        double norm = getVectorNorm(vector);\n        for (int i = 0; i < vector.length; i++) {\n            vector[i] /= norm;\n        }\n        return vector;\n    }\n\n    public static double[][] identity(int m) {\n        return DoubleArray.identity(m);\n    }\n\n    public static double[][] one(int m, int n) {\n        return DoubleArray.fill(m, n, 1.0);\n    }\n\n    public static double[][] scaleMatrix(double[][] matrix, double v) {\n        return LinearAlgebra.times(matrix, v);\n    }\n\n    public static double[][] transpose(double[][] matrix) {\n        return DoubleArray.transpose(matrix);\n    }\n\n    public static double[][] matrixProduct(double[][] A, double[][] B) {\n        return LinearAlgebra.times(A, B);\n    }\n\n    public static double[] vectorPower(double[] v, double n) {\n        return LinearAlgebra.raise(v, n);\n    }\n\n    public static double[] matrixVectorProduct(double[][] matrix, double[] vector) {\n        return LinearAlgebra.times(matrix, vector);\n    }\n\n    public static double[][] diagonal(double[] c) {\n        double[][] I = new double[c.length][c.length];\n        for (int i = 0; i < I.length; i++) I[i][i] = c[i];\n        return I;\n    }\n\n    public static double getRowSum(double[][] m, int i) {\n        return DoubleArray.sum(DoubleArray.getRowCopy(m, i));\n    }\n\n    public static double getColumnSum(double[][] m, int j) {\n        return DoubleArray.sum(DoubleArray.getColumnCopy(m, j));\n    }\n\n    public static double getTotalSum(double[][] m) {\n        double sum = 0;\n        for (int i = 0; i < m.length; i++) {\n            for (int j = 0; j < m.length; j++) {\n                sum += m[i][j];\n            }\n        }\n        return sum;\n    }\n\n    public static double[] scaleVector(double[] vector, double v) {\n        return LinearAlgebra.times(vector, v);\n    }\n\n    public static double[] oneVector(int m) {\n        return DoubleArray.fill(m, 1.0);\n    }\n\n    public static double vectorProduct(double[] v1, double[] v2) {\n        double product = 0;\n        for (int i = 0; i < v1.length; i++) {\n            product += v1[i] * v2[i];\n        }\n        return product;\n    }\n\n    public static double[] getColumn(double[][] matrix, int i) {\n        return DoubleArray.getColumnCopy(matrix, i);\n    }\n}\n",
  "classDeclarationCode": "public class MatrixOperator {\n\n    private static double[][] adjacencyMatrix;\n\n    public static double[] getFiedlerVector(double[][] A) {\n        // D - degree matrix\n        double[][] D = new double[A.length][A[0].length];\n        // L - Laplacian matrix\n        double[][] L = new double[A.length][A[0].length];\n        // sumRow is row matrix, each column i in sumRow contains\n        // the sum value of column i in the adjacency matrix\n        double[] sumRow = sum(A);\n        // fill the degree matrix with the degrees of each node.\n        for (int i = 0; i < D[0].length; i++) {\n            D[i][i] = sumRow[i];\n        }\n        // L = D - A\n        L = minus(D, A);\n        EigenvalueDecomposition LEigenDec = eigen(L);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        // keys are the Eigen values sorted in ascending order\n        // values are the corresponding positions in eigenValues matrix\n        TreeMap<Double, Integer> sortedEigenValues = new TreeMap<Double, Integer>();\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            // \\E1\\EB\\EB\\DC\\E6\\EF\\F5\\EC\\E5 \\F0\\F1\\FC\\F3\\E7\\EC\\EF \\F3\\F4\\E9\\F2 \\E1\\F1\\ED\\E7\\F4\\E9\\EA\\DD\\F2 \\F4\\E9\\EC\\DD\\F2\n            double value;\n            if (eigenValues.get(i, i) < 0.0)\n                value = -eigenValues.get(i, i);\n            else\n                value = eigenValues.get(i, i);\n            sortedEigenValues.put(value, i);\n        }\n        Set<Double> keySet = sortedEigenValues.keySet();\n        Iterator<Double> keyIt = keySet.iterator();\n        int minIndex = 0;\n        double threshold = 0.00001;\n        while (keyIt.hasNext()) {\n            Double key = keyIt.next();\n            if (key > threshold) {\n                minIndex = sortedEigenValues.get(key);\n                break;\n            }\n        }\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return DoubleArray.getColumnCopy(eigenVectors2, minIndex);\n    }\n\n    public static double[] getEigenValues(double[][] A) {\n        EigenvalueDecomposition LEigenDec = eigen(A);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        double[] eigenValues2 = new double[eigenValues.getColumnDimension()];\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            eigenValues2[i] = eigenValues.get(i, i);\n        }\n        return eigenValues2;\n    }\n\n    public static double[][] getEigenVectors(double[][] A) {\n        EigenvalueDecomposition LEigenDec = eigen(A);\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return eigenVectors2;\n    }\n\n    private static double[][] multiplyMatrixes(double[][] A, double[][] B) {\n        double[][] product = new double[A.length][A.length];\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < A.length; j++) {\n                for (int k = 0; k < A.length; k++) product[i][j] = product[i][j] + A[i][k] * B[k][j];\n            }\n        }\n        return product;\n    }\n\n    public static double[] getAuthorityVector(double[][] adjacency) {\n        double[][] transpose = transpose(adjacency);\n        double[][] product = multiplyMatrixes(transpose, adjacency);\n        return getPrincipalEigenVector(product);\n    }\n\n    /*private static double[][] transpose(double[][] adjacency) {\n\t\tdouble[][] transpose = new double[adjacency.length][adjacency[0].length];\n\t\tfor(int i=0;i<adjacency.length;i++) {\n\t\t\tfor(int j=0;j<adjacency[0].length;j++) {\n\t\t\t\ttranspose[i][j] = adjacency[j][i];\n\t\t\t}\n\t\t}\n\t\treturn transpose;\n\t}*/\n    public static double[] getHubVector(double[][] adjacency) {\n        double[][] transpose = transpose(adjacency);\n        double[][] product = multiplyMatrixes(adjacency, transpose);\n        return getPrincipalEigenVector(product);\n    }\n\n    public static double[] getMeanVector(double[][] adjacency) {\n        double[] authority = getAuthorityVector(adjacency);\n        double[] hub = getHubVector(adjacency);\n        double[] mean = new double[hub.length];\n        for (int i = 0; i < hub.length; i++) {\n            mean[i] = (authority[i] + hub[i]) / 2;\n        }\n        return mean;\n    }\n\n    private static double[] getPrincipalEigenVector(double[][] A) {\n        // D - degree matrix\n        double[][] D = new double[A.length][A[0].length];\n        // L - Laplacian matrix\n        double[][] L = new double[A.length][A[0].length];\n        // sumRow is row matrix, each column i in sumRow contains\n        // the sum value of column i in the adjacency matrix\n        double[] sumRow = DoubleArray.sum(A);\n        // fill the degree matrix with the degrees of each node.\n        for (int i = 0; i < D[0].length; i++) {\n            D[i][i] = sumRow[i];\n        }\n        // L = D - A\n        L = minus(D, A);\n        EigenvalueDecomposition LEigenDec = eigen(L);\n        // diagonal eigenvalue matrix\n        Matrix eigenValues = LEigenDec.getD();\n        // eigenvector matrix\n        Matrix eigenVectors = LEigenDec.getV();\n        // keys are the Eigen values sorted in ascending order\n        // values are the corresponding positions in eigenValues matrix\n        TreeMap<Double, Integer> sortedEigenValues = new TreeMap<Double, Integer>();\n        for (int i = 0; i < eigenValues.getColumnDimension(); i++) {\n            // \\E1\\EB\\EB\\DC\\E6\\EF\\F5\\EC\\E5 \\F0\\F1\\FC\\F3\\E7\\EC\\EF \\F3\\F4\\E9\\F2 \\E1\\F1\\ED\\E7\\F4\\E9\\EA\\DD\\F2 \\F4\\E9\\EC\\DD\\F2\n            double value;\n            if (eigenValues.get(i, i) < 0.0)\n                value = -eigenValues.get(i, i);\n            else\n                value = eigenValues.get(i, i);\n            sortedEigenValues.put(value, i);\n        }\n        /*Set<Double> keySet = sortedEigenValues.keySet();\n        Iterator<Double> keyIt = keySet.iterator();\n        int maxIndex = 0;*/\n        Double lastKey = sortedEigenValues.lastKey();\n        int maxIndex = sortedEigenValues.get(lastKey);\n        /*while(keyIt.hasNext()) {\n            Double key = keyIt.next();\n            maxIndex = sortedEigenValues.get(key);\n            if(maxIndex > sortedEigenValues.get(key)) {\n            \tmaxIndex = sortedEigenValues.get(key);\n            }\n        }*/\n        double[][] eigenVectors2 = new double[eigenVectors.getRowDimension()][eigenVectors.getColumnDimension()];\n        for (int i = 0; i < eigenVectors.getRowDimension(); i++) {\n            for (int j = 0; j < eigenVectors.getColumnDimension(); j++) {\n                eigenVectors2[i][j] = eigenVectors.get(i, j);\n            }\n        }\n        return DoubleArray.getColumnCopy(eigenVectors2, maxIndex);\n    }\n\n    public static double getMean(double[] vector) {\n        double sum = 0;\n        double mean = 0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += vector[i];\n        }\n        if (vector.length > 0) {\n            mean = sum / vector.length;\n        }\n        return mean;\n    }\n\n    public static double getStandardDeviation(double[] vector) {\n        double mean = getMean(vector);\n        double sum = 0;\n        double sd = 0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += Math.pow((vector[i] - mean), 2);\n        }\n        if (vector.length > 0) {\n            sd = Math.sqrt(sum / vector.length);\n        }\n        return sd;\n    }\n\n    public static void saveResults(String project, double[] authority, double[] hub, double[] meanVector, double mean, double sd) {\n        try {\n            BufferedWriter out = new BufferedWriter(new FileWriter(\"C://results\" + \"(\" + project + \")\" + \".txt\"));\n            out.write(project);\n            out.newLine();\n            out.write('[');\n            for (int i = 0; i < authority.length; i++) {\n                out.write(authority[i] + \", \");\n            }\n            out.newLine();\n            for (int i = 0; i < hub.length; i++) {\n                out.write(hub[i] + \", \");\n            }\n            out.newLine();\n            for (int i = 0; i < meanVector.length; i++) {\n                out.write(meanVector[i] + \", \");\n            }\n            out.newLine();\n            out.write(\"\" + mean);\n            out.newLine();\n            out.write(\"\" + sd);\n            out.newLine();\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void setAdjacencyMatrix(double[][] adjacencyMatrix) {\n        MatrixOperator.adjacencyMatrix = adjacencyMatrix;\n    }\n\n    public static TreeMap<Integer, ArrayList<Integer>> getConnectedComponents() {\n        int[] component = new int[adjacencyMatrix.length];\n        int cn = 0;\n        for (int i = 0; i < component.length; i++) {\n            if (component[i] == 0) {\n                cn++;\n                dfs(component, i, cn);\n            }\n        }\n        TreeMap<Integer, ArrayList<Integer>> map = new TreeMap<Integer, ArrayList<Integer>>();\n        for (int i = 0; i < component.length; i++) {\n            if (!map.containsKey(component[i])) {\n                ArrayList<Integer> l = new ArrayList<Integer>();\n                l.add(i);\n                map.put(component[i], l);\n            } else {\n                ArrayList<Integer> l = map.get(component[i]);\n                l.add(i);\n            }\n        }\n        return map;\n    }\n\n    private static void dfs(int[] component, int v, int cn) {\n        component[v] = cn;\n        for (int w = 0; w < adjacencyMatrix[v].length; w++) {\n            if (adjacencyMatrix[v][w] != 0)\n                if (component[w] == 0)\n                    dfs(component, w, cn);\n        }\n    }\n\n    private static double getVectorNorm(double[] vector) {\n        double sum = 0.0;\n        for (int i = 0; i < vector.length; i++) {\n            sum += Math.pow(vector[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    public static double[] normalizeVector(double[] vector) {\n        double norm = getVectorNorm(vector);\n        for (int i = 0; i < vector.length; i++) {\n            vector[i] /= norm;\n        }\n        return vector;\n    }\n\n    public static double[][] identity(int m) {\n        return DoubleArray.identity(m);\n    }\n\n    public static double[][] one(int m, int n) {\n        return DoubleArray.fill(m, n, 1.0);\n    }\n\n    public static double[][] scaleMatrix(double[][] matrix, double v) {\n        return LinearAlgebra.times(matrix, v);\n    }\n\n    public static double[][] transpose(double[][] matrix) {\n        return DoubleArray.transpose(matrix);\n    }\n\n    public static double[][] matrixProduct(double[][] A, double[][] B) {\n        return LinearAlgebra.times(A, B);\n    }\n\n    public static double[] vectorPower(double[] v, double n) {\n        return LinearAlgebra.raise(v, n);\n    }\n\n    public static double[] matrixVectorProduct(double[][] matrix, double[] vector) {\n        return LinearAlgebra.times(matrix, vector);\n    }\n\n    public static double[][] diagonal(double[] c) {\n        double[][] I = new double[c.length][c.length];\n        for (int i = 0; i < I.length; i++) I[i][i] = c[i];\n        return I;\n    }\n\n    public static double getRowSum(double[][] m, int i) {\n        return DoubleArray.sum(DoubleArray.getRowCopy(m, i));\n    }\n\n    public static double getColumnSum(double[][] m, int j) {\n        return DoubleArray.sum(DoubleArray.getColumnCopy(m, j));\n    }\n\n    public static double getTotalSum(double[][] m) {\n        double sum = 0;\n        for (int i = 0; i < m.length; i++) {\n            for (int j = 0; j < m.length; j++) {\n                sum += m[i][j];\n            }\n        }\n        return sum;\n    }\n\n    public static double[] scaleVector(double[] vector, double v) {\n        return LinearAlgebra.times(vector, v);\n    }\n\n    public static double[] oneVector(int m) {\n        return DoubleArray.fill(m, 1.0);\n    }\n\n    public static double vectorProduct(double[] v1, double[] v2) {\n        double product = 0;\n        for (int i = 0; i < v1.length; i++) {\n            product += v1[i] * v2[i];\n        }\n        return product;\n    }\n\n    public static double[] getColumn(double[][] matrix, int i) {\n        return DoubleArray.getColumnCopy(matrix, i);\n    }\n}",
  "subClasses": []
}