{
  "fullClassName": "ca.ualberta.cs.serl.wikidev.clustering.Hierarchical",
  "className": "Hierarchical",
  "index": 28,
  "modifier": "[public ]",
  "extend": "[Clustering]",
  "implement": "[]",
  "packageName": "ca.ualberta.cs.serl.wikidev.clustering",
  "packageDeclaration": "package ca.ualberta.cs.serl.wikidev.clustering;",
  "classSignature": "public class Hierarchical",
  "hasConstructor": true,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import static org.math.array.DoubleArray.deleteColumns;",
    "import static org.math.array.DoubleArray.deleteRows;",
    "import static org.math.array.DoubleArray.insertColumns;",
    "import static org.math.array.DoubleArray.insertRows;",
    "import java.util.ArrayList;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.IArtifact;"
  ],
  "fields": [
    "private double THRESHOLD;"
  ],
  "superClasses": [
    "Clustering"
  ],
  "implementedTypes": [],
  "methodSigs": {
    "clustering(ArrayList)": "0",
    "Hierarchical(double[][], double)": "1"
  },
  "methodsBrief": [
    "public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts){}",
    "public Hierarchical(double[][] distanceMatrix, double threshold){}"
  ],
  "constructorSigs": [
    "Hierarchical(double[][], double)"
  ],
  "constructorBrief": [
    "public Hierarchical(double[][] distanceMatrix, double threshold){}"
  ],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {
    "double[]": []
  },
  "compilationUnitCode": "package ca.ualberta.cs.serl.wikidev.clustering;\n\nimport static org.math.array.DoubleArray.deleteColumns;\nimport static org.math.array.DoubleArray.deleteRows;\nimport static org.math.array.DoubleArray.insertColumns;\nimport static org.math.array.DoubleArray.insertRows;\nimport java.util.ArrayList;\nimport ca.ualberta.cs.serl.wikidev.artifacts.IArtifact;\n\npublic class Hierarchical extends Clustering {\n\n    /**\n     * @uml.property  name=\"tHRESHOLD\"\n     */\n    private double THRESHOLD;\n\n    public Hierarchical(double[][] distanceMatrix, double threshold) {\n        this.distanceMatrix = distanceMatrix;\n        this.THRESHOLD = threshold;\n        // TODO Auto-generated constructor stub\n    }\n\n    public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts) {\n        ArrayList<Cluster> clusters = new ArrayList<Cluster>();\n        for (IArtifact artifact : artifacts) {\n            Cluster cluster = new Cluster();\n            cluster.addArtifact(artifact);\n            clusters.add(cluster);\n        }\n        while (clusters.size() > 2) {\n            double minVal = 2.0;\n            int minRow = 0;\n            int minCol = 1;\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                for (int j = 0; j < distanceMatrix.length; j++) {\n                    if (i != j) {\n                        if (distanceMatrix[i][j] < minVal) {\n                            minVal = distanceMatrix[i][j];\n                            minRow = i;\n                            minCol = j;\n                        }\n                    }\n                }\n            }\n            if (minVal >= THRESHOLD)\n                break;\n            if (minRow < minCol) {\n                clusters.get(minRow).addArtifacts(clusters.get(minCol).getArtifacts());\n                double[] newDistances = new double[distanceMatrix.length - 1];\n                for (int i = 0; i < distanceMatrix.length; i++) {\n                    if (i != minCol) {\n                        if (i != minRow) {\n                            if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                                if (i > minCol) {\n                                    newDistances[i - 1] = distanceMatrix[minRow][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minRow][i];\n                                }\n                            } else {\n                                if (i > minCol) {\n                                    newDistances[i - 1] = distanceMatrix[minCol][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minCol][i];\n                                }\n                            }\n                        } else {\n                            newDistances[i] = 0.0;\n                        }\n                    }\n                }\n                distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n                distanceMatrix = deleteColumns(distanceMatrix, minCol);\n                distanceMatrix = insertRows(distanceMatrix, minRow, newDistances);\n                distanceMatrix = deleteColumns(distanceMatrix, minRow);\n                distanceMatrix = insertColumns(distanceMatrix, minRow, newDistances);\n                clusters.remove(minCol);\n            } else {\n                clusters.get(minCol).addArtifacts(clusters.get(minRow).getArtifacts());\n                double[] newDistances = new double[distanceMatrix.length - 1];\n                for (int i = 0; i < distanceMatrix.length; i++) {\n                    if (i != minRow) {\n                        if (i != minCol) {\n                            if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                                if (i > minRow) {\n                                    newDistances[i - 1] = distanceMatrix[minRow][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minRow][i];\n                                }\n                            } else {\n                                if (i > minRow) {\n                                    newDistances[i - 1] = distanceMatrix[minCol][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minCol][i];\n                                }\n                            }\n                        } else {\n                            newDistances[i] = 0.0;\n                        }\n                    }\n                }\n                distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n                distanceMatrix = deleteColumns(distanceMatrix, minCol);\n                distanceMatrix = insertRows(distanceMatrix, minCol, newDistances);\n                distanceMatrix = deleteColumns(distanceMatrix, minRow);\n                distanceMatrix = insertColumns(distanceMatrix, minCol, newDistances);\n                clusters.remove(minRow);\n            }\n        }\n        return clusters;\n    }\n}\n",
  "classDeclarationCode": "public class Hierarchical extends Clustering {\n\n    /**\n     * @uml.property  name=\"tHRESHOLD\"\n     */\n    private double THRESHOLD;\n\n    public Hierarchical(double[][] distanceMatrix, double threshold) {\n        this.distanceMatrix = distanceMatrix;\n        this.THRESHOLD = threshold;\n        // TODO Auto-generated constructor stub\n    }\n\n    public ArrayList<Cluster> clustering(ArrayList<IArtifact> artifacts) {\n        ArrayList<Cluster> clusters = new ArrayList<Cluster>();\n        for (IArtifact artifact : artifacts) {\n            Cluster cluster = new Cluster();\n            cluster.addArtifact(artifact);\n            clusters.add(cluster);\n        }\n        while (clusters.size() > 2) {\n            double minVal = 2.0;\n            int minRow = 0;\n            int minCol = 1;\n            for (int i = 0; i < distanceMatrix.length; i++) {\n                for (int j = 0; j < distanceMatrix.length; j++) {\n                    if (i != j) {\n                        if (distanceMatrix[i][j] < minVal) {\n                            minVal = distanceMatrix[i][j];\n                            minRow = i;\n                            minCol = j;\n                        }\n                    }\n                }\n            }\n            if (minVal >= THRESHOLD)\n                break;\n            if (minRow < minCol) {\n                clusters.get(minRow).addArtifacts(clusters.get(minCol).getArtifacts());\n                double[] newDistances = new double[distanceMatrix.length - 1];\n                for (int i = 0; i < distanceMatrix.length; i++) {\n                    if (i != minCol) {\n                        if (i != minRow) {\n                            if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                                if (i > minCol) {\n                                    newDistances[i - 1] = distanceMatrix[minRow][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minRow][i];\n                                }\n                            } else {\n                                if (i > minCol) {\n                                    newDistances[i - 1] = distanceMatrix[minCol][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minCol][i];\n                                }\n                            }\n                        } else {\n                            newDistances[i] = 0.0;\n                        }\n                    }\n                }\n                distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n                distanceMatrix = deleteColumns(distanceMatrix, minCol);\n                distanceMatrix = insertRows(distanceMatrix, minRow, newDistances);\n                distanceMatrix = deleteColumns(distanceMatrix, minRow);\n                distanceMatrix = insertColumns(distanceMatrix, minRow, newDistances);\n                clusters.remove(minCol);\n            } else {\n                clusters.get(minCol).addArtifacts(clusters.get(minRow).getArtifacts());\n                double[] newDistances = new double[distanceMatrix.length - 1];\n                for (int i = 0; i < distanceMatrix.length; i++) {\n                    if (i != minRow) {\n                        if (i != minCol) {\n                            if (distanceMatrix[minRow][i] < distanceMatrix[minCol][i]) {\n                                if (i > minRow) {\n                                    newDistances[i - 1] = distanceMatrix[minRow][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minRow][i];\n                                }\n                            } else {\n                                if (i > minRow) {\n                                    newDistances[i - 1] = distanceMatrix[minCol][i];\n                                } else {\n                                    newDistances[i] = distanceMatrix[minCol][i];\n                                }\n                            }\n                        } else {\n                            newDistances[i] = 0.0;\n                        }\n                    }\n                }\n                distanceMatrix = deleteRows(distanceMatrix, minRow, minCol);\n                distanceMatrix = deleteColumns(distanceMatrix, minCol);\n                distanceMatrix = insertRows(distanceMatrix, minCol, newDistances);\n                distanceMatrix = deleteColumns(distanceMatrix, minRow);\n                distanceMatrix = insertColumns(distanceMatrix, minCol, newDistances);\n                clusters.remove(minRow);\n            }\n        }\n        return clusters;\n    }\n}",
  "subClasses": []
}