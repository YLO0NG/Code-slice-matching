{
  "fullClassName": "ca.ualberta.cs.serl.wikidev.city3d.Layout",
  "className": "Layout",
  "index": 22,
  "modifier": "[public ]",
  "extend": "[]",
  "implement": "[]",
  "packageName": "ca.ualberta.cs.serl.wikidev.city3d",
  "packageDeclaration": "package ca.ualberta.cs.serl.wikidev.city3d;",
  "classSignature": "public class Layout",
  "hasConstructor": false,
  "isPublic": true,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "import java.awt.Color;",
    "import java.awt.Point;",
    "import java.io.BufferedWriter;",
    "import java.io.FileWriter;",
    "import java.io.IOException;",
    "import java.sql.SQLException;",
    "import java.util.ArrayList;",
    "import java.util.Arrays;",
    "import java.util.Collection;",
    "import java.util.HashMap;",
    "import ca.ualberta.cs.serl.wikidev.DataManager;",
    "import ca.ualberta.cs.serl.wikidev.RelationshipMiner;",
    "import ca.ualberta.cs.serl.wikidev.User;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.ChangeSet;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.IArtifact;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.Message;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.SVNFile;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.Ticket;",
    "import ca.ualberta.cs.serl.wikidev.artifacts.Wiki;",
    "import ca.ualberta.cs.serl.wikidev.clustering.Cluster;",
    "import ca.ualberta.cs.serl.wikidev.clustering.Clustering;",
    "import ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling;",
    "import ca.ualberta.cs.serl.wikidev.clustering.SammonsProjection;"
  ],
  "fields": [
    "protected ArrayList<CityBlock> cityBlocks;",
    "public static final String URLprefix = \"http://hypatia.cs.ualberta.ca/ucosp/index.php/\";"
  ],
  "superClasses": [],
  "implementedTypes": [],
  "methodSigs": {
    "getLayout(ArrayList, double[][])": "0",
    "cityBlockInitialization(ArrayList, double[][], double, double, double, double)": "1",
    "pushBuildings(double, double, double)": "2",
    "redistributeBuildings()": "3",
    "assignArtifactToCityBlock(IArtifact, double, double, double, double, double, double)": "4",
    "getCityBlock(Point)": "5",
    "getClosestArtifact(CityBlock)": "6",
    "getClosestBlock(IArtifact)": "7",
    "redistributeArtifactsInBlock(CityBlock, double[][])": "8",
    "getEuclideanDistance(double[], double[])": "9",
    "getUsers(int)": "10",
    "assignUserColors(int)": "11",
    "assignUserColors2(int)": "12"
  },
  "methodsBrief": [
    "protected void getLayout(ArrayList<IArtifact> newArtifacts, double[][] distanceMatrix) throws IOException{}",
    "private void cityBlockInitialization(ArrayList<IArtifact> newArtifacts,\r\n\t\t\tdouble[][] coords, double minX, double minY, double range,\r\n\t\t\tdouble blocks){}",
    "private void pushBuildings(double minX, double minY, double range){}",
    "private void redistributeBuildings(){}",
    "private void assignArtifactToCityBlock(IArtifact artifact, double x,\r\n\t\t\tdouble y, double minX, double minY, double blocks, double r){}",
    "private CityBlock getCityBlock(Point index){}",
    "private IArtifact getClosestArtifact(CityBlock block){}",
    "private CityBlock getClosestBlock(IArtifact artifact){}",
    "private void redistributeArtifactsInBlock(CityBlock block,\r\n\t\t\tdouble[][] subblocks){}",
    "private double getEuclideanDistance(double[] p1, double[] p2){}",
    "public ArrayList<User> getUsers(int projectid){}",
    "private ArrayList<User> assignUserColors(int projectid){}",
    "private ArrayList<User> assignUserColors2(int projectid){}"
  ],
  "constructorSigs": [],
  "constructorBrief": [],
  "getterSetterSigs": [],
  "getterSetterBrief": [],
  "constructorDeps": {},
  "compilationUnitCode": "package ca.ualberta.cs.serl.wikidev.city3d;\n\nimport java.awt.Color;\nimport java.awt.Point;\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport ca.ualberta.cs.serl.wikidev.DataManager;\nimport ca.ualberta.cs.serl.wikidev.RelationshipMiner;\nimport ca.ualberta.cs.serl.wikidev.User;\nimport ca.ualberta.cs.serl.wikidev.artifacts.ChangeSet;\nimport ca.ualberta.cs.serl.wikidev.artifacts.IArtifact;\nimport ca.ualberta.cs.serl.wikidev.artifacts.Message;\nimport ca.ualberta.cs.serl.wikidev.artifacts.SVNFile;\nimport ca.ualberta.cs.serl.wikidev.artifacts.Ticket;\nimport ca.ualberta.cs.serl.wikidev.artifacts.Wiki;\nimport ca.ualberta.cs.serl.wikidev.clustering.Cluster;\nimport ca.ualberta.cs.serl.wikidev.clustering.Clustering;\nimport ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling;\nimport ca.ualberta.cs.serl.wikidev.clustering.SammonsProjection;\n\npublic class Layout {\n\n    protected ArrayList<CityBlock> cityBlocks;\n\n    public static final String URLprefix = \"http://hypatia.cs.ualberta.ca/ucosp/index.php/\";\n\n    protected void getLayout(ArrayList<IArtifact> newArtifacts, double[][] distanceMatrix) throws IOException {\n        double[][] coords = null;\n        if (distanceMatrix.length > 0) {\n            MultidimensionalScaling mds = new MultidimensionalScaling(distanceMatrix);\n            double[][] mdsCoords = mds.cMDS();\n            SammonsProjection sammon = new SammonsProjection(mdsCoords, 2, 1000);\n            sammon.CreateMapping();\n            coords = sammon.getProjection();\n        }\n        for (int i = 0; i < newArtifacts.size(); i++) {\n            newArtifacts.get(i).setCoords(coords[i]);\n        }\n        System.out.print(\"x<-c(\");\n        double maxX = 0;\n        double minX = Double.MAX_VALUE;\n        double maxY = 0;\n        double minY = Double.MAX_VALUE;\n        for (int i = 0; i < coords.length; i++) {\n            for (int j = 0; j < coords[0].length; j++) {\n                if (j == 0) {\n                    if (coords[i][j] > maxX) {\n                        maxX = coords[i][j];\n                    }\n                    if (coords[i][j] < minX) {\n                        minX = coords[i][j];\n                    }\n                } else {\n                    if (coords[i][j] > maxY) {\n                        maxY = coords[i][j];\n                    }\n                    if (coords[i][j] < minY) {\n                        minY = coords[i][j];\n                    }\n                }\n                System.out.print((float) coords[i][j] + \", \");\n            }\n        }\n        System.out.println(\")\");\n        double rangeX = Math.ceil(maxX - minX);\n        double rangeY = Math.ceil(maxY - minY);\n        double range = 0;\n        if (rangeX > rangeY) {\n            range = rangeX;\n        } else {\n            range = rangeY;\n        }\n        double blocks = Math.ceil(Math.sqrt(Math.ceil(newArtifacts.size() / 16))) + 2;\n        cityBlockInitialization(newArtifacts, coords, minX, minY, range, blocks);\n        redistributeBuildings();\n        pushBuildings(minX, minY, range);\n        // printCityBlocks(cityBlocks);\n        System.out.println(\"Blocks done\");\n    }\n\n    private void cityBlockInitialization(ArrayList<IArtifact> newArtifacts, double[][] coords, double minX, double minY, double range, double blocks) {\n        this.cityBlocks = new ArrayList<CityBlock>();\n        for (int i = 0; i < blocks; i++) {\n            for (int j = 0; j < blocks; j++) {\n                double[] center = { minX + i * (range / 16) + (range / 16) / 2, minY + j * (range / 16) + (range / 16) / 2 };\n                CityBlock cityblock = new CityBlock(new Point(i, j));\n                cityblock.setCenter(center);\n                cityBlocks.add(cityblock);\n            }\n        }\n        double r = range / blocks;\n        for (int i = 0; i < newArtifacts.size(); i++) {\n            assignArtifactToCityBlock(newArtifacts.get(i), coords[i][0], coords[i][1], minX, minY, blocks, r);\n        }\n    }\n\n    private void pushBuildings(double minX, double minY, double range) {\n        for (CityBlock block : cityBlocks) {\n            if (block.getArtifacts().size() > 4 && block.getArtifacts().size() <= 16) {\n                double blockMinX = minX + block.getIndex().x * (range / 16);\n                double blockMaxX = minX + (block.getIndex().x + 1) * (range / 16);\n                double blockMinY = minY + block.getIndex().y * (range / 16);\n                double blockMaxY = minY + (block.getIndex().y + 1) * (range / 16);\n                double rX = Math.ceil(blockMaxX - blockMinX);\n                double rY = Math.ceil(blockMaxY - blockMinY);\n                double blockR = 0;\n                if (rX > rY) {\n                    blockR = rX;\n                } else {\n                    blockR = rY;\n                }\n                double[][] subblockCenters = new double[16][3];\n                for (int i = 0; i < 4; i++) {\n                    for (int j = 0; j < 4; j++) {\n                        double[] subCenter = { blockMinX + i * blockR + blockR / 2, blockMinY + j * blockR + blockR / 2, 0 };\n                        subblockCenters[j + i * 4] = subCenter;\n                    }\n                }\n                redistributeArtifactsInBlock(block, subblockCenters);\n            }\n        }\n    }\n\n    private void redistributeBuildings() {\n        for (CityBlock block : cityBlocks) {\n            if (block.getArtifacts().size() > 16) {\n                block.setMarked(true);\n                HashMap<IArtifact, Integer> finalArtifacts = new HashMap<IArtifact, Integer>();\n                for (IArtifact artifact : block.getArtifacts().keySet()) {\n                    if (artifact.isEnforced()) {\n                        finalArtifacts.put(artifact, -1);\n                    }\n                }\n                while (finalArtifacts.size() < 16) {\n                    IArtifact artifact = getClosestArtifact(block);\n                    finalArtifacts.put(artifact, -1);\n                    block.getArtifacts().remove(artifact);\n                }\n                Collection<IArtifact> surplus = block.getArtifacts().keySet();\n                block.setArtifacts(finalArtifacts);\n                for (IArtifact artifact : surplus) {\n                    CityBlock closestBlock = getClosestBlock(artifact);\n                    artifact.setEnforced(true);\n                    closestBlock.addArtifact(artifact, -1);\n                }\n            }\n        }\n    }\n\n    private void assignArtifactToCityBlock(IArtifact artifact, double x, double y, double minX, double minY, double blocks, double r) {\n        int blockX = 0;\n        int blockY = 0;\n        for (int i = 1; i < blocks; i++) {\n            if (x > minX + (i - 1) * r && x <= minX + i * r) {\n                blockX = i - 1;\n            }\n            if (y > minY + (i - 1) * r && y <= minY + i * r) {\n                blockY = i - 1;\n            }\n        }\n        CityBlock block = getCityBlock(new Point(blockX, blockY));\n        block.addArtifact(artifact, -1);\n    }\n\n    private CityBlock getCityBlock(Point index) {\n        for (CityBlock block : cityBlocks) {\n            if (index.equals(block.getIndex())) {\n                return block;\n            }\n        }\n        return null;\n    }\n\n    private IArtifact getClosestArtifact(CityBlock block) {\n        double minDist = Double.MAX_VALUE;\n        IArtifact minArtifact = null;\n        for (IArtifact artifact : block.getArtifacts().keySet()) {\n            if (getEuclideanDistance(artifact.getCoords(), block.getCenter()) < minDist) {\n                minDist = getEuclideanDistance(artifact.getCoords(), block.getCenter());\n                minArtifact = artifact;\n            }\n        }\n        return minArtifact;\n    }\n\n    private CityBlock getClosestBlock(IArtifact artifact) {\n        double minDist = Double.MAX_VALUE;\n        CityBlock minBlock = null;\n        for (CityBlock block : cityBlocks) {\n            if (!block.isMarked() && block.getArtifacts().size() < 16) {\n                if (getEuclideanDistance(artifact.getCoords(), block.getCenter()) < minDist) {\n                    minDist = getEuclideanDistance(artifact.getCoords(), block.getCenter());\n                    minBlock = block;\n                }\n            }\n        }\n        return minBlock;\n    }\n\n    private void redistributeArtifactsInBlock(CityBlock block, double[][] subblocks) {\n        Collection<IArtifact> artifacts = new ArrayList<IArtifact>();\n        artifacts.addAll(block.getArtifacts().keySet());\n        block.getArtifacts().clear();\n        for (IArtifact artifact : artifacts) {\n            double minDist = Double.MAX_VALUE;\n            int minSubblock = -1;\n            for (int i = 0; i < subblocks.length; i++) {\n                if (subblocks[i][2] != 1) {\n                    double[] subcenter = new double[2];\n                    subcenter[0] = subblocks[i][0];\n                    subcenter[1] = subblocks[i][1];\n                    if (getEuclideanDistance(artifact.getCoords(), subcenter) < minDist) {\n                        minDist = getEuclideanDistance(artifact.getCoords(), subcenter);\n                        minSubblock = i;\n                    }\n                }\n            }\n            subblocks[minSubblock][2] = 1;\n            block.addArtifact(artifact, minSubblock);\n        }\n    }\n\n    private double getEuclideanDistance(double[] p1, double[] p2) {\n        double sum = 0.0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    public ArrayList<User> getUsers(int projectid) {\n        return assignUserColors2(projectid);\n    }\n\n    private ArrayList<User> assignUserColors(int projectid) {\n        ArrayList<User> users = null;\n        try {\n            users = DataManager.getUsersPerProject(projectid);\n            boolean emptyUsers = false;\n            int count = 0;\n            for (int r = 0; r <= 255; r += 127) {\n                for (int g = 0; g <= 255; g += 127) {\n                    for (int b = 0; b <= 255; b += 127) {\n                        if (!(new Color(r, g, b).equals(Color.black) || new Color(r, g, b).equals(Color.white))) {\n                            users.get(count).setColor(new Color(r, g, b));\n                            count++;\n                            if (users.size() == count) {\n                                emptyUsers = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (emptyUsers)\n                        break;\n                }\n                if (emptyUsers)\n                    break;\n            }\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return users;\n    }\n\n    private ArrayList<User> assignUserColors2(int projectid) {\n        ArrayList<User> users = null;\n        try {\n            users = DataManager.getUsersPerProject(projectid);\n            ArrayList<Color> colors = new ArrayList<Color>();\n            colors.add(new Color(0, 0, 255));\n            colors.add(new Color(0, 255, 0));\n            colors.add(new Color(255, 0, 0));\n            colors.add(new Color(0, 255, 255));\n            colors.add(new Color(255, 0, 255));\n            colors.add(new Color(255, 255, 0));\n            colors.add(new Color(127, 0, 0));\n            colors.add(new Color(255, 127, 0));\n            colors.add(new Color(127, 0, 127));\n            for (int i = 0; i < colors.size(); i++) {\n                users.get(i).setColor(colors.get(i));\n            }\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return users;\n    }\n}\n",
  "classDeclarationCode": "public class Layout {\n\n    protected ArrayList<CityBlock> cityBlocks;\n\n    public static final String URLprefix = \"http://hypatia.cs.ualberta.ca/ucosp/index.php/\";\n\n    protected void getLayout(ArrayList<IArtifact> newArtifacts, double[][] distanceMatrix) throws IOException {\n        double[][] coords = null;\n        if (distanceMatrix.length > 0) {\n            MultidimensionalScaling mds = new MultidimensionalScaling(distanceMatrix);\n            double[][] mdsCoords = mds.cMDS();\n            SammonsProjection sammon = new SammonsProjection(mdsCoords, 2, 1000);\n            sammon.CreateMapping();\n            coords = sammon.getProjection();\n        }\n        for (int i = 0; i < newArtifacts.size(); i++) {\n            newArtifacts.get(i).setCoords(coords[i]);\n        }\n        System.out.print(\"x<-c(\");\n        double maxX = 0;\n        double minX = Double.MAX_VALUE;\n        double maxY = 0;\n        double minY = Double.MAX_VALUE;\n        for (int i = 0; i < coords.length; i++) {\n            for (int j = 0; j < coords[0].length; j++) {\n                if (j == 0) {\n                    if (coords[i][j] > maxX) {\n                        maxX = coords[i][j];\n                    }\n                    if (coords[i][j] < minX) {\n                        minX = coords[i][j];\n                    }\n                } else {\n                    if (coords[i][j] > maxY) {\n                        maxY = coords[i][j];\n                    }\n                    if (coords[i][j] < minY) {\n                        minY = coords[i][j];\n                    }\n                }\n                System.out.print((float) coords[i][j] + \", \");\n            }\n        }\n        System.out.println(\")\");\n        double rangeX = Math.ceil(maxX - minX);\n        double rangeY = Math.ceil(maxY - minY);\n        double range = 0;\n        if (rangeX > rangeY) {\n            range = rangeX;\n        } else {\n            range = rangeY;\n        }\n        double blocks = Math.ceil(Math.sqrt(Math.ceil(newArtifacts.size() / 16))) + 2;\n        cityBlockInitialization(newArtifacts, coords, minX, minY, range, blocks);\n        redistributeBuildings();\n        pushBuildings(minX, minY, range);\n        // printCityBlocks(cityBlocks);\n        System.out.println(\"Blocks done\");\n    }\n\n    private void cityBlockInitialization(ArrayList<IArtifact> newArtifacts, double[][] coords, double minX, double minY, double range, double blocks) {\n        this.cityBlocks = new ArrayList<CityBlock>();\n        for (int i = 0; i < blocks; i++) {\n            for (int j = 0; j < blocks; j++) {\n                double[] center = { minX + i * (range / 16) + (range / 16) / 2, minY + j * (range / 16) + (range / 16) / 2 };\n                CityBlock cityblock = new CityBlock(new Point(i, j));\n                cityblock.setCenter(center);\n                cityBlocks.add(cityblock);\n            }\n        }\n        double r = range / blocks;\n        for (int i = 0; i < newArtifacts.size(); i++) {\n            assignArtifactToCityBlock(newArtifacts.get(i), coords[i][0], coords[i][1], minX, minY, blocks, r);\n        }\n    }\n\n    private void pushBuildings(double minX, double minY, double range) {\n        for (CityBlock block : cityBlocks) {\n            if (block.getArtifacts().size() > 4 && block.getArtifacts().size() <= 16) {\n                double blockMinX = minX + block.getIndex().x * (range / 16);\n                double blockMaxX = minX + (block.getIndex().x + 1) * (range / 16);\n                double blockMinY = minY + block.getIndex().y * (range / 16);\n                double blockMaxY = minY + (block.getIndex().y + 1) * (range / 16);\n                double rX = Math.ceil(blockMaxX - blockMinX);\n                double rY = Math.ceil(blockMaxY - blockMinY);\n                double blockR = 0;\n                if (rX > rY) {\n                    blockR = rX;\n                } else {\n                    blockR = rY;\n                }\n                double[][] subblockCenters = new double[16][3];\n                for (int i = 0; i < 4; i++) {\n                    for (int j = 0; j < 4; j++) {\n                        double[] subCenter = { blockMinX + i * blockR + blockR / 2, blockMinY + j * blockR + blockR / 2, 0 };\n                        subblockCenters[j + i * 4] = subCenter;\n                    }\n                }\n                redistributeArtifactsInBlock(block, subblockCenters);\n            }\n        }\n    }\n\n    private void redistributeBuildings() {\n        for (CityBlock block : cityBlocks) {\n            if (block.getArtifacts().size() > 16) {\n                block.setMarked(true);\n                HashMap<IArtifact, Integer> finalArtifacts = new HashMap<IArtifact, Integer>();\n                for (IArtifact artifact : block.getArtifacts().keySet()) {\n                    if (artifact.isEnforced()) {\n                        finalArtifacts.put(artifact, -1);\n                    }\n                }\n                while (finalArtifacts.size() < 16) {\n                    IArtifact artifact = getClosestArtifact(block);\n                    finalArtifacts.put(artifact, -1);\n                    block.getArtifacts().remove(artifact);\n                }\n                Collection<IArtifact> surplus = block.getArtifacts().keySet();\n                block.setArtifacts(finalArtifacts);\n                for (IArtifact artifact : surplus) {\n                    CityBlock closestBlock = getClosestBlock(artifact);\n                    artifact.setEnforced(true);\n                    closestBlock.addArtifact(artifact, -1);\n                }\n            }\n        }\n    }\n\n    private void assignArtifactToCityBlock(IArtifact artifact, double x, double y, double minX, double minY, double blocks, double r) {\n        int blockX = 0;\n        int blockY = 0;\n        for (int i = 1; i < blocks; i++) {\n            if (x > minX + (i - 1) * r && x <= minX + i * r) {\n                blockX = i - 1;\n            }\n            if (y > minY + (i - 1) * r && y <= minY + i * r) {\n                blockY = i - 1;\n            }\n        }\n        CityBlock block = getCityBlock(new Point(blockX, blockY));\n        block.addArtifact(artifact, -1);\n    }\n\n    private CityBlock getCityBlock(Point index) {\n        for (CityBlock block : cityBlocks) {\n            if (index.equals(block.getIndex())) {\n                return block;\n            }\n        }\n        return null;\n    }\n\n    private IArtifact getClosestArtifact(CityBlock block) {\n        double minDist = Double.MAX_VALUE;\n        IArtifact minArtifact = null;\n        for (IArtifact artifact : block.getArtifacts().keySet()) {\n            if (getEuclideanDistance(artifact.getCoords(), block.getCenter()) < minDist) {\n                minDist = getEuclideanDistance(artifact.getCoords(), block.getCenter());\n                minArtifact = artifact;\n            }\n        }\n        return minArtifact;\n    }\n\n    private CityBlock getClosestBlock(IArtifact artifact) {\n        double minDist = Double.MAX_VALUE;\n        CityBlock minBlock = null;\n        for (CityBlock block : cityBlocks) {\n            if (!block.isMarked() && block.getArtifacts().size() < 16) {\n                if (getEuclideanDistance(artifact.getCoords(), block.getCenter()) < minDist) {\n                    minDist = getEuclideanDistance(artifact.getCoords(), block.getCenter());\n                    minBlock = block;\n                }\n            }\n        }\n        return minBlock;\n    }\n\n    private void redistributeArtifactsInBlock(CityBlock block, double[][] subblocks) {\n        Collection<IArtifact> artifacts = new ArrayList<IArtifact>();\n        artifacts.addAll(block.getArtifacts().keySet());\n        block.getArtifacts().clear();\n        for (IArtifact artifact : artifacts) {\n            double minDist = Double.MAX_VALUE;\n            int minSubblock = -1;\n            for (int i = 0; i < subblocks.length; i++) {\n                if (subblocks[i][2] != 1) {\n                    double[] subcenter = new double[2];\n                    subcenter[0] = subblocks[i][0];\n                    subcenter[1] = subblocks[i][1];\n                    if (getEuclideanDistance(artifact.getCoords(), subcenter) < minDist) {\n                        minDist = getEuclideanDistance(artifact.getCoords(), subcenter);\n                        minSubblock = i;\n                    }\n                }\n            }\n            subblocks[minSubblock][2] = 1;\n            block.addArtifact(artifact, minSubblock);\n        }\n    }\n\n    private double getEuclideanDistance(double[] p1, double[] p2) {\n        double sum = 0.0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += Math.pow(p1[i] - p2[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n\n    public ArrayList<User> getUsers(int projectid) {\n        return assignUserColors2(projectid);\n    }\n\n    private ArrayList<User> assignUserColors(int projectid) {\n        ArrayList<User> users = null;\n        try {\n            users = DataManager.getUsersPerProject(projectid);\n            boolean emptyUsers = false;\n            int count = 0;\n            for (int r = 0; r <= 255; r += 127) {\n                for (int g = 0; g <= 255; g += 127) {\n                    for (int b = 0; b <= 255; b += 127) {\n                        if (!(new Color(r, g, b).equals(Color.black) || new Color(r, g, b).equals(Color.white))) {\n                            users.get(count).setColor(new Color(r, g, b));\n                            count++;\n                            if (users.size() == count) {\n                                emptyUsers = true;\n                                break;\n                            }\n                        }\n                    }\n                    if (emptyUsers)\n                        break;\n                }\n                if (emptyUsers)\n                    break;\n            }\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return users;\n    }\n\n    private ArrayList<User> assignUserColors2(int projectid) {\n        ArrayList<User> users = null;\n        try {\n            users = DataManager.getUsersPerProject(projectid);\n            ArrayList<Color> colors = new ArrayList<Color>();\n            colors.add(new Color(0, 0, 255));\n            colors.add(new Color(0, 255, 0));\n            colors.add(new Color(255, 0, 0));\n            colors.add(new Color(0, 255, 255));\n            colors.add(new Color(255, 0, 255));\n            colors.add(new Color(255, 255, 0));\n            colors.add(new Color(127, 0, 0));\n            colors.add(new Color(255, 127, 0));\n            colors.add(new Color(127, 0, 127));\n            for (int i = 0; i < colors.size(); i++) {\n                users.get(i).setColor(colors.get(i));\n            }\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return users;\n    }\n}",
  "subClasses": [
    "ca.ualberta.cs.serl.wikidev.city3d.CityLayout",
    "ca.ualberta.cs.serl.wikidev.city3d.IndustrialLayout"
  ]
}