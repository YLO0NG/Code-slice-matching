{
  "fullClassName": "ca.ualberta.cs.serl.wikidev.Stemmer",
  "className": "Stemmer",
  "index": 41,
  "modifier": "[]",
  "extend": "[]",
  "implement": "[]",
  "packageName": "ca.ualberta.cs.serl.wikidev",
  "packageDeclaration": "package ca.ualberta.cs.serl.wikidev;",
  "classSignature": "class Stemmer",
  "hasConstructor": true,
  "isPublic": false,
  "isInterface": false,
  "isAbstract": false,
  "imports": [
    "/*\r\n\r\n   Porter stemmer in Java. The original paper is in\r\n\r\n       Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,\r\n       no. 3, pp 130-137,\r\n\r\n   See also http://www.tartarus.org/~martin/PorterStemmer\r\n\r\n   History:\r\n\r\n   Release 1\r\n\r\n   Bug 1 (reported by Gonzalo Parra 16/10/99) fixed as marked below.\r\n   The words 'aed', 'eed', 'oed' leave k at 'a' for step 3, and b[k-1]\r\n   is then out outside the bounds of b.\r\n\r\n   Release 2\r\n\r\n   Similarly,\r\n\r\n   Bug 2 (reported by Steve Dyrdahl 22/2/00) fixed as marked below.\r\n   'ion' by itself leaves j = -1 in the test for 'ion' in step 5, and\r\n   b[j] is then outside the bounds of b.\r\n\r\n   Release 3\r\n\r\n   Considerably revised 4/9/00 in the light of many helpful suggestions\r\n   from Brian Goetz of Quiotix Corporation (brian@quiotix.com).\r\n\r\n   Release 4\r\n\r\n*/\r\nimport java.io.*;"
  ],
  "fields": [
    "private char[] b;",
    "private int i;",
    "private int i_end;",
    "private int j;",
    "private int k;",
    "private static final int INC = 50;"
  ],
  "superClasses": [],
  "implementedTypes": [],
  "methodSigs": {
    "add(char)": "0",
    "add(char[], int)": "1",
    "toString()": "2",
    "getResultLength()": "3",
    "getResultBuffer()": "4",
    "cons(int)": "5",
    "m()": "6",
    "vowelinstem()": "7",
    "doublec(int)": "8",
    "cvc(int)": "9",
    "ends(String)": "10",
    "setto(String)": "11",
    "r(String)": "12",
    "step1()": "13",
    "step2()": "14",
    "step3()": "15",
    "step4()": "16",
    "step5()": "17",
    "step6()": "18",
    "stem()": "19",
    "main(String[])": "20",
    "Stemmer()": "21"
  },
  "methodsBrief": [
    "public void add(char ch)\r\n  {}",
    "public void add(char[] w, int wLen)\r\n  {}",
    "public String toString(){}",
    "public int getResultLength(){}",
    "public char[] getResultBuffer(){}",
    "private final boolean cons(int i)\r\n  {}",
    "private final int m()\r\n  {}",
    "private final boolean vowelinstem()\r\n  {}",
    "private final boolean doublec(int j)\r\n  {}",
    "private final boolean cvc(int i)\r\n  {}",
    "private final boolean ends(String s)\r\n  {}",
    "private final void setto(String s)\r\n  {}",
    "private final void r(String s){}",
    "private final void step1()\r\n  {}",
    "private final void step2(){}",
    "private final void step3(){}",
    "private final void step4(){}",
    "private final void step5()\r\n  {}",
    "private final void step6()\r\n  {}",
    "public void stem()\r\n  {}",
    "public static void main(String[] args)\r\n  {}",
    "public Stemmer()\r\n  {}"
  ],
  "constructorSigs": [
    "Stemmer()"
  ],
  "constructorBrief": [
    "public Stemmer()\r\n  {}"
  ],
  "getterSetterSigs": [
    "getResultLength()",
    "getResultBuffer()",
    "setto(String)"
  ],
  "getterSetterBrief": [
    "public int getResultLength(){}",
    "public char[] getResultBuffer(){}",
    "private final void setto(String s)\r\n  {}"
  ],
  "constructorDeps": {},
  "compilationUnitCode": "package ca.ualberta.cs.serl.wikidev;\n\n/*\n\n   Porter stemmer in Java. The original paper is in\n\n       Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,\n       no. 3, pp 130-137,\n\n   See also http://www.tartarus.org/~martin/PorterStemmer\n\n   History:\n\n   Release 1\n\n   Bug 1 (reported by Gonzalo Parra 16/10/99) fixed as marked below.\n   The words 'aed', 'eed', 'oed' leave k at 'a' for step 3, and b[k-1]\n   is then out outside the bounds of b.\n\n   Release 2\n\n   Similarly,\n\n   Bug 2 (reported by Steve Dyrdahl 22/2/00) fixed as marked below.\n   'ion' by itself leaves j = -1 in the test for 'ion' in step 5, and\n   b[j] is then outside the bounds of b.\n\n   Release 3\n\n   Considerably revised 4/9/00 in the light of many helpful suggestions\n   from Brian Goetz of Quiotix Corporation (brian@quiotix.com).\n\n   Release 4\n\n*/\nimport java.io.*;\n\n/**\n * Stemmer, implementing the Porter Stemming Algorithm\n *\n * The Stemmer class transforms a word into its root form.  The input\n * word can be provided a character at time (by calling add()), or at once\n * by calling one of the various stem(something) methods.\n */\nclass Stemmer {\n\n    /**\n     * @uml.property  name=\"b\" multiplicity=\"(0 -1)\" dimension=\"1\"\n     */\n    private char[] b;\n\n    /**\n     * @uml.property  name=\"i\"\n     */\n    private int i;\n\n    /**\n     * @uml.property  name=\"i_end\"\n     */\n    private int i_end;\n\n    /**\n     * @uml.property  name=\"j\"\n     */\n    private int j;\n\n    /**\n     * @uml.property  name=\"k\"\n     */\n    private int k;\n\n    private static final int INC = 50;\n\n    public Stemmer() {\n        b = new char[INC];\n        i = 0;\n        i_end = 0;\n    }\n\n    /**\n     * Add a character to the word being stemmed.  When you are finished\n     * adding characters, you can call stem(void) to stem the word.\n     */\n    public void add(char ch) {\n        if (i == b.length) {\n            char[] new_b = new char[i + INC];\n            for (int c = 0; c < i; c++) new_b[c] = b[c];\n            b = new_b;\n        }\n        b[i++] = ch;\n    }\n\n    /**\n     * Adds wLen characters to the word being stemmed contained in a portion\n     * of a char[] array. This is like repeated calls of add(char ch), but\n     * faster.\n     */\n    public void add(char[] w, int wLen) {\n        if (i + wLen >= b.length) {\n            char[] new_b = new char[i + wLen + INC];\n            for (int c = 0; c < i; c++) new_b[c] = b[c];\n            b = new_b;\n        }\n        for (int c = 0; c < wLen; c++) b[i++] = w[c];\n    }\n\n    /**\n     * After a word has been stemmed, it can be retrieved by toString(),\n     * or a reference to the internal buffer can be retrieved by getResultBuffer\n     * and getResultLength (which is generally more efficient.)\n     */\n    public String toString() {\n        return new String(b, 0, i_end);\n    }\n\n    /**\n     * Returns the length of the word resulting from the stemming process.\n     */\n    public int getResultLength() {\n        return i_end;\n    }\n\n    /**\n     * Returns a reference to a character buffer containing the results of\n     * the stemming process.  You also need to consult getResultLength()\n     * to determine the length of the result.\n     */\n    public char[] getResultBuffer() {\n        return b;\n    }\n\n    /* cons(i) is true <=> b[i] is a consonant. */\n    private final boolean cons(int i) {\n        switch(b[i]) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                return false;\n            case 'y':\n                return (i == 0) ? true : !cons(i - 1);\n            default:\n                return true;\n        }\n    }\n\n    /* m() measures the number of consonant sequences between 0 and j. if c is\n      a consonant sequence and v a vowel sequence, and <..> indicates arbitrary\n      presence,\n\n         <c><v>       gives 0\n         <c>vc<v>     gives 1\n         <c>vcvc<v>   gives 2\n         <c>vcvcvc<v> gives 3\n         ....\n   */\n    private final int m() {\n        int n = 0;\n        int i = 0;\n        while (true) {\n            if (i > j)\n                return n;\n            if (!cons(i))\n                break;\n            i++;\n        }\n        i++;\n        while (true) {\n            while (true) {\n                if (i > j)\n                    return n;\n                if (cons(i))\n                    break;\n                i++;\n            }\n            i++;\n            n++;\n            while (true) {\n                if (i > j)\n                    return n;\n                if (!cons(i))\n                    break;\n                i++;\n            }\n            i++;\n        }\n    }\n\n    /* vowelinstem() is true <=> 0,...j contains a vowel */\n    private final boolean vowelinstem() {\n        int i;\n        for (i = 0; i <= j; i++) if (!cons(i))\n            return true;\n        return false;\n    }\n\n    /* doublec(j) is true <=> j,(j-1) contain a double consonant. */\n    private final boolean doublec(int j) {\n        if (j < 1)\n            return false;\n        if (b[j] != b[j - 1])\n            return false;\n        return cons(j);\n    }\n\n    /* cvc(i) is true <=> i-2,i-1,i has the form consonant - vowel - consonant\n      and also if the second c is not w,x or y. this is used when trying to\n      restore an e at the end of a short word. e.g.\n\n         cav(e), lov(e), hop(e), crim(e), but\n         snow, box, tray.\n\n   */\n    private final boolean cvc(int i) {\n        if (i < 2 || !cons(i) || cons(i - 1) || !cons(i - 2))\n            return false;\n        {\n            int ch = b[i];\n            if (ch == 'w' || ch == 'x' || ch == 'y')\n                return false;\n        }\n        return true;\n    }\n\n    private final boolean ends(String s) {\n        int l = s.length();\n        int o = k - l + 1;\n        if (o < 0)\n            return false;\n        for (int i = 0; i < l; i++) if (b[o + i] != s.charAt(i))\n            return false;\n        j = k - l;\n        return true;\n    }\n\n    /* setto(s) sets (j+1),...k to the characters in the string s, readjusting\n      k. */\n    private final void setto(String s) {\n        int l = s.length();\n        int o = j + 1;\n        for (int i = 0; i < l; i++) b[o + i] = s.charAt(i);\n        k = j + l;\n    }\n\n    /* r(s) is used further down. */\n    private final void r(String s) {\n        if (m() > 0)\n            setto(s);\n    }\n\n    /* step1() gets rid of plurals and -ed or -ing. e.g.\n\n          caresses  ->  caress\n          ponies    ->  poni\n          ties      ->  ti\n          caress    ->  caress\n          cats      ->  cat\n\n          feed      ->  feed\n          agreed    ->  agree\n          disabled  ->  disable\n\n          matting   ->  mat\n          mating    ->  mate\n          meeting   ->  meet\n          milling   ->  mill\n          messing   ->  mess\n\n          meetings  ->  meet\n\n   */\n    private final void step1() {\n        if (b[k] == 's') {\n            if (ends(\"sses\"))\n                k -= 2;\n            else if (ends(\"ies\"))\n                setto(\"i\");\n            else if (b[k - 1] != 's')\n                k--;\n        }\n        if (ends(\"eed\")) {\n            if (m() > 0)\n                k--;\n        } else if ((ends(\"ed\") || ends(\"ing\")) && vowelinstem()) {\n            k = j;\n            if (ends(\"at\"))\n                setto(\"ate\");\n            else if (ends(\"bl\"))\n                setto(\"ble\");\n            else if (ends(\"iz\"))\n                setto(\"ize\");\n            else if (doublec(k)) {\n                k--;\n                {\n                    int ch = b[k];\n                    if (ch == 'l' || ch == 's' || ch == 'z')\n                        k++;\n                }\n            } else if (m() == 1 && cvc(k))\n                setto(\"e\");\n        }\n    }\n\n    /* step2() turns terminal y to i when there is another vowel in the stem. */\n    private final void step2() {\n        if (ends(\"y\") && vowelinstem())\n            b[k] = 'i';\n    }\n\n    /* step3() maps double suffices to single ones. so -ization ( = -ize plus\n      -ation) maps to -ize etc. note that the string before the suffix must give\n      m() > 0. */\n    private final void step3() {\n        if (k == 0)\n            return;\n        /* For Bug 1 */\n        switch(b[k - 1]) {\n            case 'a':\n                if (ends(\"ational\")) {\n                    r(\"ate\");\n                    break;\n                }\n                if (ends(\"tional\")) {\n                    r(\"tion\");\n                    break;\n                }\n                break;\n            case 'c':\n                if (ends(\"enci\")) {\n                    r(\"ence\");\n                    break;\n                }\n                if (ends(\"anci\")) {\n                    r(\"ance\");\n                    break;\n                }\n                break;\n            case 'e':\n                if (ends(\"izer\")) {\n                    r(\"ize\");\n                    break;\n                }\n                break;\n            case 'l':\n                if (ends(\"bli\")) {\n                    r(\"ble\");\n                    break;\n                }\n                if (ends(\"alli\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"entli\")) {\n                    r(\"ent\");\n                    break;\n                }\n                if (ends(\"eli\")) {\n                    r(\"e\");\n                    break;\n                }\n                if (ends(\"ousli\")) {\n                    r(\"ous\");\n                    break;\n                }\n                break;\n            case 'o':\n                if (ends(\"ization\")) {\n                    r(\"ize\");\n                    break;\n                }\n                if (ends(\"ation\")) {\n                    r(\"ate\");\n                    break;\n                }\n                if (ends(\"ator\")) {\n                    r(\"ate\");\n                    break;\n                }\n                break;\n            case 's':\n                if (ends(\"alism\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"iveness\")) {\n                    r(\"ive\");\n                    break;\n                }\n                if (ends(\"fulness\")) {\n                    r(\"ful\");\n                    break;\n                }\n                if (ends(\"ousness\")) {\n                    r(\"ous\");\n                    break;\n                }\n                break;\n            case 't':\n                if (ends(\"aliti\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"iviti\")) {\n                    r(\"ive\");\n                    break;\n                }\n                if (ends(\"biliti\")) {\n                    r(\"ble\");\n                    break;\n                }\n                break;\n            case 'g':\n                if (ends(\"logi\")) {\n                    r(\"log\");\n                    break;\n                }\n        }\n    }\n\n    /* step4() deals with -ic-, -full, -ness etc. similar strategy to step3. */\n    private final void step4() {\n        switch(b[k]) {\n            case 'e':\n                if (ends(\"icate\")) {\n                    r(\"ic\");\n                    break;\n                }\n                if (ends(\"ative\")) {\n                    r(\"\");\n                    break;\n                }\n                if (ends(\"alize\")) {\n                    r(\"al\");\n                    break;\n                }\n                break;\n            case 'i':\n                if (ends(\"iciti\")) {\n                    r(\"ic\");\n                    break;\n                }\n                break;\n            case 'l':\n                if (ends(\"ical\")) {\n                    r(\"ic\");\n                    break;\n                }\n                if (ends(\"ful\")) {\n                    r(\"\");\n                    break;\n                }\n                break;\n            case 's':\n                if (ends(\"ness\")) {\n                    r(\"\");\n                    break;\n                }\n                break;\n        }\n    }\n\n    /* step5() takes off -ant, -ence etc., in context <c>vcvc<v>. */\n    private final void step5() {\n        if (k == 0)\n            return;\n        /* for Bug 1 */\n        switch(b[k - 1]) {\n            case 'a':\n                if (ends(\"al\"))\n                    break;\n                return;\n            case 'c':\n                if (ends(\"ance\"))\n                    break;\n                if (ends(\"ence\"))\n                    break;\n                return;\n            case 'e':\n                if (ends(\"er\"))\n                    break;\n                return;\n            case 'i':\n                if (ends(\"ic\"))\n                    break;\n                return;\n            case 'l':\n                if (ends(\"able\"))\n                    break;\n                if (ends(\"ible\"))\n                    break;\n                return;\n            case 'n':\n                if (ends(\"ant\"))\n                    break;\n                if (ends(\"ement\"))\n                    break;\n                if (ends(\"ment\"))\n                    break;\n                /* element etc. not stripped before the m */\n                if (ends(\"ent\"))\n                    break;\n                return;\n            case 'o':\n                if (ends(\"ion\") && j >= 0 && (b[j] == 's' || b[j] == 't'))\n                    break;\n                /* j >= 0 fixes Bug 2 */\n                if (ends(\"ou\"))\n                    break;\n                return;\n            /* takes care of -ous */\n            case 's':\n                if (ends(\"ism\"))\n                    break;\n                return;\n            case 't':\n                if (ends(\"ate\"))\n                    break;\n                if (ends(\"iti\"))\n                    break;\n                return;\n            case 'u':\n                if (ends(\"ous\"))\n                    break;\n                return;\n            case 'v':\n                if (ends(\"ive\"))\n                    break;\n                return;\n            case 'z':\n                if (ends(\"ize\"))\n                    break;\n                return;\n            default:\n                return;\n        }\n        if (m() > 1)\n            k = j;\n    }\n\n    /* step6() removes a final -e if m() > 1. */\n    private final void step6() {\n        j = k;\n        if (b[k] == 'e') {\n            int a = m();\n            if (a > 1 || a == 1 && !cvc(k - 1))\n                k--;\n        }\n        if (b[k] == 'l' && doublec(k) && m() > 1)\n            k--;\n    }\n\n    /**\n     * Stem the word placed into the Stemmer buffer through calls to add().\n     * Returns true if the stemming process resulted in a word different\n     * from the input.  You can retrieve the result with\n     * getResultLength()/getResultBuffer() or toString().\n     */\n    public void stem() {\n        k = i - 1;\n        if (k > 1) {\n            step1();\n            step2();\n            step3();\n            step4();\n            step5();\n            step6();\n        }\n        i_end = k + 1;\n        i = 0;\n    }\n\n    /**\n     * Test program for demonstrating the Stemmer.  It reads text from a\n     * a list of files, stems each word, and writes the result to standard\n     * output. Note that the word stemmed is expected to be in lower case:\n     * forcing lower case must be done outside the Stemmer class.\n     * Usage: Stemmer file-name file-name ...\n     */\n    public static void main(String[] args) {\n        char[] w = new char[501];\n        Stemmer s = new Stemmer();\n        for (int i = 0; i < args.length; i++) try {\n            FileInputStream in = new FileInputStream(args[i]);\n            try {\n                while (true) {\n                    int ch = in.read();\n                    if (Character.isLetter((char) ch)) {\n                        int j = 0;\n                        while (true) {\n                            ch = Character.toLowerCase((char) ch);\n                            w[j] = (char) ch;\n                            if (j < 500)\n                                j++;\n                            ch = in.read();\n                            if (!Character.isLetter((char) ch)) {\n                                /* to test add(char ch) */\n                                for (int c = 0; c < j; c++) s.add(w[c]);\n                                /* or, to test add(char[] w, int j) */\n                                /* s.add(w, j); */\n                                s.stem();\n                                {\n                                    String u;\n                                    /* and now, to test toString() : */\n                                    u = s.toString();\n                                    /* to test getResultBuffer(), getResultLength() : */\n                                    /* u = new String(s.getResultBuffer(), 0, s.getResultLength()); */\n                                    System.out.print(u);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (ch < 0)\n                        break;\n                    System.out.print((char) ch);\n                }\n            } catch (IOException e) {\n                System.out.println(\"error reading \" + args[i]);\n                break;\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file \" + args[i] + \" not found\");\n            break;\n        }\n    }\n}\n",
  "classDeclarationCode": "/**\n * Stemmer, implementing the Porter Stemming Algorithm\n *\n * The Stemmer class transforms a word into its root form.  The input\n * word can be provided a character at time (by calling add()), or at once\n * by calling one of the various stem(something) methods.\n */\nclass Stemmer {\n\n    /**\n     * @uml.property  name=\"b\" multiplicity=\"(0 -1)\" dimension=\"1\"\n     */\n    private char[] b;\n\n    /**\n     * @uml.property  name=\"i\"\n     */\n    private int i;\n\n    /**\n     * @uml.property  name=\"i_end\"\n     */\n    private int i_end;\n\n    /**\n     * @uml.property  name=\"j\"\n     */\n    private int j;\n\n    /**\n     * @uml.property  name=\"k\"\n     */\n    private int k;\n\n    private static final int INC = 50;\n\n    public Stemmer() {\n        b = new char[INC];\n        i = 0;\n        i_end = 0;\n    }\n\n    /**\n     * Add a character to the word being stemmed.  When you are finished\n     * adding characters, you can call stem(void) to stem the word.\n     */\n    public void add(char ch) {\n        if (i == b.length) {\n            char[] new_b = new char[i + INC];\n            for (int c = 0; c < i; c++) new_b[c] = b[c];\n            b = new_b;\n        }\n        b[i++] = ch;\n    }\n\n    /**\n     * Adds wLen characters to the word being stemmed contained in a portion\n     * of a char[] array. This is like repeated calls of add(char ch), but\n     * faster.\n     */\n    public void add(char[] w, int wLen) {\n        if (i + wLen >= b.length) {\n            char[] new_b = new char[i + wLen + INC];\n            for (int c = 0; c < i; c++) new_b[c] = b[c];\n            b = new_b;\n        }\n        for (int c = 0; c < wLen; c++) b[i++] = w[c];\n    }\n\n    /**\n     * After a word has been stemmed, it can be retrieved by toString(),\n     * or a reference to the internal buffer can be retrieved by getResultBuffer\n     * and getResultLength (which is generally more efficient.)\n     */\n    public String toString() {\n        return new String(b, 0, i_end);\n    }\n\n    /**\n     * Returns the length of the word resulting from the stemming process.\n     */\n    public int getResultLength() {\n        return i_end;\n    }\n\n    /**\n     * Returns a reference to a character buffer containing the results of\n     * the stemming process.  You also need to consult getResultLength()\n     * to determine the length of the result.\n     */\n    public char[] getResultBuffer() {\n        return b;\n    }\n\n    /* cons(i) is true <=> b[i] is a consonant. */\n    private final boolean cons(int i) {\n        switch(b[i]) {\n            case 'a':\n            case 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n                return false;\n            case 'y':\n                return (i == 0) ? true : !cons(i - 1);\n            default:\n                return true;\n        }\n    }\n\n    /* m() measures the number of consonant sequences between 0 and j. if c is\n      a consonant sequence and v a vowel sequence, and <..> indicates arbitrary\n      presence,\n\n         <c><v>       gives 0\n         <c>vc<v>     gives 1\n         <c>vcvc<v>   gives 2\n         <c>vcvcvc<v> gives 3\n         ....\n   */\n    private final int m() {\n        int n = 0;\n        int i = 0;\n        while (true) {\n            if (i > j)\n                return n;\n            if (!cons(i))\n                break;\n            i++;\n        }\n        i++;\n        while (true) {\n            while (true) {\n                if (i > j)\n                    return n;\n                if (cons(i))\n                    break;\n                i++;\n            }\n            i++;\n            n++;\n            while (true) {\n                if (i > j)\n                    return n;\n                if (!cons(i))\n                    break;\n                i++;\n            }\n            i++;\n        }\n    }\n\n    /* vowelinstem() is true <=> 0,...j contains a vowel */\n    private final boolean vowelinstem() {\n        int i;\n        for (i = 0; i <= j; i++) if (!cons(i))\n            return true;\n        return false;\n    }\n\n    /* doublec(j) is true <=> j,(j-1) contain a double consonant. */\n    private final boolean doublec(int j) {\n        if (j < 1)\n            return false;\n        if (b[j] != b[j - 1])\n            return false;\n        return cons(j);\n    }\n\n    /* cvc(i) is true <=> i-2,i-1,i has the form consonant - vowel - consonant\n      and also if the second c is not w,x or y. this is used when trying to\n      restore an e at the end of a short word. e.g.\n\n         cav(e), lov(e), hop(e), crim(e), but\n         snow, box, tray.\n\n   */\n    private final boolean cvc(int i) {\n        if (i < 2 || !cons(i) || cons(i - 1) || !cons(i - 2))\n            return false;\n        {\n            int ch = b[i];\n            if (ch == 'w' || ch == 'x' || ch == 'y')\n                return false;\n        }\n        return true;\n    }\n\n    private final boolean ends(String s) {\n        int l = s.length();\n        int o = k - l + 1;\n        if (o < 0)\n            return false;\n        for (int i = 0; i < l; i++) if (b[o + i] != s.charAt(i))\n            return false;\n        j = k - l;\n        return true;\n    }\n\n    /* setto(s) sets (j+1),...k to the characters in the string s, readjusting\n      k. */\n    private final void setto(String s) {\n        int l = s.length();\n        int o = j + 1;\n        for (int i = 0; i < l; i++) b[o + i] = s.charAt(i);\n        k = j + l;\n    }\n\n    /* r(s) is used further down. */\n    private final void r(String s) {\n        if (m() > 0)\n            setto(s);\n    }\n\n    /* step1() gets rid of plurals and -ed or -ing. e.g.\n\n          caresses  ->  caress\n          ponies    ->  poni\n          ties      ->  ti\n          caress    ->  caress\n          cats      ->  cat\n\n          feed      ->  feed\n          agreed    ->  agree\n          disabled  ->  disable\n\n          matting   ->  mat\n          mating    ->  mate\n          meeting   ->  meet\n          milling   ->  mill\n          messing   ->  mess\n\n          meetings  ->  meet\n\n   */\n    private final void step1() {\n        if (b[k] == 's') {\n            if (ends(\"sses\"))\n                k -= 2;\n            else if (ends(\"ies\"))\n                setto(\"i\");\n            else if (b[k - 1] != 's')\n                k--;\n        }\n        if (ends(\"eed\")) {\n            if (m() > 0)\n                k--;\n        } else if ((ends(\"ed\") || ends(\"ing\")) && vowelinstem()) {\n            k = j;\n            if (ends(\"at\"))\n                setto(\"ate\");\n            else if (ends(\"bl\"))\n                setto(\"ble\");\n            else if (ends(\"iz\"))\n                setto(\"ize\");\n            else if (doublec(k)) {\n                k--;\n                {\n                    int ch = b[k];\n                    if (ch == 'l' || ch == 's' || ch == 'z')\n                        k++;\n                }\n            } else if (m() == 1 && cvc(k))\n                setto(\"e\");\n        }\n    }\n\n    /* step2() turns terminal y to i when there is another vowel in the stem. */\n    private final void step2() {\n        if (ends(\"y\") && vowelinstem())\n            b[k] = 'i';\n    }\n\n    /* step3() maps double suffices to single ones. so -ization ( = -ize plus\n      -ation) maps to -ize etc. note that the string before the suffix must give\n      m() > 0. */\n    private final void step3() {\n        if (k == 0)\n            return;\n        /* For Bug 1 */\n        switch(b[k - 1]) {\n            case 'a':\n                if (ends(\"ational\")) {\n                    r(\"ate\");\n                    break;\n                }\n                if (ends(\"tional\")) {\n                    r(\"tion\");\n                    break;\n                }\n                break;\n            case 'c':\n                if (ends(\"enci\")) {\n                    r(\"ence\");\n                    break;\n                }\n                if (ends(\"anci\")) {\n                    r(\"ance\");\n                    break;\n                }\n                break;\n            case 'e':\n                if (ends(\"izer\")) {\n                    r(\"ize\");\n                    break;\n                }\n                break;\n            case 'l':\n                if (ends(\"bli\")) {\n                    r(\"ble\");\n                    break;\n                }\n                if (ends(\"alli\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"entli\")) {\n                    r(\"ent\");\n                    break;\n                }\n                if (ends(\"eli\")) {\n                    r(\"e\");\n                    break;\n                }\n                if (ends(\"ousli\")) {\n                    r(\"ous\");\n                    break;\n                }\n                break;\n            case 'o':\n                if (ends(\"ization\")) {\n                    r(\"ize\");\n                    break;\n                }\n                if (ends(\"ation\")) {\n                    r(\"ate\");\n                    break;\n                }\n                if (ends(\"ator\")) {\n                    r(\"ate\");\n                    break;\n                }\n                break;\n            case 's':\n                if (ends(\"alism\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"iveness\")) {\n                    r(\"ive\");\n                    break;\n                }\n                if (ends(\"fulness\")) {\n                    r(\"ful\");\n                    break;\n                }\n                if (ends(\"ousness\")) {\n                    r(\"ous\");\n                    break;\n                }\n                break;\n            case 't':\n                if (ends(\"aliti\")) {\n                    r(\"al\");\n                    break;\n                }\n                if (ends(\"iviti\")) {\n                    r(\"ive\");\n                    break;\n                }\n                if (ends(\"biliti\")) {\n                    r(\"ble\");\n                    break;\n                }\n                break;\n            case 'g':\n                if (ends(\"logi\")) {\n                    r(\"log\");\n                    break;\n                }\n        }\n    }\n\n    /* step4() deals with -ic-, -full, -ness etc. similar strategy to step3. */\n    private final void step4() {\n        switch(b[k]) {\n            case 'e':\n                if (ends(\"icate\")) {\n                    r(\"ic\");\n                    break;\n                }\n                if (ends(\"ative\")) {\n                    r(\"\");\n                    break;\n                }\n                if (ends(\"alize\")) {\n                    r(\"al\");\n                    break;\n                }\n                break;\n            case 'i':\n                if (ends(\"iciti\")) {\n                    r(\"ic\");\n                    break;\n                }\n                break;\n            case 'l':\n                if (ends(\"ical\")) {\n                    r(\"ic\");\n                    break;\n                }\n                if (ends(\"ful\")) {\n                    r(\"\");\n                    break;\n                }\n                break;\n            case 's':\n                if (ends(\"ness\")) {\n                    r(\"\");\n                    break;\n                }\n                break;\n        }\n    }\n\n    /* step5() takes off -ant, -ence etc., in context <c>vcvc<v>. */\n    private final void step5() {\n        if (k == 0)\n            return;\n        /* for Bug 1 */\n        switch(b[k - 1]) {\n            case 'a':\n                if (ends(\"al\"))\n                    break;\n                return;\n            case 'c':\n                if (ends(\"ance\"))\n                    break;\n                if (ends(\"ence\"))\n                    break;\n                return;\n            case 'e':\n                if (ends(\"er\"))\n                    break;\n                return;\n            case 'i':\n                if (ends(\"ic\"))\n                    break;\n                return;\n            case 'l':\n                if (ends(\"able\"))\n                    break;\n                if (ends(\"ible\"))\n                    break;\n                return;\n            case 'n':\n                if (ends(\"ant\"))\n                    break;\n                if (ends(\"ement\"))\n                    break;\n                if (ends(\"ment\"))\n                    break;\n                /* element etc. not stripped before the m */\n                if (ends(\"ent\"))\n                    break;\n                return;\n            case 'o':\n                if (ends(\"ion\") && j >= 0 && (b[j] == 's' || b[j] == 't'))\n                    break;\n                /* j >= 0 fixes Bug 2 */\n                if (ends(\"ou\"))\n                    break;\n                return;\n            /* takes care of -ous */\n            case 's':\n                if (ends(\"ism\"))\n                    break;\n                return;\n            case 't':\n                if (ends(\"ate\"))\n                    break;\n                if (ends(\"iti\"))\n                    break;\n                return;\n            case 'u':\n                if (ends(\"ous\"))\n                    break;\n                return;\n            case 'v':\n                if (ends(\"ive\"))\n                    break;\n                return;\n            case 'z':\n                if (ends(\"ize\"))\n                    break;\n                return;\n            default:\n                return;\n        }\n        if (m() > 1)\n            k = j;\n    }\n\n    /* step6() removes a final -e if m() > 1. */\n    private final void step6() {\n        j = k;\n        if (b[k] == 'e') {\n            int a = m();\n            if (a > 1 || a == 1 && !cvc(k - 1))\n                k--;\n        }\n        if (b[k] == 'l' && doublec(k) && m() > 1)\n            k--;\n    }\n\n    /**\n     * Stem the word placed into the Stemmer buffer through calls to add().\n     * Returns true if the stemming process resulted in a word different\n     * from the input.  You can retrieve the result with\n     * getResultLength()/getResultBuffer() or toString().\n     */\n    public void stem() {\n        k = i - 1;\n        if (k > 1) {\n            step1();\n            step2();\n            step3();\n            step4();\n            step5();\n            step6();\n        }\n        i_end = k + 1;\n        i = 0;\n    }\n\n    /**\n     * Test program for demonstrating the Stemmer.  It reads text from a\n     * a list of files, stems each word, and writes the result to standard\n     * output. Note that the word stemmed is expected to be in lower case:\n     * forcing lower case must be done outside the Stemmer class.\n     * Usage: Stemmer file-name file-name ...\n     */\n    public static void main(String[] args) {\n        char[] w = new char[501];\n        Stemmer s = new Stemmer();\n        for (int i = 0; i < args.length; i++) try {\n            FileInputStream in = new FileInputStream(args[i]);\n            try {\n                while (true) {\n                    int ch = in.read();\n                    if (Character.isLetter((char) ch)) {\n                        int j = 0;\n                        while (true) {\n                            ch = Character.toLowerCase((char) ch);\n                            w[j] = (char) ch;\n                            if (j < 500)\n                                j++;\n                            ch = in.read();\n                            if (!Character.isLetter((char) ch)) {\n                                /* to test add(char ch) */\n                                for (int c = 0; c < j; c++) s.add(w[c]);\n                                /* or, to test add(char[] w, int j) */\n                                /* s.add(w, j); */\n                                s.stem();\n                                {\n                                    String u;\n                                    /* and now, to test toString() : */\n                                    u = s.toString();\n                                    /* to test getResultBuffer(), getResultLength() : */\n                                    /* u = new String(s.getResultBuffer(), 0, s.getResultLength()); */\n                                    System.out.print(u);\n                                }\n                                break;\n                            }\n                        }\n                    }\n                    if (ch < 0)\n                        break;\n                    System.out.print((char) ch);\n                }\n            } catch (IOException e) {\n                System.out.println(\"error reading \" + args[i]);\n                break;\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"file \" + args[i] + \" not found\");\n            break;\n        }\n    }\n}",
  "subClasses": []
}