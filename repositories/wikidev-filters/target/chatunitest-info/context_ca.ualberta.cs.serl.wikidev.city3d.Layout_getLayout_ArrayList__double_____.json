{
  "targetClass": "ca.ualberta.cs.serl.wikidev.city3d.Layout",
  "targetMethod": "getLayout(ArrayList, double[][])",
  "dependentFields": {
    "ca.ualberta.cs.serl.wikidev.artifacts.IArtifact": "protected ArrayList<RelatedArtifact> directlyRelatedArtifacts;\nprotected User owner;\nprotected Timestamp timestamp;\nprotected Project project;\nprotected Document document;\nprotected int index;\nprotected int uid;\nprotected double[] coords;\nprotected boolean enforced;\nprivate String type;\nprivate int id;\nprotected User lastEditor;\nprotected Timestamp lastModified;\nprotected Timestamp created;",
    "ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling": "private double[][] betaMatrix;\nprivate double[][] alphaMatrix;\nprivate double[][] hMatrix;\nprivate double[][] distanceMatrix;\nprivate double[][] squareDistanceMatrix;\nprivate int dimensions;",
    "ca.ualberta.cs.serl.wikidev.city3d.Layout": "protected ArrayList<CityBlock> cityBlocks;\npublic static final String URLprefix = \"http://hypatia.cs.ualberta.ca/ucosp/index.php/\";",
    "ca.ualberta.cs.serl.wikidev.clustering.SammonsProjection": "private int maxIteration;\nprivate double lambda = 1;\nprivate double[][] InputData;\nprivate int[] indicesI;\nprivate int[] indicesJ;\nprivate int OutputDimension;\nprotected double[][] _distanceMatrix;\nprivate int Count;\nprivate double[][] Projection;\nprivate int Iteration;"
  },
  "dependentMethods": {
    "ca.ualberta.cs.serl.wikidev.artifacts.IArtifact": "public void setCoords(double[] coords){}",
    "ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling": "public double[][] cMDS(){}",
    "ca.ualberta.cs.serl.wikidev.city3d.Layout": "private void pushBuildings(double minX, double minY, double range){}\nprivate void redistributeBuildings(){}",
    "ca.ualberta.cs.serl.wikidev.clustering.SammonsProjection": "public void CreateMapping()\r\n{}\npublic double[][] getProjection(){}"
  },
  "dependentMethodBodies": {
    "ca.ualberta.cs.serl.wikidev.artifacts.IArtifact": "public void setCoords(double[] coords) {\n\t\tthis.coords = coords;\n\t}",
    "ca.ualberta.cs.serl.wikidev.clustering.MultidimensionalScaling": "public double[][] cMDS() {\n\t\t//dimensions = 2;\n\t\t\n\t\tgetHMatrix();\n\t\tdouble[][] B = getNewBetaMatrix();\n\t\tdouble[] eigenValues = MatrixOperator.getEigenValues(B);\n\t\tdouble[][] eigenVectors = MatrixOperator.getEigenVectors(B);\n\t\tfor(int k=0; k<eigenValues.length; k++) {\n\t\t\tif(eigenValues[k] < 0) {\n\t\t\t\teigenValues[k] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<eigenValues.length; k++) {\n\t\t\tif(eigenValues[k] > 0) {\n\t\t\t\tdimensions++;\n\t\t\t}\n\t\t}\n\t\t//dimensions = 2;\n\t\tdouble[][] coordinates = new double[distanceMatrix.length][dimensions];\n\t\tdouble[] sqrtEigenValues = MatrixOperator.vectorPower(eigenValues, 1.0/2.0);\n\t\tdouble[][] eigenValuesDiagonal = MatrixOperator.diagonal(sqrtEigenValues);\n\t\tdouble[][] x = MatrixOperator.matrixProduct(eigenVectors, eigenValuesDiagonal);\n\t\t/*for(int i=0;i<distanceMatrix.length;i++) {\n\t\t\tfor(int j=0;j<dimensions;j++) {\n\t\t\t\tif(eigenVectors[j][i] >= 0.0) {\n\t\t\t\t\tcoordinates[i][j] = (float)eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoordinates[i][j] = (float)-eigenVectors[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tArrayList<Integer> indices = new ArrayList<Integer>();\n\t\tint counter = 0;\n\t\tfor(int i=0; i<x.length;i++) {\n\t\t\tif(x[0][i] != 0.0) {\n\t\t\t\tindices.add(i);\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif(counter == dimensions) break;\n\t\t}\n\t\tif (!indices.isEmpty()) {\n\t\t\tfor (int i = 0; i < x.length; i++) {\n\t\t\t\tfor (int j = 0; j < indices.size(); j++) {\n\t\t\t\t\tcoordinates[i][j] = x[i][indices.get(j)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn coordinates;\n\t\t}\n\t\telse {\n\t\t\treturn coordinates;\n\t\t}\n\t\t\t\n\t}",
    "ca.ualberta.cs.serl.wikidev.city3d.Layout": "private void pushBuildings(double minX, double minY, double range) {\n\t\tfor (CityBlock block : cityBlocks) {\n\t\t\tif (block.getArtifacts().size() > 4\n\t\t\t\t\t&& block.getArtifacts().size() <= 16) {\n\t\t\t\tdouble blockMinX = minX + block.getIndex().x * (range / 16);\n\t\t\t\tdouble blockMaxX = minX + (block.getIndex().x + 1)\n\t\t\t\t\t\t* (range / 16);\n\t\t\t\tdouble blockMinY = minY + block.getIndex().y * (range / 16);\n\t\t\t\tdouble blockMaxY = minY + (block.getIndex().y + 1)\n\t\t\t\t\t\t* (range / 16);\n\t\t\t\tdouble rX = Math.ceil(blockMaxX - blockMinX);\n\t\t\t\tdouble rY = Math.ceil(blockMaxY - blockMinY);\n\t\t\t\tdouble blockR = 0;\n\t\t\t\tif (rX > rY) {\n\t\t\t\t\tblockR = rX;\n\t\t\t\t} else {\n\t\t\t\t\tblockR = rY;\n\t\t\t\t}\n\t\t\t\tdouble[][] subblockCenters = new double[16][3];\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tdouble[] subCenter = {\n\t\t\t\t\t\t\t\tblockMinX + i * blockR + blockR / 2,\n\t\t\t\t\t\t\t\tblockMinY + j * blockR + blockR / 2, 0 };\n\t\t\t\t\t\tsubblockCenters[j + i * 4] = subCenter;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tredistributeArtifactsInBlock(block, subblockCenters);\n\t\t\t}\n\t\t}\n\t}\nprivate void redistributeBuildings() {\n\t\tfor (CityBlock block : cityBlocks) {\n\t\t\tif (block.getArtifacts().size() > 16) {\n\t\t\t\tblock.setMarked(true);\n\t\t\t\tHashMap<IArtifact, Integer> finalArtifacts = new HashMap<IArtifact, Integer>();\n\t\t\t\tfor (IArtifact artifact : block.getArtifacts().keySet()) {\n\t\t\t\t\tif (artifact.isEnforced()) {\n\t\t\t\t\t\tfinalArtifacts.put(artifact, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (finalArtifacts.size() < 16) {\n\t\t\t\t\tIArtifact artifact = getClosestArtifact(block);\n\t\t\t\t\tfinalArtifacts.put(artifact, -1);\n\t\t\t\t\tblock.getArtifacts().remove(artifact);\n\t\t\t\t}\n\t\t\t\tCollection<IArtifact> surplus = block.getArtifacts().keySet();\n\t\t\t\tblock.setArtifacts(finalArtifacts);\n\t\t\t\tfor (IArtifact artifact : surplus) {\n\t\t\t\t\tCityBlock closestBlock = getClosestBlock(artifact);\n\t\t\t\t\tartifact.setEnforced(true);\n\t\t\t\t\tclosestBlock.addArtifact(artifact, -1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
    "ca.ualberta.cs.serl.wikidev.clustering.SammonsProjection": "public void CreateMapping()\n\t{\n\t\tfor (int i = maxIteration; i >= 0; i--)\n\t\t\tthis.Iterate();\n\t}\npublic double[][] getProjection() {\n\t\treturn Projection;\n\t}"
  }
}